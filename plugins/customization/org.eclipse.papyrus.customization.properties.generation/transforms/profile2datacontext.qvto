modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";
modeltype PropertyContext uses "http://www.eclipse.org/papyrus/properties/contexts/0.9";
modeltype PropertyEnvironment uses "http://www.eclipse.org/papyrus/properties/environment/0.9";
modeltype PRoot uses "http://www.eclipse.org/papyrus/properties/root";
modeltype Constraints uses "http://www.eclipse.org/papyrus/constraints/0.9";

transformation stereotype2datacontext(in profile : UML, out context : PropertyContext, in uml : PropertyContext, in pRoot : PRoot);

main() {
	profile.rootObjects()[Profile]->map toContext();
}

mapping Profile::toContext() : c:Context, root:DataContextRoot{
	object c : Context {
		name := self.name;
		dataContexts := root;
		dependencies := uml.rootObjects()[Context];
	};
	
	self.packagedElement->select(e | e.isView())->map toDataContextElement();
	
	object root : DataContextRoot{
		name := self.name;
		label := self.name;
		elements := self.packagedElement->select(e | e.isView())->map toDataContextElement().element
			->union(self.packagedElement->select(e | e.oclIsKindOf(Package))->map toDataContextPackage());
		modelElementFactory := pRoot.rootObjects()[PropertiesRoot].environments.modelElementFactories
			->any(e | e.factoryClass = 'org.eclipse.papyrus.uml.properties.modelelement.StereotypeModelElementFactory');
	};
}

query Element::isView() : Boolean {
	return self.oclIsTypeOf(Stereotype) or self.oclIsTypeOf(DataType);
}

abstract mapping Element::toDataContextElement() : element : DataContextElement, viewSingle : View, viewMultiple : View;

abstract mapping PackageableElement::toDataContextPackage() : DataContextPackage {	
	name := self.name;
}

mapping Package::toDataContextPackage() : DataContextPackage inherits PackageableElement::toDataContextPackage{
	elements := self.packagedElement->map toDataContextElement().element->union(
		self.packagedElement->select(e | e.oclIsKindOf(Package))->map toDataContextPackage()
	);
}

abstract mapping Classifier::toDCElement() : element : DataContextElement, viewSingle : View, viewMultiple : View {
	element.name := self.name;

	viewSingle.name := 'Single '+self.name;
	viewSingle.automaticContext := true;
	viewSingle.datacontexts := element;
	viewSingle.elementMultiplicity := 1;
	viewSingle.constraints := self.map toConstraint(viewSingle);
	viewSingle.context := self.getContext();
	
	viewMultiple.name := 'Multiple '+self.name;
	viewMultiple.automaticContext := true;
	viewMultiple.datacontexts := element;
	viewMultiple.elementMultiplicity := -1;
	viewMultiple.constraints := self.map toConstraint(viewMultiple);
	viewMultiple.context := self.getContext();
}

mapping Stereotype::toDataContextElement() : element : DataContextElement, viewSingle : View, viewMultiple : View inherits Classifier::toDCElement{
	element.properties := self.attribute->select(e | e.isAttribute(self))->map toProperty();
	element.supertypes := self.generalization.target->map toDataContextElement().element->union(
		self.ownedAttribute->select(e | not e.isAttribute(self)).getDataContextElement()->asSet()
	);
}

mapping DataType::toDataContextElement() : element : DataContextElement, viewSingle : View, viewMultiple : View inherits Classifier::toDCElement when {
	self.oclIsTypeOf(DataType) -- Exclude primitive types from generation
}{
	element.properties := self.attribute->map toProperty();
	element.supertypes := self.generalization.target->map toDataContextElement().element->union(
		self.ownedAttribute->getDataContextElement()->asSet()
	);
}

query Package::getRootPackage() : Package {
	var package : Package;
	if self.nestingPackage.oclIsUndefined() then 
		package := self
	else
		package := self.nestingPackage.getRootPackage()
	endif;
	return package;
}

query Classifier::getRootProfile() : Profile {
	return self.package.getRootPackage().oclAsType(Profile);
}

query Classifier::getContext() : PropertyContext::Context {
	return self.getRootProfile().map toContext().c;
}

mapping Classifier::toConstraint(view : View) : SimpleConstraint{
	name := "is" + view.name.replace(' ', '');
	display := view;
	constraintType := pRoot.objectsOfType(PropertiesRoot).environments.constraintTypes->any(e | e.constraintClass = 'org.eclipse.papyrus.uml.properties.constraints.HasStereotypeConstraint');
	var stereotypeName := object ValueProperty {
		name := 'stereotypeName';
		value := self.qualifiedName;
	};
	properties := stereotypeName;
}

query Property::getDataContextElement() : DataContextElement {
	var extension := self.association.memberEnd->any(e | not self.association.ownedEnd->includes(e));
	var metaclassName := extension.type.name;
	return uml.rootObjects()[Context].dataContexts->any(e | e.name = 'UML').elements->any(e | e.name = metaclassName);
}

query UML::Property::isAttribute(stereo : Stereotype) : Boolean{
	return not self.name.startsWith('base_');
}

mapping UML::Property::toProperty() : PropertyContext::Property {
	name := self.name;
	type := self.type.toType();
}

query UML::Type::toType() : PropertyEnvironment::Type {
	-- Unknown cases are handled as Strings
	var type : PropertyEnvironment::Type := PropertyEnvironment::Type::String;
	switch {
		case (self.oclIsKindOf(Class)) type := PropertyEnvironment::Type::Reference;
		case (self.oclIsKindOf(Enumeration)) type := PropertyEnvironment::Type::Enumeration;
		case (self.oclIsKindOf(PrimitiveType)) switch {
			case (self.name = "String") type := PropertyEnvironment::Type::String; 
			case (self.name = "Integer") type := PropertyEnvironment::Type::Integer;
			case (self.name = "Boolean") type := PropertyEnvironment::Type::Boolean;
		};
	};
	return type;
}
