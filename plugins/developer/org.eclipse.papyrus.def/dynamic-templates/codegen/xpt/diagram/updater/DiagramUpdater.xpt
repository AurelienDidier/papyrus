/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/papyrus/2009/papyrusgmfgenextension"»

«EXTENSION MetaModel»
«EXTENSION xpt::EMFUtils»
«EXTENSION xpt::diagram::updater::Utils»
«EXTENSION xpt::diagram::editpolicies::LinkUtils»
«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::mutatingUtils»

«REM»Mutating Canvas :: semantic children of diagram must select the correct features depending on the element that is the actual canvas«ENDREM»
«REM»@author :: fjcano (C) 2008«ENDREM»
«AROUND getSemanticChildrenOfView FOR gmfgen::GenContainerBase-»
	«IF GenDiagram.isInstance(this) && getReferencingObjects().typeSelect(AlternateCanvas).size() > 0»
«REM»
	The switch that performs the correct job according to the canvas' EObject
«ENDREM»
	«EXPAND createUpdaterSwitch FOR this»
	«REM»The canvas get method that depends on the Switch«ENDREM»
	«EXPAND xpt::Common::generatedMemberComment»
	public static java.util.List «EXPAND xpt::diagram::updater::DiagramUpdater::getSemanticChildrenMethodName»(org.eclipse.gmf.runtime.notation.View view) {
		«IF getSemanticChildrenChildFeatures(this).size() > 0 || getPhantomNodes(this).size() > 0-»
		«EXPAND defineModelElement-»
		aSwitch.setInfo(view);
		java.util.List<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»> result = aSwitch.doSwitch(modelElement);
		if (result == null || result.size() <= 0) {
			return java.util.Collections.EMPTY_LIST;
		}
		«IF !getPhantomNodes(this).isEmpty()-»
		org.eclipse.emf.ecore.resource.Resource resource = modelElement.eResource();
		for (java.util.Iterator semanticIterator = getPhantomNodesIterator(resource); semanticIterator.hasNext();) {
			org.eclipse.emf.ecore.EObject childElement = (org.eclipse.emf.ecore.EObject) semanticIterator.next();
			if (childElement == modelElement) {
				continue;
			}
			«EXPAND addNextIfPhantom FOREACH getPhantomNodes(this)-»
		}
		«ENDIF-»		
		return result;
		«ELSE-»
		return java.util.Collections.EMPTY_LIST;
		«ENDIF-»
	}
	«ELSE»
	«targetDef.proceed()-»
	«ENDIF»
«ENDAROUND»


«DEFINE checkChildElementVisualID(boolean inLoop) FOR gmfgen::GenNode-»
if (visualID == «EXPAND xpt::editor::VisualIDRegistry::visualID») {
	result.add(new «getDiagram().editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»(«IF null != modelFacet.childMetaFeature»«EXPAND MetaModel::DowncastToEObject("childElement") FOR getTypeGenClassX(modelFacet.childMetaFeature)»«ENDIF», visualID));
«IF inLoop-»
	continue;
«ENDIF-»
}
«ENDDEFINE»


«REM»The EcoreSwitch that will navigate the proper features according to the canvas' EObject«ENDREM»
«DEFINE createUpdaterSwitch FOR gmfgen::GenDiagram»
«EXPAND xpt::Common::generatedMemberComment»
	static class ThisDiagramUpdaterSwitch extends es.cv.gvcase.mdt.common.util.BasicEcoreSwitch<java.util.List<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»>, org.eclipse.gmf.runtime.notation.View> {
		@Override
		public java.util.List<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»> doSwitch(org.eclipse.emf.ecore.EObject modelElement) {
			«REM»getInfo provides the View«ENDREM»
			final org.eclipse.gmf.runtime.notation.View view = getInfo();
			if (view == null) {
				return java.util.Collections.EMPTY_LIST;
			}
			
			«getModelSwitchQualifiedName(domainDiagramElement)»<java.util.List<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»>> aSwitch = new «getModelSwitchQualifiedName(domainDiagramElement)»<java.util.List<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»>>() {
				«REM»Start of cases«ENDREM»
				@Override
				public java.util.List<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»> case«domainDiagramElement.ecoreClass.name»(«EXPAND MetaModel::MetaClass FOR domainDiagramElement» modelElement) {
					java.util.List<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»> result = new java.util.LinkedList<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»>();
					«FOREACH getSemanticChildrenChildFeatures(this) AS childMetaFeature-»
						«IF null == childMetaFeature-»
							{ /*FIXME no containment/child feature found in the genmodel, toolsmith need to specify Class here manually*/ childElement = /*FIXME no containment/child feature found in the genmodel, toolsmith need to specify correct one here manually*/;
						«ELSEIF isListType(childMetaFeature)-»
					for (java.util.Iterator it = «EXPAND xpt::Common::getFeatureValue("modelElement", getModelElementType()) FOR childMetaFeature».iterator(); it.hasNext();) {
						«EXPAND MetaModel::MetaClass FOR getTypeGenClassX(childMetaFeature)» childElement = («getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))») it.next();
						«ELSE-»
					{ «getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))» childElement = «EXPAND xpt::Common::getFeatureValue("modelElement", getModelElementType()) FOR childMetaFeature»;
						«ENDIF-»
						int visualID = «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(view, «EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(childMetaFeature)»childElement);
						«EXPAND checkChildElementVisualID(null != childMetaFeature && isListType(childMetaFeature)) FOREACH getSemanticChildren(this, childMetaFeature)-»
					}
					«ENDFOREACH-»
					«IF !getPhantomNodes(this).isEmpty()-»
					org.eclipse.emf.ecore.resource.Resource resource = modelElement.eResource();
					for (java.util.Iterator semanticIterator = getPhantomNodesIterator(resource); semanticIterator.hasNext();) {
						org.eclipse.emf.ecore.EObject childElement = (org.eclipse.emf.ecore.EObject) semanticIterator.next();
						if (childElement == modelElement) {
							continue;
						}
					«EXPAND addNextIfPhantom FOREACH getPhantomNodes(this)-»
					}
					«ENDIF-»		
					return result;
				}
				
				«FOREACH getReferencingObjects().typeSelect(AlternateCanvas) AS referencer»
				@Override
				public java.util.List<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»> case«referencer.domainDiagramElement.ecoreClass.name»(«getQualifiedInterfaceName(referencer.domainDiagramElement)» modelElement) {
					java.util.List<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»> result = new java.util.LinkedList<«editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»>();
					«REM»«FOREACH getSemanticChildrenChildFeatures(this) AS childMetaFeature-»«ENDREM»
					«FOREACH getMutatingChildrenFeatures(referencer) AS childMetaFeature-»
						«IF null == childMetaFeature-»
							{ /*FIXME no containment/child feature found in the genmodel, toolsmith need to specify Class here manually*/ childElement = /*FIXME no containment/child feature found in the genmodel, toolsmith need to specify correct one here manually*/;
						«ELSEIF isListType(childMetaFeature)-»
					for (java.util.Iterator it = «EXPAND xpt::Common::getFeatureValue("modelElement", referencer.domainDiagramElement) FOR childMetaFeature».iterator(); it.hasNext();) {
						«getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))» childElement = («getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))») it.next();
						«ELSE-»
					{ «getQualifiedInterfaceName(getTypeGenClassX(childMetaFeature))» childElement = «EXPAND xpt::Common::getFeatureValue("modelElement", referencer.domainDiagramElement) FOR childMetaFeature»;
						«ENDIF-»
						int visualID = «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(view, «EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(childMetaFeature)»childElement);
						«REM»«EXPAND checkChildElementVisualID(null != childMetaFeature && isListType(childMetaFeature)) FOREACH getSemanticChildren(this, childMetaFeature)-»«ENDREM»
						«EXPAND checkMutatingChildElementVisualID(null != childMetaFeature && isListType(childMetaFeature)) FOREACH getMutatingSemanticChildren(referencer, childMetaFeature)-»
					}
					«ENDFOREACH-»
					«REM»«IF !getPhantomNodes(this).isEmpty()-»
					org.eclipse.emf.ecore.resource.Resource resource = modelElement.eResource();
					for (java.util.Iterator semanticIterator = getPhantomNodesIterator(resource); semanticIterator.hasNext();) {
						org.eclipse.emf.ecore.EObject childElement = (org.eclipse.emf.ecore.EObject) semanticIterator.next();
						if (childElement == modelElement) {
							continue;
						}
					«EXPAND addNextIfPhantom FOREACH getPhantomNodes(this)-»
					}
					«ENDIF-»
					«ENDREM»		
					return result;
				}
				«ENDFOREACH»
				
				«REM»End of cases«ENDREM»			
			};
			return aSwitch.doSwitch(modelElement);
		}
	};

	«REM»The global variable for a Switch«ENDREM»
	«EXPAND xpt::Common::generatedMemberComment»
	private static ThisDiagramUpdaterSwitch aSwitch = new ThisDiagramUpdaterSwitch();
«ENDDEFINE»

«REM» Mutating check Visual ID «ENDREM»
«DEFINE checkMutatingChildElementVisualID(boolean inLoop) FOR papyrusgmfgenextension::AlternateGenTopLevelNode-»
	if (visualID == «EXPAND visualID») {
		result.add(new «genTopLevelNode.getDiagram().editorGen.diagramUpdater.getNodeDescriptorQualifiedClassName()»(«IF null != typeModelFacet.childMetaFeature»«EXPAND xpt::Common::castToEObject FOR getTypeGenClassX(typeModelFacet.childMetaFeature)»«ENDIF»childElement, visualID));
	«IF inLoop-»
		continue;
	«ENDIF-»
	}
«ENDDEFINE»

«REM» Mutating VisualID espansion «ENDREM»
«DEFINE visualID FOR papyrusgmfgenextension::AlternateGenTopLevelNode»
	«EXPAND xpt::editor::VisualIDRegistry::visualID FOR genTopLevelNode»
«ENDDEFINE»

«DEFINE defineModelElement FOR gmfgen::GenContainerBase-»
if (!view.isSetElement()) {
	return java.util.Collections.EMPTY_LIST;
}
«EXPAND MetaModel::DeclareAndAssign("modelElement", "view.getElement()") FOR getModelElementType()»
«ENDDEFINE»

«DEFINE getContainedLinksByTypeMethodBody(gmfgen::GenLink genLink, boolean sourceVarDefined) FOR gmfgen::TypeLinkModelFacet-»
java.util.Collection result = new java.util.LinkedList();
	«LET childMetaFeature.isListType() AS inLoop-»
«IF inLoop-»
for (java.util.Iterator links = «EXPAND MetaModel::getFeatureValue("container", containmentMetaFeature.genClass) FOR childMetaFeature».iterator(); links.hasNext();) {
	org.eclipse.emf.ecore.EObject linkObject = (org.eclipse.emf.ecore.EObject ) links.next();
	if («EXPAND MetaModel::NotInstance("linkObject") FOR metaClass») {
		continue;
	}
	«EXPAND MetaModel::DeclareAndAssign("link", "linkObject") FOR metaClass»
«ELSE-»
	«IF getTypeGenClassX(childMetaFeature) == metaClass-»
		«EXPAND MetaModel::DeclareAndAssign("link", "container", getSourceType(), childMetaFeature) FOR metaClass»
	«ELSE-»
		«EXPAND MetaModel::DeclareAndAssign("linkObject", "container", getSourceType(), childMetaFeature) FOR getTypeGenClassX(childMetaFeature)»
		if («EXPAND MetaModel::NotInstance("linkObject") FOR metaClass») {
			return result;
		}
		«EXPAND MetaModel::DeclareAndAssign("link", "linkObject") FOR metaClass»
	«ENDIF-»
«ENDIF-»
		«EXPAND checkLinkVisualID(genLink, inLoop)-»
		
		«REM»BEGIN: PapyrusGenCode«ENDREM»
		«REM»Test if the source and target reference the same feature, in this case generation with collection«ENDREM»
		
		«IF this.sourceMetaFeature==this.targetMetaFeature»
			//Papyrus GenCode 
		    «EXPAND defineLinkDestinationForSet(inLoop)-»
			«IF null != sourceMetaFeature-»
				«EXPAND defineLinkSource(inLoop)-»
				«IF sourceVarDefined-»
					«EXPAND checkLinkSource(inLoop)-»
				«ENDIF-»
				«EXPAND addLinkDescriptor(genLink, "src", "dst")-»
			«ELSE-»
				«EXPAND addLinkDescriptor(genLink, "container", "dst")-»
			«ENDIF-»
		«ELSE»
		«REM»END: PapyrusGenCode«ENDREM»
			«EXPAND defineLinkDestination(inLoop)-»
			«IF null != sourceMetaFeature-»
				«EXPAND defineLinkSource(inLoop)-»
				«IF sourceVarDefined-»
					«EXPAND checkLinkSource(inLoop)-»
				«ENDIF-»
				«EXPAND addLinkDescriptor(genLink, "src", "dst")-»
			«ELSE-»
				«EXPAND addLinkDescriptor(genLink, "container", "dst")-»
			«ENDIF-»
		«REM»BEGIN: PapyrusGenCode«ENDREM»
		«ENDIF-»
		«REM»END: PapyrusGenCode«ENDREM»
«IF inLoop-»
}
«ENDIF-»
	«ENDLET-»
return result;	
«ENDDEFINE»

«DEFINE defineLinkSource(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
	«IF sourceMetaFeature.isListType()-»
java.util.List sources = «EXPAND MetaModel::getFeatureValue("link", metaClass) FOR sourceMetaFeature»;
«REM»BEGIN: PapyrusGenCode«ENDREM»
«REM»In the case of set greater that 1! not equal«ENDREM»
Object theSource = sources.size() >= 1 ? sources.get(0) : null;
«REM»END: PapyrusGenCode«ENDREM»
if («EXPAND MetaModel::NotInstance("theSource") FOR getSourceType()») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«EXPAND MetaModel::DeclareAndAssign("src", "theSource", true) FOR getSourceType()»
	«ELSE-»
«EXPAND MetaModel::DeclareAndAssign("src", "link", metaClass, sourceMetaFeature) FOR getSourceType()»
	«ENDIF-»
«ENDDEFINE»

«DEFINE checkLinkSource(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
if (src != source) {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«ENDDEFINE»
«REM»BEGIN: PapyrusGenCode«ENDREM»
«REM»Define target and source that can manage set«ENDREM»
«DEFINE defineLinkDestinationForSet(boolean inLoop) FOR gmfgen::TypeLinkModelFacet-»
	«IF targetMetaFeature.isListType()-»
java.util.List targets = «EXPAND MetaModel::getFeatureValue("link", metaClass) FOR targetMetaFeature»;
Object theTarget = targets.size() >=2 ? targets.get(1) : null;
if («EXPAND MetaModel::NotInstance("theTarget") FOR getTargetType()») {
	«EXPAND stopLinkProcessing(inLoop)-»
}
«EXPAND MetaModel::DeclareAndAssign("dst", "theTarget", true) FOR getTargetType()»
	«ELSE-»
«EXPAND MetaModel::DeclareAndAssign("dst", "link", metaClass, targetMetaFeature) FOR getTargetType()»
	«ENDIF-»
«ENDDEFINE»
«REM»END: PapyrusGenCode«ENDREM»
