/*****************************************************************************
 * Copyright (c) 2015 CEA LIST.
 *    
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Ed Seidewitz
 * 
 *****************************************************************************/
import AlfCommon2UML;

modeltype Alf uses "http://www.omg.org/spec/ALF/20120827";
modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";

transformation AlfExpression2UML(in alf : Alf, inout uml : UML)
	extends transformation AlfCommon2UML(in Alf, inout UML);

// ACTIVITY GRAPHS

intermediate class ActivityGraph {
	nodes : Set(ActivityNode);
	edges : Set(ActivityEdge);
	resultSource : ActivityNode;
	indexSource : ActivityNode;
	objectSource : ActivityNode;
}

helper newActivityGraph() : ActivityGraph {
	return object ActivityGraph {};
}

helper ActivityGraph::addTo(inout activity : Activity) : ActivityGraph {
	activity.structuredNode += self.nodes[StructuredActivityNode] ;
	activity.ownedNode += self.nodes[not oclIsKindOf(StructuredActivityNode)];
	activity.edge += self.edges;
	return self;
}

helper ActivityGraph::addTo(inout graph : ActivityGraph) : ActivityGraph {
	graph.nodes += self.nodes;
	graph.edges += self.edges;
	return self;
}

helper ActivityGraph::addToStructuredNode(inout graph : ActivityGraph, inout structuredNode : StructuredActivityNode) {
	addToStructuredNode(graph, structuredNode, self.nodes, self.edges);
}

helper ActivityGraph::addStructuredActivityNodeTo(inout graph : ActivityGraph, name : String) : StructuredActivityNode {
	return addStructuredActivityNode(graph, name, self.nodes, self.edges);
}

helper addStructuredActivityNode(inout graph : ActivityGraph, name : String, 
	nodes : Set(ActivityNode), edges : Set(ActivityEdge)) : StructuredActivityNode {
	graph.nodes += var structuredNode ::= new StructuredActivityNode(name);
	addToStructuredNode(graph, structuredNode, nodes, edges);
	return structuredNode;
}

helper addToStructuredNode(inout graph : ActivityGraph, inout structuredNode : StructuredActivityNode, 
	nodes : Set(ActivityNode), edges : Set(ActivityEdge)) {
	graph.edges += addToStructuredNode(structuredNode, nodes, edges);
}

helper addExpansionRegion(inout graph : ActivityGraph, name : String, mode : ExpansionKind, 
	nodes : Set(ActivityNode), edges : Set(ActivityEdge), 
	inputSource : ActivityNode, inputTarget : ActivityNode, resultSource : ActivityNode) : ExpansionRegion {
	graph.nodes += var region ::= new ExpansionRegion(name, mode);
	
	// Add elements to the expansion region.
	addToExpansionRegion(graph, region, nodes, edges);
	
	// Add an input expansion node.
	var inputName := if inputSource = null then null else inputSource.name endif;
	graph.nodes += var inputNode ::= new ExpansionNode(inputName, region, true);
	
	// Connect the input source (if any) to the region input node.
	if inputSource <> null then {
		graph.edges += new ObjectFlow(inputSource, inputNode);
	} endif;
	
	// Connect the region input node to the internal input target (if any).
	if inputTarget <> null then {
		region.edge += new ObjectFlow(inputNode, inputTarget);
	} endif;
	
	// Connect the internal result source (if any) to a region output node.
	if resultSource <> null then {
		graph.nodes += var outputNode ::= new ExpansionNode(resultSource.name, region, false);
		region.edge += new ObjectFlow(resultSource, outputNode);
	} endif;
	
	return region;
}

helper addToExpansionRegion(inout graph : ActivityGraph, inout region : ExpansionRegion, nodes: Set(ActivityNode), edges : Set(ActivityEdge)) {
	var remainingEdges := addToExpansionRegion(region, nodes, edges);
	graph.edges += remainingEdges;
	graph.nodes += remainingEdges.source[ExpansionNode];
}

helper createDecisionGraph(
	label : String, isObjectFlow : Boolean,
	inputSource : ActivityNode, decisionSource : ActivityNode,
	trueTarget : ActivityNode, falseTarget : ActivityNode
) : ActivityGraph {
	var graph := object ActivityGraph {};
	
	graph.nodes += graph.resultSource := var decisionNode ::= 
		object DecisionNode {
			name := "Decision(" + label + ")";
		};
	
	if inputSource <> null then {
		graph.edges += createFlow(inputSource, decisionNode, isObjectFlow, null);
	} endif;
	
	if decisionSource <> null then {
		graph.edges += decisionNode.decisionInputFlow := new ObjectFlow(decisionSource, decisionNode);
	} endif;
	
	if trueTarget <> null then {
		graph.edges += createFlow(decisionNode, trueTarget, isObjectFlow, true);
	} endif;
	
	if falseTarget <> null then {
		graph.edges += createFlow(decisionNode, falseTarget, isObjectFlow, false);
	} endif;
	
	return graph;
}

helper createFlow(source : ActivityNode, target : ActivityNode, isObjectFlow : Boolean, guard : Boolean) : ActivityEdge {
	var activityEdge :=
		if isObjectFlow then new ObjectFlow(source, target)
		else new ControlFlow(source, target)
		endif;
	if guard <> null then {
		activityEdge.guard := object LiteralBoolean {
			name := guard.toString();
			value := guard;
		};
	} endif;
	return activityEdge;
}

helper createObjectDecisionGraph(
	label : String,
	inputSource : ActivityNode, decisionSource : ActivityNode,
	trueTarget : ActivityNode, falseTarget : ActivityNode
) : ActivityGraph {
	return createDecisionGraph(label, true, inputSource, decisionSource, trueTarget, falseTarget);
}

helper createControlDecisionGraph(
	label : String,
	inputSource : ActivityNode, decisionSource : ActivityNode,
	trueTarget : ActivityNode, falseTarget : ActivityNode
) : ActivityGraph {
	return createDecisionGraph(label, false, inputSource, decisionSource, trueTarget, falseTarget);
}

// ASSIGNED SOURCES

/*
 * Returns the activity node to be used as the source of the value for a
 * given local name that has this syntax element as its assigned source.
*/
query SyntaxElement::assignedValueSource(assignedName : String) : ActivityNode {
	return null;
}

query Expression::assignedValueSource(assignedName : String) : ActivityNode {
	// TODO: Remove this.
	return self.map toActivityGraph().resultSource;
}

mapping AssignedSource::toActivityNode() : ActivityNode
	when { self.source <> null } {
init {
	result := self.source.assignedValueSource(self.name);
}
}

query find(assignments : Set(AssignedSource), assignedName : String) : AssignedSource {
	var sourcedAssignments := assignments[name = assignedName and source <> null];
	return
		if sourcedAssignments->isEmpty() then null
		else sourcedAssignments->any(true) endif;
}

helper AssignedSource::toInputPin() : InputPin {
	return new InputPin(self.name, toType(self.type), self.lower, self.upper);
}

helper AssignedSource::toOutputPin() : OutputPin {
	return new OutputPin(self.name, toType(self.type), self.lower, self.upper);
}

// EXPRESSIONS

// General

abstract mapping Expression::toActivity() : Activity {
  ownedParameter := object Parameter {
    direction := ParameterDirectionKind::_return;
    type := if self.type = null then null else self.type.toUml().oclAsType(Classifier) endif;
    lower := self.lower;
    upper := self.upper;
  };
  var graph := self.map expressionToActivityGraph().addTo(result);
  var outputNode := new ActivityParameterNode(result, ownedParameter->at(1), false);
  new ObjectFlow(result, graph.resultSource, outputNode);
}

mapping Expression::expressionToActivityGraph() : ActivityGraph
	disjuncts 
		LiteralExpression::toActivityGraph,
		NameExpression::toActivityGraph,
		ThisExpression::toActivityGraph,
		PropertyAccessExpression::toActivityGraph,
		InvocationExpression::toActivityGraph,
		ClassExtentExpression::toActivityGraph,
		SequenceConstructionExpression::toActivityGraph,
		SequenceAccessExpression::toActivityGraph,
		SequenceReductionExpression::toActivityGraph,
		SequenceExpansionExpression::toActivityGraph,
		IncrementOrDecrementExpression::toActivityGraph,
		UnaryExpression::toActivityGraph,
		BinaryExpression::toActivityGraph,
		CastExpression::toActivityGraph,
		ConditionalTestExpression::toActivityGraph,
		AssignmentExpression::toActivityGraph;

abstract mapping Expression::toActivityGraph() : ActivityGraph;

mapping Expression::Dummy_toActivityGraph() : ActivityGraph
	inherits Expression::toActivityGraph {
	resultSource := new ForkNode("Dummy");
	nodes += resultSource;
}

// Literal Expressions

mapping LiteralExpression::toActivityGraph() : ActivityGraph
	inherits Expression::toActivityGraph {
	nodes += new ValueSpecificationAction(self.toValueSpecification());
}

abstract helper LiteralExpression::toValueSpecification() : ValueSpecification;

helper BooleanLiteralExpression::toValueSpecification() : ValueSpecification {
	return new LiteralBoolean(self.image = "true", self.type.toType());
}

helper NaturalLiteralExpression::toValueSpecification() : ValueSpecification {
	return new LiteralInteger(self.image.replaceAll("_", "").parseInt(self.radix()), self.type.toType());
}

query NaturalLiteralExpression::radix() : Integer {
	var image := self.image;
	var radix := 10;
	if image.length() > 1 and image.at(1) = "0" then {
		var radixChar := image.at(2);
		radix :=
			if radixChar = "b" or radixChar = "B" then 2
			else if radixChar = "x" or radixChar = "X" then 16
			else 8
			endif endif;
	  if radix <> 8 then {
	  	image := image.substring(2, image.length());
	  } endif;
	} endif;
	return radix;
}

query String::parseInt(radix : Integer) : Integer {
	var digits :=
		if radix <> 16 then self.characters().toInteger()
		else self.characters().hexValue()
		endif;
	var value := 0;
	digits->forEach(d) {
		value := value * radix + d;
	};
	return value;
}

query String::hexValue() : Integer {
	return 
		if self >= "0" and self <= "9" then
			self.toInteger()
	  else
			switch {
				case (self = "a" or self = "A") 10;
				case (self = "b" or self = "B") 11;
				case (self = "c" or self = "C") 12;
				case (self = "d" or self = "D") 13;
				case (self = "e" or self = "E") 14;
				case (self = "f" or self = "F") 15;
			}
		endif
}

helper UnboundedLiteralExpression::toValueSpecification() : ValueSpecification {
	return new LiteralUnlimitedNatural(self.type.toType());
}

helper StringLiteralExpression::toValueSpecification() : ValueSpecification {
	return new LiteralString( 
			if self.image.length() <= 2 then ""
			else self.image.substring(2, self.image.length()-1)
			endif,
			self.type.toType());
}

// Name Expressions

mapping NameExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::toActivityGraph  {
init {
	var assignment = self.assignment;
	var enumerationLiteralReference = self.enumerationLiteral;
	var propertyAccess = self.propertyAccess;
	
	if assignment <> null then {
	  var source := assignment.map toActivityNode();
		result := object ActivityGraph {
			resultSource := 
				if not assignment.isParallelLocalName then source
	      // If the assignment is for an @parallel local name within a for statement, then the 
	      // assigned source node must be a fork node attached to an output expansion node for 
	      // the expansion region mapped from the for statement. Get the expansion node as the 
	      // result source.
				else source.incoming->any(true).source endif;
		};
	} else if enumerationLiteralReference <> null then {
		var enumerationLiteral = enumerationLiteralReference.toUml().oclAsType(EnumerationLiteral);
		var valueActionName := "Value(" + enumerationLiteral.name + ")";
		result := object ActivityGraph {
			nodes += var valueAction ::= new ValueSpecificationAction(new InstanceValue(enumerationLiteral));
			resultSource := valueAction._'result';
		};
	} else if propertyAccess <> null then {
		result := propertyAccess.map toActivityGraph();
	} endif endif endif;
}
}

// This Expressions

mapping ThisExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::toActivityGraph  {
  nodes += var readSelfAction := new ReadSelfAction(self.type.toType());
  resultSource := readSelfAction.result;
}

// Property Access Expressions

mapping PropertyAccessExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph  {
	var feature := self.feature.toUml().oclAsType(Property);
	var graph := self.featureReference.expression.map toActivityGraph();
	nodes += graph.nodes;
	edges += graph.edges;
	
  // Add a fork node that may be used as the source of the feature
  // expression to avoid recomputing it for inout parameters,
  // increment or decrement expressions and compound assignments.
  nodes += objectSource := new ForkNode(graph.resultSource.name);
  edges += new ObjectFlow(graph.resultSource, objectSource);
  
	var type :=
		if self.feature.isAssociationEnd() then
			self.feature.opposite().type()
		else
			self.feature.namespace()
		endif;	
	var readAction ::= new ReadStructuralFeatureAction(type.toType(), feature);

  if self.featureReference.expression.upper = 1 then {
  	// Single instance property access
  	nodes += readAction;
  	edges += new ObjectFlow(objectSource, readAction._'object');
  	resultSource := readAction.result;
  } else {
  	// Sequence property access
  	var region := addExpansionRegion(
  		result, "Collect(" + readAction.name + ")", ExpansionKind::parallel,
  		Set{readAction}, Set{}, objectSource, readAction._'object', readAction.result);
  	resultSource := region.outputElement![true];
  } endif;
}

// Invocation Actions

intermediate property InvocationExpression::assignedValueSourceMap : Dict(String, ActivityNode);

mapping InvocationExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::toActivityGraph {
 	self.mapAction(result);
}

helper InvocationExpression::mapAction(inout graph : ActivityGraph) : Action {
	return self.InvocationExpression_mapAction(graph);
}

helper InvocationExpression::InvocationExpression_mapAction(inout graph : ActivityGraph) : Action {
 	var action := self.mapTarget(graph);
  var tupleGraph := self.tuple.map toActivityGraph(action);
  tupleGraph.addTo(graph);
  self.assignedValueSourceMap := self.tuple.assignedValueSourceMap;
  self.mapFeature(graph, action);
  
  // NOTE: Adding left-hand side elements here prevents them from being
  // wrapped in the expansion region mapped from a sequence feature
  // invocation.
  tupleGraph.lhsGraph.addTo(graph);
  
  return action;
}

helper InvocationExpression::mapTarget(inout graph : ActivityGraph) : Action {
	return self.InvocationExpression_mapTarget(graph);
}

helper InvocationExpression::InvocationExpression_mapTarget(inout graph : ActivityGraph) : Action {
  var action : Action;
  if self.isImplicit then {
  	graph.nodes += action := new DestroyObjectAction(null);
  } else {
  	var element := self.referent.toUml();
  	switch {
  		case(element.oclIsKindOf(Operation)) {
	  		graph.nodes += action := new CallOperationAction(element.oclAsType(Operation));
	  		graph.resultSource := action.returnPin();
	  	}
	  	case(element.oclIsKindOf(Signal)) {
	  		graph.nodes += action := new SendSignalAction(element.oclAsType(Signal));
	  	}
	  	case(element.oclIsKindOf(Behavior)) {
	  		graph.nodes += action := new CallBehaviorAction(element.oclAsType(Behavior));
	  		graph.resultSource := action.returnPin();
	  	}
	  	case(element.oclIsKindOf(Property)) {
	  		graph.nodes += action := new ReadLinkAction(element.oclAsType(Property));
	  		graph.resultSource := action._'output'->at(1);
	  	}
  	};
  } endif;
	return action;
}

helper InvocationExpression::mapFeature(inout graph : ActivityGraph, action : Action) {
	var targetNode : ActivityNode;
	switch {
		case(action.oclIsKindOf(CallOperationAction)) {
			var callAction := action.oclAsType(CallOperationAction);
			if not self.isDestructor then {
				targetNode := callAction.target;
			} else {	
				graph.nodes += targetNode := new ForkNode(callAction.target.name);
				graph.edges += new ObjectFlow(targetNode, callAction.target);
				
				graph.nodes += var destroyAction ::= new DestroyObjectAction(callAction.operation._'class');
				graph.edges += new ControlFlow(action, destroyAction);
				
				if self.isContainedInDestructor() then {
					self.addDestroyCheck(graph, targetNode, destroyAction.target);
				} else {
					graph.edges += new ObjectFlow(targetNode, destroyAction.target);
				} endif;
			} endif;
		}
		case(action.oclIsKindOf(SendSignalAction)) {
			var sendAction := action.oclAsType(SendSignalAction);

      // NOTE: The type of the target pin must be properly set to
      // satisfy the fUML constraint that the type of this pin has a
      // reception for the signal being sent.
			sendAction.target.type := self.feature.type.toType();
			
			targetNode := sendAction.target;
		}
		case(action.oclIsKindOf(DestroyObjectAction)) {
			var destroyAction := action.oclAsType(DestroyObjectAction);
			if self.isContainedInDestructor() then {
				graph.nodes += targetNode := new ForkNode(destroyAction.target.name);
				self.addDestroyCheck(graph, targetNode, destroyAction.target);
			} else {
				targetNode := destroyAction.target;
			} endif;
		}
	};
	
	var featureGraph := self.feature.expression.map toActivityGraph();
	if self.isSequenceFeatureInvocation() then {
		
		// Wrap the invocation action and input arguments mapping in an expansion region.
		var nodes := graph.nodes;
		var edges := graph.edges;
		var resultSource := graph.resultSource;
		graph := object ActivityGraph{};
		var region := addExpansionRegion(graph, 
			"Collect(" + action.name + ")", ExpansionKind::parallel, nodes, edges, 
			featureGraph.resultSource, targetNode, resultSource);
	  if resultSource <> null then {
	  	graph.resultSource := region.outputElement![incoming![true].source = resultSource];
	  } endif;
	  
	  // Wrap the feature expression in a structured activity node as the source of
	  // a control flow to the expansion region.
	  var featureNode := featureGraph.addStructuredActivityNodeTo(graph, "Feature(" + featureGraph.resultSource.name + ")");
	  graph.edges += new ControlFlow(featureNode, region);

  } else if featureGraph.resultSource <> null then {
  	// Connect the feature mapping result source directly to the action target pin.
  	graph.edges += new ObjectFlow(featureGraph.resultSource, targetNode);
  	featureGraph.addTo(graph);
	} endif endif;
}

// Check whether this invocation expression is contained in the body of a constructor operation.
query InvocationExpression::isContainedInDestructor() : Boolean {
	var namespace := self.currentScope();
	return namespace <> null and namespace.isDestructor();
}

// Check whether this invocation expression is a sequence feature invocation.
query InvocationExpression::isSequenceFeatureInvocation() : Boolean {
	var feature = self.feature;
	var primary = if feature = null then null else feature.expression endif;
	return primary <> null and (primary.lower <> 1 or primary.upper <> 1);
}

// Add the logic to test whether the context object is the object being destroyed (from targetNode)
// and conditioning the destroy action on that.
helper InvocationExpression::addDestroyCheck(inout graph : ActivityGraph, targetNode : ActivityNode, targetPin : ActivityNode) {
	graph.nodes += var readSelfAction ::= new ReadSelfAction(null);
	graph.nodes += var testAction ::= new TestIdentityAction("self==" + targetNode.name, self.booleanType().toType());
	graph.edges += new ObjectFlow(readSelfAction.result, testAction.first);
	graph.edges += new ObjectFlow(targetNode, testAction.second);
	createObjectDecisionGraph("destroy check", targetNode, testAction.result, targetPin, null).addTo(graph);
}

query InvocationExpression::assignedValueSource(assignedName : String) : ActivityNode {
	return self.assignedValueSourceMap->get(assignedName);
}

intermediate class TupleGraph extends ActivityGraph {
	lhsGraph : ActivityGraph;
}

intermediate property _Tuple::assignedValueSourceMap : Dict(String, ActivityNode);

mapping _Tuple::toActivityGraph(action : Action) : TupleGraph {
	var invocation := self.invocation;
	var inputs := self.input;
	var outputs := self.output;
	var parameters := invocation.parameter;
	var subgraph := object ActivityGraph {};
	var inoutExpressionMap : Dict(String, Expression);
	
	if inputs->notEmpty() then {
		var inputParameters := parameters[direction() = "in" or direction() = "inout"];
		var i := 1;
		inputParameters->forEach(parameter) {
			var input := inputs![name = parameter.name()];
			var expressionGraph := input.expression.map toActivityGraph();
			if parameter.direction() = "inout" then {
				inoutExpressionMap->put(input.name, input.expression);
			} endif;
			
			expressionGraph.addTo(subgraph);
			var source := expressionGraph.resultSource;
			
	    // If the expression has type Natural, but the parameter
	    // has type UnlimitedNatural, then a conversion is
	    // required, because the representations are different.
	    var expressionType := input.expression.type;
	    var parameterType := parameter.type();
	    
	    if expressionType <> null and parameterType <> null and
	    	self.isNaturalType(expressionType) and
        // NOTE: Check for "not Integer" excludes both Integer
        // and Natural. Checking just for "is UnlimitedNatural"
        // wouldn't exclude Natural, since it is a specialization
        // of UnlimitedNatural.
	    	not self.isIntegerType(parameterType) then {
	    		nodes += var callAction ::= new CallBehaviorAction(
	    			self.libraryFunction("PrimitiveBehaviors::IntegerFunctions::ToUnlimitedNatural"));
	    		edges += new ObjectFlow(source, callAction.argument->at(1));
	    		source := callAction.result->at(1);
	    } endif;
	    
	    // Add collection and bit string conversions, if required.
	    source := mapConversions(subgraph.nodes, subgraph.edges, source, expressionType,
	    	input.isCollectionConversion, input.isBitStringConversion);
	    
	    var inputPin := action.input->at(i);
	    edges += new ObjectFlow(source, inputPin);
	    
	    // Check for an index on the argument name (as opposed to the argument expression itself).
	    var index := input.index;
	    if index <> null or invocation.oclIsKindOf(LinkOperationExpression) and inputPin.isOrdered then {
				if index = null then {
					nodes += var valueAction ::= 
						new ValueSpecificationAction(new LiteralUnlimitedNatural(self.unlimitedNaturalType().toType()));
					source := valueAction.result;
				} else {
					source := index.map toActivityGraph().addTo(result).resultSource;
					if self.isIntegerType(index.type) then {
						subgraph.nodes += var callAction ::= 
							new CallBehaviorAction(self.libraryFunction("PrimitiveBehaviors::IntegerFunctions::ToUnlimitedNatural"));
						subgraph.edges += new ObjectFlow(source, callAction.argument->at(1));
						source := callAction.result->at(1);
					} endif;
				} endif;
				// NOTE: This presumes that the "insertAt" or "destroyAt" pin comes directly after
				// the value pin in the list of input pins.
				i := i + 1;
				edges += new ObjectFlow(source, action.input->at(i));
	    } endif;
	    
	    i := i + 1;
		};
		
		if subgraph.nodes->notEmpty() then {
			var node := subgraph.addStructuredActivityNodeTo(result, "Tuple(" + action.name + ")");
			edges += new ControlFlow(node, action);
		} endif;		
	} endif;
	
	if outputs->notEmpty() then {
		var outputParameters := parameters[direction() = "out" or direction() = "inout" or 
			direction() = "return"];
		var i := 1;
		var returnPin := action.returnPin();
		outputParameters->forEach(parameter) {
			var output := outputs![name = parameter.name()];
			if not output.expression.isNull() then {
				var lhs := output.leftHandSide;
				var lhsGraph := lhs.map toActivityGraph(inoutExpressionMap->get(output.name));
				lhsGraph.addTo(result);
				
				// Skip the return pin. The return parameter never has an output argument.
				var outputPin : ActivityNode := action.output->at(i);
				if outputPin = returnPin then {
					i := i + 1;
					outputPin := action.output->at(i);
				} endif;
				
				// Add collection and bit string conversion, if required.
				outputPin := mapConversions(nodes, edges, outputPin, parameter.type(), output.isCollectionConversion, output.isBitStringConversion);
				
				// NOTE: These activity edges are part of the tuple graph, NOT the LHS graph.
				edges += new ObjectFlow(outputPin, lhsGraph.assignmentTarget);
				
				var controlTarget := lhsGraph.controlTarget;
				if controlTarget <> null then {
					edges += new ControlFlow(action, controlTarget);
				} endif;
				
				var assignedName := lhs.assignedName();
				if assignedName <> null then {
					self.assignedValueSourceMap->put(assignedName, lhs.assignedValueSource(assignedName))
				} endif;
			} endif;
			i := i + 1;
		};
	} endif;
}

query _Tuple::assignedValueSource(assignedName : String) : ActivityNode {
	return self.assignedValueSourceMap->get(assignedName);
}

// Behavior Invocation Expressions

helper BehaviorInvocationExpression::mapAction(inout graph : ActivityGraph) : Action {
	var action : Action := null;
	if not self.isAddInvocation() then {
		action := self.mapAction(graph);
	} else {
		var inputs := self.tuple.input;
	  var nameExpression := inputs![name = self.parameter->at(1).name()].expression;
		var target := nameExpression.map toActivityGraph().resultSource;
		
		var expression := inputs![name = self.parameter->at(2).name()].expression;
		var expressionGraph := expression.map toActivityGraph().addTo(graph);
		graph.edges += new ObjectFlow(expressionGraph.resultSource, target);
	} endif;
	return action;
}

query BehaviorInvocationExpression::isAddInvocation() : Boolean {
	var parameter := self.parameter![direction() = "inout"];
	return parameter <> null and 
		self.isAddTarget(self.tuple.input![name = parameter.name()].expression);
}

// Feature Invocation Expressions
// (No specialization from default invocation expression mapping)

// Super Invocation Expressions

helper SuperInvocationExpression::mapTarget(inout graph : ActivityGraph) : Action {
	var operation := self.referent.toUml().oclAsType(Operation);
	graph.nodes += var action ::= new CallBehaviorAction(operation.method![true]);
	graph.resultSource := action.returnPin();
	return action;
}

// Instance Creation Expressions

helper InstanceCreationExpression::mapAction(inout graph : ActivityGraph) : Action {
	var action := self.InvocationExpression_mapAction(graph);
	
	// If creating an instance of an active class, add a start behavior action.
	if action.oclIsKindOf(CallOperationAction) then {
		var class_ := action.oclAsType(CallOperationAction).operation._'class';
		if class_.isActive then {
			graph.nodes += var forkNode ::= new ForkNode(graph.resultSource.name);
			graph.edges += new ObjectFlow(graph.resultSource, forkNode);
			
			graph.nodes += var startAction ::= new StartObjectBehaviorAction(class_);
			graph.edges += new ObjectFlow(forkNode, startAction._'object');
			
			class_.allParents().oclAsType(Class)[isActive]->forEach(parent) {
				graph.nodes += startAction := new StartObjectBehaviorAction(parent);
				graph.edges += new ObjectFlow(forkNode, startAction._'object');
			};
			
			var newGraph := object ActivityGraph {};
			var node := graph.addStructuredActivityNodeTo(newGraph, "InstanceCreationExpression(" + class_.name + ")");
			
			var pin := new OutputPin(node, "Output(" + graph.resultSource.name + ")", class_, 1, 1);
			addToStructuredNode(newGraph, node, Set{}, Set{new ObjectFlow(forkNode, pin)});
			
			graph := newGraph;
			graph.resultSource := pin;
			action := node;
		} endif;
	} endif;
	
	return action;
}

helper InstanceCreationExpression::mapTarget(inout graph : ActivityGraph) : Action {
	var action : Action;
	
	if not self.isObjectCreation then {
		// Data value creation
		var dataType := self.referent.toUml().oclAsType(DataType);
		var subgraph := object ActivityGraph {};
		
		// Create a value specification action to create an instance of the data type.
		subgraph.nodes += var valueAction ::= new ValueSpecificationAction(new InstanceValue(dataType));
		graph.resultSource := valueAction.result;
		
		// The mapping for a data value creation is placed inside a structured activity node
		// so that the node can act as the action with input pins to which the results of the
		// tuple mapping are connected.
		
		graph.nodes += var structuredNode ::= new StructuredActivityNode("Create(" + dataType.name + ")");
		dataType.allAttributes()->forEach(attribute) {
			var valuePin := new InputPin(structuredNode, 
				structuredNode.name + ".input(" + attribute.qualifiedName + ")", 
				attribute.type, attribute.lower, attribute.upper);
			graph.resultSource := self.mapPropertyAssignment(attribute, graph.resultSource, valuePin).addTo(subgraph).resultSource;
		}
		
	} else if not self.isConstructorless then {
		// Object creation with a constructor
		
		// Map the constructor call as a normal call operation action.
		action := self.InvocationExpression_mapTarget(graph);
		var callAction := action.oclAsType(CallOperationAction);
		
		// Add a create object action to provide the target input to the constructor call.
		graph.nodes += var createAction ::= new CreateObjectAction(callAction.operation._'class');
		graph.edges += new ObjectFlow(createAction.result, callAction.target);
		
	} else {
		// Object creation without a constructor
		graph.nodes += action := new CreateObjectAction(self.referent.toUml().oclAsType(Class));
		graph.resultSource := action.oclAsType(CreateObjectAction).result;
		
	} endif endif;
	
	return action;
}

// Link Operation Expressions

helper LinkOperationExpression::mapTarget(inout graph : ActivityGraph) : Action {
	var association := self.referent.toUml().oclAsType(Association);
	var unlimitedNaturalType := self.unlimitedNaturalType().toType();
	graph.nodes += var action ::=
		if self.isClear then new ClearAssociationAction(association)
		else if self.isCreation then new CreateLinkAction(association, unlimitedNaturalType)
		else new DestroyLinkAction(association, unlimitedNaturalType)
		endif endif;
	if self.isCreation then {
		var endDataList := action.oclAsType(CreateLinkAction).endData.oclAsType(LinkEndCreationData)->asSequence();
		if association.memberEnd->size() = 2 then {
			// For a binary association, setting isReplaceAll = trure on the opposite end of an end with
			// multiplicity upper bound of 1 ensures that the upper bound is maintained.
			var endData1 := endDataList->at(1);
			var endData2 := endDataList->at(2);
			if endData1._'end'.upper = 1 then {
				endData2.isReplaceAll := true;
			} endif;
			if endData2._'end'.upper = 1 then {
				endData1.isReplaceAll := true;
			} endif;
	
		} else if endDataList->exists(_'end'.upper = 1) then {
			// For a non-binary association, specific links need to be found and destroyed to maintain
			// any upper bound multiplicities of 1.
			graph.nodes := graph.nodes->excluding(action);
			graph.nodes += var node ::= new StructuredActivityNode("CreateLink(" + association.name + ")");
			
			var subgraph := object ActivityGraph {};
			subgraph.nodes += action;
			endDataList->forEach(endData) {
				var end_ := endData._'end';
				var inputPin := new InputPin(node, node.name + ".input(" + end_.name + ")", end_.type, end_.lower, end_.upper);
				inputPin.isOrdered := end_.isOrdered;
				subgraph.nodes += var forkNode ::= new ForkNode(end_.name);
				subgraph.edges += new ObjectFlow(inputPin, forkNode);
				subgraph.edges += new ObjectFlow(forkNode, endData.value);
				if end_.isOrdered then {
					inputPin := new InputPin(node, node.name + ".index(" + end_.name + ")", endData.insertAt.type, 1, 1);
					subgraph.edges += new ObjectFlow(inputPin, endData.insertAt);
				} endif;
			};
			
			var destroyGraph := object ActivityGraph {};
			var n := endDataList->size();
			Sequence{1..n}->forEach(i) {
				var end_ := endDataList->at(i)._'end';
				destroyGraph.nodes += var readAction ::= new ReadLinkAction(end_);
				destroyGraph.nodes += var destroyAction ::= new DestroyLinkAction(association, unlimitedNaturalType);
				destroyGraph.edges += new ObjectFlow(readAction.result, destroyAction.input->at(i));
				var k := 1;
				Sequence{1..n}->forEach(j) {
					if j <> i then {
						var inputPin := node.input->at(k);
						var forkNode := inputPin.outgoing![true].target;
						destroyGraph.edges += new ObjectFlow(forkNode, readAction.input->at(if j < i then j else j - 1 endif));
						destroyGraph.edges += new ObjectFlow(forkNode, destroyAction.input->at(j));
					} endif;
					k := k + 1;
					if endDataList->at(j)._'end'.isOrdered then {
						k := k + 1
					} endif;
				}
			};
			var destroyNode := destroyGraph.addStructuredActivityNodeTo(subgraph, "DestroyLinks");
			subgraph.edges += new ControlFlow(destroyNode, action);
			subgraph.addToStructuredNode(graph, node);
			action := node;
		} endif endif;
	} endif;
	return action;
}

// Read Extent Expressions

mapping ClassExtentExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::toActivityGraph  {
	nodes += var action ::= new ReadExtentAction(self.type.toType().oclAsType(Class));
	resultSource := action.result;
}

// Sequence Construction Expressions

mapping SequenceConstructionExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph  {

}

abstract mapping SequenceElements::toActivityGraph(out nodes : Set(ActivityNode), out edges : Set(ActivityEdge));

mapping SequenceExpressionList::toActivityGraph(out nodes : Set(ActivityNode), out edges : Set(ActivityEdge))
 	inherits SequenceElements::toActivityGraph;

mapping SequenceRange::toActivityGraph(out nodes : Set(ActivityNode), out edges : Set(ActivityEdge))
 	inherits SequenceElements::toActivityGraph;

mapping SequenceAccessExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph  {

}

helper mapSequenceRangeLoop(
	inout nodes : Set(ActivityNode), inout edges : Set(ActivityEdge),
	resultSource1 : ActivityNode, resultSource2 : ActivityNode,
	label : String) : ActivityNode {
	// TODO
	return resultSource1;
}

// Sequence Operation Expressions

mapping SequenceOperationExpression::toActivityGraph() : ActivityGraph
 	inherits InvocationExpression::toActivityGraph  {

}

mapping ExtentOrExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph  {

}

// Sequence Reduction Expressions

mapping SequenceReductionExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph  {

}

// Sequence Expansion Expressions

abstract mapping SequenceExpansionExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph;

mapping SelectOrRejectExpression::toActivityGraph() : ActivityGraph
 	inherits SequenceExpansionExpression::toActivityGraph  {

}

mapping CollectOrIterateExpression::toActivityGraph() : ActivityGraph
 	inherits SequenceExpansionExpression::toActivityGraph  {

}

mapping ForAllOrExistsOrOneExpression::toActivityGraph() : ActivityGraph
 	inherits SequenceExpansionExpression::toActivityGraph  {

}

mapping IsUniqueExpression::toActivityGraph() : ActivityGraph
 	inherits SequenceExpansionExpression::toActivityGraph  {

}

mapping IncrementOrDecrementExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph  {

}

abstract mapping UnaryExpression::toActivityGraph() : ActivityGraph;

mapping BooleanUnaryExpression::toActivityGraph() : ActivityGraph
 	inherits UnaryExpression::toActivityGraph  {

}

mapping BitStringUnaryExpression::toActivityGraph() : ActivityGraph
 	inherits UnaryExpression::toActivityGraph  {

}

mapping NumericUnaryExpression::toActivityGraph() : ActivityGraph
 	inherits UnaryExpression::toActivityGraph  {

}

mapping CastExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph  {

}

mapping IsolationExpression::toActivityGraph() : ActivityGraph
 	inherits UnaryExpression::toActivityGraph  {

}

abstract mapping BinaryExpression::toActivityGraph() : ActivityGraph;

mapping ArithmeticExpression::toActivityGraph() : ActivityGraph
 	inherits BinaryExpression::toActivityGraph  {

}

mapping ShiftExpression::toActivityGraph() : ActivityGraph
 	inherits BinaryExpression::toActivityGraph  {

}

mapping RelationalExpression::toActivityGraph() : ActivityGraph
 	inherits BinaryExpression::toActivityGraph  {

}

mapping ClassificationExpression::toActivityGraph() : ActivityGraph
 	inherits UnaryExpression::toActivityGraph  {

}

mapping EqualityExpression::toActivityGraph() : ActivityGraph
 	inherits BinaryExpression::toActivityGraph  {

}

mapping LogicalExpression::toActivityGraph() : ActivityGraph
 	inherits BinaryExpression::toActivityGraph  {

}

mapping ConditionalLogicalExpression::toActivityGraph() : ActivityGraph
 	inherits BinaryExpression::toActivityGraph  {

}

mapping ConditionalTestExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph  {

}

// Assignment Expressions

mapping AssignmentExpression::toActivityGraph() : ActivityGraph
 	inherits Expression::Dummy_toActivityGraph  {

}

query AssignmentExpression::assignedValueSource(assignedName : String) : ActivityNode {
	// TODO: Fix this.
	return self.map toActivityGraph().resultSource;
}

helper SyntaxElement::mapPropertyAssignment(property_ : Property, objectSource : ActivityNode, valueSource : ActivityNode): ActivityGraph {
	var graph = object ActivityGraph {};
	var featuringClassifier := property_.featuringClassifier->any(true);
	
	// Create a write action for the property.
	var writeActionName := "Write(" + property_.name + ")";
	graph.nodes += var writeAction ::= object AddStructuralFeatureValueAction {
		name := writeActionName;
		structuralFeature := property_;
		isReplaceAll := false;
		_'object' := object InputPin {
			name := writeActionName + ".object";
			type := featuringClassifier;
			lower := 1;
			upper := 1;
		};
		value := object InputPin {
			name := writeActionName + ".value";
			type := property_.type;
			lower := 1;
			upper := 1;
		};
		_'result' := object OutputPin {
			name := writeActionName + ".result";
			type := featuringClassifier;
			lower := 1;
			upper := 1;
		};
	};
	
	// For an ordered property, provide insertAt pin with a "*" input.
	if property_.isOrdered then {
		graph.nodes += var valueAction ::= object ValueSpecificationAction {
			name := "Value(*)";
			value := object LiteralUnlimitedNatural {};
			_'result' := object OutputPin {
				name := "Value(*).result";
				type := self.unlimitedNaturalType().toUml().oclAsType(Type);
				lower := 1;
				upper := 1;
			};
		};
		writeAction.insertAt := object InputPin {
			name := writeAction.name + ".insertAt";
			type := valueAction._'result'.type;
			lower := 1;
			upper := 1;
		};
		graph.edges += object ObjectFlow {
			source := valueAction._'result';
			target := writeAction.insertAt;
		};
	} endif;
	
	if property_.lower = 1 and property_.upper = 1 then {
		// If the property multiplicity is 1..1, connect the valueSource 
		// to the write action value input pin.
		graph.edges += object ObjectFlow {
			source := valueSource;
			target := writeAction.value;
		};
		writeAction.isReplaceAll := true;
		
		// Connect the action object pin to the objectSource.
		graph.edges += object ObjectFlow {
			source := objectSource;
			target := writeAction._'object';
		};
		
		graph.resultSource := writeAction._'result';
  } else if not featuringClassifier.oclIsKindOf(DataType) then {
  	// If the property is not a feature of a data type, use an iterative
  	// expansion region to set multiple values.
  	var regionName := "Iterate(" + writeAction.name + ")";
  	var region := object ExpansionRegion {
  		name := regionName;
  		mode := ExpansionKind::iterative;
  		node := graph.nodes;
  		edge := graph.edges;
  	};
  	region.structuredNodeInput += var objectInputPin := object InputPin {
			name := regionName + ".input(" + objectSource.name + ")";
			type := featuringClassifier;
			lower := 1;
			upper := 1;
		};
  	region.edge += object ObjectFlow {
  		source := objectInputPin;
  		target := writeAction._'object';
  	};
  	
  	graph.nodes := region;
  	graph.nodes += var inputNode ::= object ExpansionNode {
  		name := regionName + ".inputNode(" + valueSource.name + ")";
  		type := property_.type;
  		regionAsInput := region;
  	};
  	graph.edges += object ObjectFlow {
  		source := objectSource;
  		target := objectInputPin;
  	};
  	graph.edges += object ObjectFlow {
  		source := valueSource;
  		target := inputNode;
  	}
  	
  } else {
  	// If the property is a feature of a data type, then use a loop node
  	// to iteratively update the data value.
  	
  	// TODO: Implement setting a data type property.
  		
  } endif endif;
	
	return graph;
}

helper mapConversions(
	inout nodes : Set(ActivityNode), inout edges : Set(ActivityEdge),
	rhsResultSource : ActivityNode, rhsType : ElementReference,
	isCollectionConversion : Boolean, isBitStringConversion : Boolean) : ActivityNode {
	// TODO
	return rhsResultSource;
}

intermediate class LhsGraph extends ActivityGraph {
	assignmentTarget : ActivityNode;
	controlTarget : ActivityNode;
}

mapping LeftHandSide::toActivityGraph(sourceExpression : Expression) : LhsGraph {
	
}

mapping NameLeftHandSide::toActivityGraph(sourceExpression : Expression) : LhsGraph
	inherits LeftHandSide::toActivityGraph {
		
}

mapping FeatureLeftHandSide::toActivityGraph(sourceExpression : Expression) : LhsGraph
	inherits LeftHandSide::toActivityGraph {
		
}
