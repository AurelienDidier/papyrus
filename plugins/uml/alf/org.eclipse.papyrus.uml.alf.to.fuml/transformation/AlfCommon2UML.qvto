/*****************************************************************************
 * Copyright (c) 2015 CEA LIST.
 *
 *    
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Ed Seidewitz
 * 
 *****************************************************************************/
modeltype Alf uses "http://www.omg.org/spec/ALF/20120827";
modeltype UML uses "http://www.eclipse.org/uml2/5.0.0/UML";

transformation AlfCommon2UML(in alf : Alf, inout uml : UML);

// Syntax Elements

abstract mapping SyntaxElement::toUml() : Element;

helper SyntaxElement::libraryFunction(path : String) : Behavior {
	var referents := self.resolveInLibrary(path)->select(isBehavior());
  return
    if referents->isEmpty() then null
    else referents->any(true).toUml().oclAsType(Behavior)
    endif;
}

query SyntaxElement::literalBoolean(b : Boolean) : LiteralBoolean {
	return object LiteralBoolean {
	  name := b.toString();
		type := self.booleanType().toType();
		value := b;
	}
}

query SyntaxElement::literalNatural(n : Integer) : LiteralInteger {
	return object LiteralInteger {
		name := n.toString();
		type := self.naturalType().toType();
		value := n;
	}
}

helper SyntaxElement::functionSize() : Behavior {
	return self.libraryFunction("PrimitiveBehaviors::SequenceFunctions::Size");
}

helper SyntaxElement::functionAt() : Behavior {
	return self.libraryFunction("PrimitiveBehaviors::SequenceFunctions::At");
}

helper SyntaxElement::functionPlus() : Behavior {
	return self.libraryFunction("PrimitiveBehaviors::IntegerFunctions::+");
}

helper SyntaxElement::functionMinus() : Behavior {
	return self.libraryFunction("PrimitiveBehaviors::IntegerFunctions::-");
}

helper SyntaxElement::functionLessThanOrEqual() : Behavior {
	return self.libraryFunction("PrimitiveBehaviors::IntegerFunctions::<=");
}

helper SyntaxElement::functionOr() : Behavior {
	return self.libraryFunction("PrimitiveBehaviors::BooleanFunctions::|");
}

// Documented Elements

abstract mapping DocumentedElement::toElement() : Element {
  self.documentation->forEach(d) {
    var comment = object Comment {
      annotatedElement := result;
      body := d.substring(4,d.length()-2)
    };
    ownedComment += comment;
  }
}

// Element References

abstract helper ElementReference::toUml() : Element;

abstract helper InternalElementReference::toUml() : Element;

helper ExternalElementReference::toUml() : Element {
 return self.asUml().oclAsType(Element);
}

helper ElementReference::toType() : Type {
	return self.toUml().oclAsType(Type);
}

helper toType(reference : ElementReference) : Type {
	return
		if reference = null then null
		else reference.toType() endif;
}

helper BoundElementReference::toUml() : Element {
  // TODO: Handle expansion of template bindings.
  return 
    if self.isTemplateBinding() then
      self.templateBinding.toUml()
    else
      self.referent.toUml()
    endif;
}

// Activities

constructor Activity::Activity(ownedParameters : Sequence(Parameter)) {
  ownedParameter := ownedParameters;
  ownedParameters->forEach(ownedParameter) {
  	var parameterNode := new ActivityParameterNode(result, ownedParameter, false);
		if ownedParameter.direction = ParameterDirectionKind::_'in' or 
		   ownedParameter.direction = ParameterDirectionKind::_'inout' then {
			var forkNode := new ForkNode(result, ownedParameter.name);
			new ObjectFlow(result, parameterNode, forkNode);
	  } endif;
	  if ownedParameter.direction = ParameterDirectionKind::_'inout' then {
			new ActivityParameterNode(result, ownedParameter, true);
		} endif;
  };
}

constructor ObjectFlow::ObjectFlow(sourceNode : ActivityNode, targetNode : ActivityNode) {
	source := sourceNode;
	target := targetNode;
}

constructor ObjectFlow::ObjectFlow(owner : Activity, sourceNode : ActivityNode, targetNode : ActivityNode) {
	activity := owner;
	source := sourceNode;
	target := targetNode;
}

constructor ObjectFlow::ObjectFlow(owner : StructuredActivityNode, sourceNode : ActivityNode, targetNode : ActivityNode) {
	inStructuredNode := owner;
	source := sourceNode;
	target := targetNode;
}

constructor ControlFlow::ControlFlow(sourceNode : ActivityNode, targetNode : ActivityNode) {
	source := sourceNode;
	target := targetNode;
}

constructor ControlFlow::ControlFlow(structuredNode : StructuredActivityNode, sourceNode : ActivityNode, targetNode : ActivityNode) {
	inStructuredNode := structuredNode;
	source := sourceNode;
	target := targetNode;
}

constructor ActivityParameterNode::ActivityParameterNode(owner : Activity, ownedParameter : Parameter, isOutput : Boolean) {
	activity := owner;
	parameter := ownedParameter;
	name :=
		if isOutput or ownedParameter.direction = ParameterDirectionKind::_'out' then 
			"Output(" + ownedParameter.name + ")"
		else if ownedParameter.direction = ParameterDirectionKind::_'in' or 
			      ownedParameter.direction = ParameterDirectionKind::_'inout' then 
			"Input(" + ownedParameter.name + ")"
		else 
			"Return" 
		endif endif;
}

constructor InitialNode::InitialNode(label : String) {
	name := "Initial(" + label + ")";
}

constructor InitialNode::InitialNode(structuredNode : StructuredActivityNode) {
	inStructuredNode := structuredNode;
	name := "Initial(" + structuredNode.name + ")"
}

constructor ForkNode::ForkNode(sourceName : String) {
	name := "Fork(" + sourceName + ")";
}

constructor ForkNode::ForkNode(owner : Activity, sourceName : String) {
	activity := owner;
	name := "Fork(" + sourceName + ")";
}

constructor ForkNode::ForkNode(structuredNode : StructuredActivityNode, sourceName : String) {
	inStructuredNode := structuredNode;
	name := "Fork(" + sourceName + ")";
}

constructor ActivityFinalNode::ActivityFinalNode(containerName : String) {
	name := "FinalNode(" + containerName + ")";
}

constructor ActivityFinalNode::ActivityFinalNode(owner : Activity) {
	activity := owner;
	name := "FinalNode(" + activity.name + ")";
}

constructor ActivityFinalNode::ActivityFinalNode(structuredNode : StructuredActivityNode) {
	inStructuredNode := structuredNode;
	name := "FinalNode(" + structuredNode.name + ")";
}

// Pins

constructor InputPin::InputPin(pinName : String, pinType: Type, pinLower : Integer, pinUpper : Integer) {
	name := pinName;
	type := pinType;
	lower := pinLower;
	upper := pinUpper;
}

constructor InputPin::InputPin(structuredNode : StructuredActivityNode, pinName : String, pinType: Type, pinLower : Integer, pinUpper : Integer) {
	inStructuredNode := structuredNode;
	name := pinName;
	type := pinType;
	lower := pinLower;
	upper := pinUpper;
}

constructor OutputPin::OutputPin(pinName : String, pinType: Type, pinLower : Integer, pinUpper : Integer) {
	name := pinName;
	type := pinType;
	lower := pinLower;
	upper := pinUpper;
}

constructor OutputPin::OutputPin(structuredNode : StructuredActivityNode, pinName : String, pinType: Type, pinLower : Integer, pinUpper : Integer) {
	inStructuredNode := structuredNode;
	name := pinName;
	type := pinType;
	lower := pinLower;
	upper := pinUpper;
}

helper addPinsFromParameters(inout action : Action, parameters : OrderedSet(Parameter)) {
	parameters->forEach(parameter) {
		if parameter.direction = ParameterDirectionKind::_'in' or parameter.direction = ParameterDirectionKind::_inout then {
			addPin(action, object InputPin {}, parameter);
		} endif;
		if parameter.direction = ParameterDirectionKind::_'out' or parameter.direction = ParameterDirectionKind::_inout or 
			 parameter.direction = ParameterDirectionKind::_'return' then {
			addPin(action, object OutputPin {}, parameter);
		} endif;
	}
}

helper addPin(inout action : Action, inout pin : Pin, parameter : Parameter) {
	object pin: {
		lower := parameter.lower;
		upper := parameter.upper;
		isOrdered := parameter.isOrdered;
		isUnique := parameter.isUnique;
		type := parameter.type;
	};
	
	if pin.oclIsKindOf(InputPin) then {
		if action.oclIsKindOf(InvocationAction) then {
			pin.name := action.name + ".argument(" + parameter.name + ")";
			action.oclAsType(InvocationAction).argument += pin.oclAsType(InputPin);
		} else if action.oclIsKindOf(CallAction) then {
			pin.name := action.name + ".result(" + parameter.name + ")";
			action.oclAsType(CallAction).result += pin.oclAsType(OutputPin);
		} endif endif;
	} endif;
}

helper addPinsFromProperties(inout action : Action, properties : OrderedSet(Property)) {
	properties->forEach(prop) {
		addPin(action, object InputPin{}, prop);
	}
}

helper addPin(inout action : Action, inout pin : Pin, property_ : Property) {
	object pin: {
		lower := property_.lower;
		upper := property_.upper;
		isOrdered := property_.isOrdered;
		isUnique := property_.isUnique;
		type := property_.type;
	};
	
	if pin.oclIsKindOf(InputPin) then {
		if action.oclIsKindOf(SendSignalAction) then {
			pin.name := action.name + ".argument(" + property_.name + ")";
			action.oclAsType(SendSignalAction).argument += pin.oclAsType(InputPin);
		} else if action.oclIsKindOf(ReadLinkAction) then {
			pin.name := action.name + ".inputValue(" + property_.name + ")";
			new LinkEndData(action.oclAsType(ReadLinkAction), property_, pin);
		} endif endif;
	} else if action.oclIsKindOf(ReadLinkAction) then {
		pin.name := action.name + ".result";
		new LinkEndData(action.oclAsType(ReadLinkAction), property_, pin);
	} endif endif;
}

query Action::returnPin() : OutputPin {
	var parameters :=
		switch {
			case(self.oclIsKindOf(CallOperationAction)) self.oclAsType(CallOperationAction).operation.ownedParameter;
			case(self.oclIsKindOf(CallBehaviorAction)) self.oclAsType(CallBehaviorAction).behavior.ownedParameter;
			else OrderedSet{};
		};
	return
		if not parameters->exists(direction = ParameterDirectionKind::_'return') then null
		else
			self.output->at(parameters.direction->indexOf(ParameterDirectionKind::_'return'))
		endif;
}

// Link End Data

constructor LinkEndData::LinkEndData(inout action : LinkAction, end_ : Property, pin : Pin) {
	_'end' := end_;
	action.endData += result;
	
	if pin.oclIsKindOf(InputPin) then {
		value := pin.oclAsType(InputPin);
		action.inputValue += pin.oclAsType(InputPin);
	} else if action.oclIsKindOf(ReadLinkAction) then {
		action.oclAsType(ReadLinkAction).result := pin.oclAsType(OutputPin);
	} endif endif;	
}

constructor LinkEndCreationData::LinkEndCreationData(inout action : CreateLinkAction, end_ : Property, unlimitedNaturalType : Type) {
	_'end' := end_;
	value := new InputPin(action.name + ".value(" + end_.name + ")", end_.type, 1, 1);
	isReplaceAll := false;

	action.endData += result;
	action.inputValue += value;
	
	if end_.isOrdered then {
		insertAt := new InputPin(action.name + ".insertAt(" + end_.name + ")", unlimitedNaturalType, 1, 1);
		action.inputValue += insertAt;
	} endif;
}

constructor LinkEndDestructionData::LinkEndDestructionData(inout action : DestroyLinkAction, end_ : Property, unlimitedNaturalType : Type) {
	_'end' := end_;
	value := new InputPin(action.name + ".value(" + end_.name + ")", end_.type, 1, 1);
	isDestroyDuplicates := not end_.isOrdered;

	action.endData += result;
	action.inputValue += value;
	
	if end_.isOrdered then {
		destroyAt := new InputPin(action.name + ".destroyAt(" + end_.name + ")", unlimitedNaturalType, 1, 1);
		action.inputValue += destroyAt;
	} endif;
}

// Actions

constructor AcceptEventAction::AcceptEventAction(structuredNode : StructuredActivityNode, signals : Set(Signal), hasOutput : Boolean) {
	inStructuredNode := structuredNode;
	isUnmarshall := false;
	
	var signalNames := "";
	signals->forEach(signal) {
		if signalNames.length() > 0 then {
			signalNames := signalNames + ",";
		} endif;
		signalNames := signalNames + signal.name;
		
		trigger += new Trigger(signal);		
	};
	
	name := "Accept(" + signalNames + ")";
	
	if hasOutput then {
		result.result += new OutputPin(name + ".result", null, 1, 1);
	} endif;
}

constructor Trigger::Trigger(signal : Signal) {
	event := new SignalEvent(signal);
}

constructor SignalEvent::SignalEvent(sig : Signal) {
	name := "Event(" + sig.name + ")";
	signal := sig;
}

constructor CallBehaviorAction::CallBehaviorAction(target : Behavior) {
	name := "Call(" + target.name +")";
	behavior := target;
	argument := target.ownedParameter[direction = ParameterDirectionKind::_'in' or direction = ParameterDirectionKind::_'inout']->
		collect(parameter |
			new InputPin(name + ".argument(" + parameter.name + ")", 
				parameter.type, parameter.lower, parameter.upper)
		);
	result._'result' := target.ownedParameter[direction = ParameterDirectionKind::_'out' or direction = ParameterDirectionKind::_'inout' or direction = ParameterDirectionKind::_'return']->collect(parameter | 
		new OutputPin(name + ".result(" + parameter.name + ")", 
			parameter.type, parameter.lower, parameter.upper)
	);
}

constructor CallOperationAction::CallOperationAction(operation_ : Operation) {
	name := "Call(" + operation.name + ")";
	operation := operation_;
	target := new InputPin(name + ".target", operation_._'class', 1, 1);
	addPinsFromParameters(result, operation_.ownedParameter);
}

constructor ClearAssociationAction::ClearAssociationAction(association_ : Association) {
	name := "Clear(" + association_.name + ")";
	association := association_;
	_'object' := new InputPin(name + ".object", null, 1, 1);
	_'object'.isOrdered := false;
}

constructor CreateLinkAction::CreateLinkAction(association_ : Association, unlimitedNaturalType : Type) {
	name := "Create(" + association_.name + ")";
	association_.ownedEnd->forEach(ownedEnd) {
		new LinkEndCreationData(result, ownedEnd, unlimitedNaturalType);
	};
}

constructor CreateObjectAction::CreateObjectAction(class_ : Class) {
	name := "Create(" + class_.name + ")";
	classifier := class_;
	result.result := new OutputPin(name + ".result", class_, 1, 1);
}

constructor DestroyLinkAction::DestroyLinkAction(association_ : Association, unlimitedNaturalType : Type) {
	name := "Destroy(" + association_.name + ")";
	association_.ownedEnd->forEach(ownedEnd) {
		new LinkEndDestructionData(result, ownedEnd, unlimitedNaturalType);
	};
}

constructor DestroyObjectAction::DestroyObjectAction(class_ : Class) {
	name := "Destroy(" + class_.name + ")";
	isDestroyLinks := true;
	isDestroyOwnedObjects := true;
	target := new InputPin(name + ".target", class_, 1, 1);
}

constructor ReadExtentAction::ReadExtentAction(class_ : Class) {
	name := "ReadExtent" + if class_ = null then "" else "(" + class_.name + ")" endif;
	classifier := class_;
	result.result := new OutputPin(name + ".result", class_, 0, -1);
}

constructor ReadIsClassifiedObjectAction::ReadIsClassifiedObjectAction(type : Classifier, direct : Boolean, booleanType : Type) {
	name := "ReadClassifiedObject(" + type.name + ")";
	classifier := type;
	isDirect := direct;
	_'object' := new InputPin(name + ".object", null, 1, 1);
	result.result := new OutputPin(name + ".result", booleanType, 1, 1);
}

constructor ReadLinkAction::ReadLinkAction(associationEnd : Property) {
	name := "ReadLink(" + associationEnd.name + ")";
	addPinsFromProperties(result, associationEnd.association.ownedEnd->asSequence()->excluding(associationEnd)->asOrderedSet());
	addPin(result, object OutputPin{}, associationEnd);
}

constructor ReadSelfAction::ReadSelfAction(type : Type) {
	name := "ReadSelf";
	result.result := new OutputPin(name + ".result", type, 1, 1);
}

constructor ReadStructuralFeatureAction::ReadStructuralFeatureAction(type : Type, feature : Property) {
	name := "Read(" + feature.name + ")";
	structuralFeature := feature;
	_'object' := new InputPin(name + ".object", type, 1, 1);
	result.result := new OutputPin(name + ".result", feature.type, 1, 1);
}

constructor ReclassifyObjectAction::ReclassifyObjectAction(type : Type, oldClassifiers : Set(Classifier), newClassifiers : Set(Classifier), replaceAll : Boolean) {
	var oldClassifierList := "";
	oldClassifiers.name->forEach(oldName) {
		if oldClassifierList.length() > 0 then {
			oldClassifierList := oldClassifierList + ",";
		} endif;
		oldClassifierList := oldClassifierList + oldName;
	};
	if oldClassifierList.length() = 0 and isReplaceAll then {
		oldClassifierList := "*";
	} endif;
	
	var newClassifierList := "";
	newClassifiers.name->forEach(newName) {
		if newClassifierList.length() > 0 then {
			newClassifierList := newClassifierList + ",";
		} endif;
		newClassifierList := newClassifierList + newName;
	};
	
	name := "Reclassify(" + oldClassifierList + " to " + newClassifierList + ")";	
	_'object' := new InputPin(name + ".object", type, 1, 1);
	oldClassifier := oldClassifiers;
	newClassifier := newClassifiers;
	isReplaceAll := replaceAll;
}

constructor SendSignalAction::SendSignalAction(signal_ : Signal) {
	name := "SendSignal(" + signal.name + ")";
	signal := signal_;
	target := new InputPin(name + ".target", null, 1, 1);
	addPinsFromProperties(result, signal.allAttributes());
}

constructor StartObjectBehaviorAction::StartObjectBehaviorAction(class_ : Class) {
	name := "Start(" + if class_ = null then "any" else class_.name endif + ")";
	_'object' := new InputPin(name + ".object", class_, 1, 1);
	isSynchronous := false;
}

constructor TestIdentityAction::TestIdentityAction(testName : String, booleanType : Type) {
	name := "Test(" + testName + ")";
	first := new InputPin(name + ".first", null, 1, 1);
	second := new InputPin(name + ".second", null, 1, 1);
	result._'result' := new OutputPin(name + ".result", booleanType, 1, 1);
}

constructor ValueSpecificationAction::ValueSpecificationAction(valueSpecification : ValueSpecification) {
	name := "Value(" + valueSpecification.name + ")";
	value := valueSpecification;
	result.result := new OutputPin(name + ".result", valueSpecification.type, 1, 1);
}

constructor LiteralBoolean::LiteralBoolean(b : Boolean, t : Type) {
	name := b.toString();
	value := b;
	type := t;
}

constructor LiteralString::LiteralString(s : String, t : Type) {
	name := "\"" + s + "\"";
	value := s;
	type := t;
}

constructor LiteralInteger::LiteralInteger(i : Integer, t : Type) {
	name := i.toString();
	value := i;
	type := t;
}

constructor LiteralUnlimitedNatural::LiteralUnlimitedNatural(t : Type) {
	name := "*";
	type := t;
}

constructor LiteralNull::LiteralNull() {
	name := "null";
}

constructor InstanceValue::InstanceValue(spec : InstanceSpecification) {
	instance := spec;
	type := spec.classifier![true];
}

constructor InstanceValue::InstanceValue(type_ : Classifier) {
	instance := object InstanceSpecification {
		classifier += type_;
	};
	type := type_;
}

// Structured Activity Nodes

constructor StructuredActivityNode::StructuredActivityNode(name_ : String) {
	name := name_;
}

constructor ExpansionRegion::ExpansionRegion(name_ : String, mode_ : ExpansionKind) {
	name := name_;
	mode := mode;
}

constructor ExpansionNode::ExpansionNode(sourceName : String, region : ExpansionRegion, isInput : Boolean) {
	if isInput then {
		name := region.name + if sourceName = null then ".inputElement" else ".inputElement(" + sourceName + ")" endif;
		regionAsInput := region;
	} else {
		name := region.name + if sourceName = null then ".outputElement" else ".outputElement(" + sourceName + ")" endif;
		regionAsOutput := region;
	} endif;
}

helper addToStructuredNode(inout structuredNode : StructuredActivityNode, in nodes : Set(ActivityNode), in edges : Set(ActivityEdge)) : Set(ActivityEdge) {
	structuredNode.node += nodes;
	return addEdgesToStructuredNode(structuredNode, edges);
}

helper addEdgesToStructuredNode(inout structuredNode : StructuredActivityNode, in edges : Set(ActivityEdge)) : Set(ActivityEdge) {
	var allOwnedNodes := structuredNode.allOwnedNodes();
	var internalEdges := edges[allOwnedNodes->includes(source) and allOwnedNodes->includes(target)];
	structuredNode.edge += internalEdges;
	return edges - internalEdges;
}

helper addToExpansionRegion(inout region : ExpansionRegion, nodes : Set(ActivityNode), edges : Set(ActivityEdge)) : Set(ActivityEdge) {
	region.node += nodes;
	var outerEdges : Set(ActivityEdge);
	var allOwnedNodes := region.allOwnedNodes();
	edges->forEach(edge) {
		var sourceIsContained := allOwnedNodes->includes(edge.source);
		var targetIsContained := allOwnedNodes->includes(edge.target);
		if sourceIsContained and targetIsContained or
			edge.source.oclIsKindOf(ExpansionNode) and
				region = edge.source.oclAsType(ExpansionNode).regionAsInput or
			edge.target.oclIsKindOf(ExpansionNode) and
				region = edge.target.oclAsType(ExpansionNode).regionAsOutput then {
			region.edge += edge;
		} else {
			if targetIsContained then {
				// If an edge crosses into the region, then redirect its target.
				edge.target :=
					if edge.oclIsKindOf(ControlFlow) then region
					else {
						var inputPin := new InputPin (region,
							region.name + ".input(" + edge.source.name + ")",
							if edge.target.oclIsKindOf(ObjectNode) then edge.target.oclAsType(ObjectNode).type
							else null endif,
							if edge.target.oclIsKindOf(Pin) then edge.target.oclAsType(Pin).lower
							else 0 endif,
							if edge.target.oclIsKindOf(Pin) then edge.target.oclAsType(Pin).upper
							else -1 endif
						);
						new ObjectFlow(region, inputPin, edge.target);
						inputPin		
					} endif;
			} else if sourceIsContained then {
				// If an edge crosses out of the region, then redirect its source.
				edge.source :=
					if edge.oclIsKindOf(ControlFlow) then region
					else {
						var outputNode ::= new ExpansionNode(edge.source.name, region, false);
						new ObjectFlow(region, edge.source, outputNode);
						outputNode
					} endif;
			} endif endif;
		} endif;
	};
	return edges - region.edge;
}

// Other

helper nameOf(element : Element) : String {
	return
		if element = null then "<Null>"
		else if element.oclIsInvalid() then "<Invalid>"
		else if not element.oclIsKindOf(NamedElement) then "<Not Named>"
		else let name = element.oclAsType(NamedElement).name in
			if name = null then "<No Name>"
			else "'" + name + "'" endif
		endif endif endif;
}


