--Author Manel Fredj-CEA LIST
library StateDiagram;

import Converter.Utils.ConverterLibs;
import StateDiagVisualIDs;
import GeneralMappingsandHelpers;


modeltype di2 uses 'http://www.papyrusuml.org/di2';
modeltype notation uses 'http://www.eclipse.org/gmf/runtime/1.0.2/notation';
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype uml uses 'http://www.eclipse.org/uml2/2.1.0/UML';


mapping di2::GraphNode::stateDiagNode2Shape() : notation::Shape inherits di2::GraphNode::node2Shape
{
	--add 3 eAnnotations as in class diagram
	eAnnotations := setEAnnotations ();
	
	if (self.getElement().oclIsTypeOf(uml::State)) then {
		type := VisualId_State;
		children := setChildrenForState(self);	
	} endif;
	if (self.getElement().oclIsTypeOf(uml::StateMachine)) then {
		type := VisualId_StateMachine;
		children := setChildrenForStateMachine(self);		
	} endif;
	if (self.getElement().oclIsTypeOf(uml::Comment)) then {
		-- type := VisualId_Comment;
	} endif;
	if (self.getElement().oclIsTypeOf(uml::Region)) then {
		type := VisualId_Region;
		children := setChildrenForRegion(self);
	  	eAnnotations += object ecore::EAnnotation {
			source := "RegionAnnotationKey";
			details := object ecore::EStringToStringMapEntry {
				key   := "RegionZoneKey";
				value := "";
			};
		};
	} endif;
	if (self.getElement().oclIsTypeOf(uml::FinalState)) then {
		type := VisualId_FinalState;
		children := setChildrenForPseudoState (self, VisualId_FinalState_DecoNode1, VisualId_FinalState_DecoNode2);
	} endif;
	if (self.getElement().oclIsTypeOf(uml::ConnectionPointReference)) then {
		type := VisualId_ConnectionPoint;
		children := setChildrenForPseudoState (self, VisualId_ConnectionPoint_DecoNode1, VisualId_ConnectionPoint_DecoNode2);
	} endif;
	if (self.getElement().oclIsTypeOf(uml::Pseudostate)) then {
		var pseudoState := self.getElement().oclAsType(uml::Pseudostate);
		if (pseudoState.kind = uml::PseudostateKind::initial) then {
			type := VisualId_InitialState;
			children := setChildrenForPseudoState (self, VisualId_InitialState_DecoNode1, VisualId_InitialState_DecoNode2);
		} endif;
		if (pseudoState.kind = uml::PseudostateKind::shallowHistory) then {
			type := VisualId_ShallowHistoryState;
			children := setChildrenForPseudoState (self, VisualId_ShallowHistoryState_DecoNode1, VisualId_ShallowHistoryState_DecoNode2);
		} endif;
		if (pseudoState.kind = uml::PseudostateKind::deepHistory) then {
			type := VisualId_DeepHistoryState;
			children := setChildrenForPseudoState (self, VisualId_DeepHistoryState_DecoNode1, VisualId_DeepHistoryState_DecoNode2);
		} endif;
		if (pseudoState.kind = uml::PseudostateKind::choice) then {
			type := VisualId_Choice;
			children := setChildrenForPseudoState (self, VisualId_Choice_DecoNode1, VisualId_Choice_DecoNode2);
		} endif;
		if (pseudoState.kind = uml::PseudostateKind::join) then {
			type := VisualId_Choice;
			children := setChildrenForPseudoState (self, VisualId_Choice_DecoNode1, VisualId_Choice_DecoNode2);
		} endif;
		if (pseudoState.kind = uml::PseudostateKind::fork) then {
			type := VisualId_Fork;
			children := setChildrenForPseudoState (self, VisualId_Fork_DecoNode1, VisualId_Fork_DecoNode2);
		} endif;
		if (pseudoState.kind = uml::PseudostateKind::junction) then {
			type := VisualId_Junction;
			children := setChildrenForPseudoState (self, VisualId_Junction_DecoNode1, VisualId_Junction_DecoNode2);
		} endif;
		if (pseudoState.kind = uml::PseudostateKind::terminate) then {
			type := VisualId_Terminate;
			children := setChildrenForPseudoState (self, VisualId_Terminate_DecoNode1, VisualId_Terminate_DecoNode2);
		} endif;
		if (pseudoState.kind = uml::PseudostateKind::entryPoint) then {
			type := VisualId_EntryPoint;
			children := setChildrenForPseudoState (self, VisualId_EntryPoint_DecoNode1, VisualId_EntryPoint_DecoNode2);
		} endif;
		if (pseudoState.kind = uml::PseudostateKind::exitPoint) then {
			type := VisualId_ExitPoint;
			children := setChildrenForPseudoState (self, VisualId_ExitPoint_DecoNode1, VisualId_ExitPoint_DecoNode2);
		} endif;
	} endif;
}


helper setChildrenForPseudoState(in node : di2::GraphNode, in visualID1 : String, in visualID2 : String) : OrderedSet(notation::Node)
{
	-- first child	
	var child1 := object notation::DecorationNode {
		type := visualID1;
		layoutConstraint := object notation::Location {
			x := 20
		};
	};
	var child2 := object notation::DecorationNode {
		type := visualID2;
		layoutConstraint := object notation::Location {
			x := 20
		};
	};
	return OrderedSet {
		child1, child2
	};
};
		
---------------------------------------------------------------------------
--set children for state

helper setChildrenForState(in node : di2::GraphNode) : OrderedSet(notation::Node)
{
	-- first child	
	var child1 := object notation::DecorationNode {
		type:=VisualId_State_DecoNode1;
	};

	-- first child	
	var child2 := object notation::DecorationNode {
		type:=VisualId_State_DecoNode2;
	};
	/*
	-- second child	
	var child2 := object notation::BasicCompartment {
		type:=VisualId_Class_Composite_Compartiment;
		--set children as properties
		children:= setPropertiesForState(node.contained);
		layoutConstraint:=object notation::Bounds {};
	};		
	*/
	--convert edges in the composite 

	return OrderedSet {
		child1, child2
	};
}

helper setChildrenForStateMachine(in node : di2::GraphNode) : OrderedSet(notation::Node)
{
	-- first child	
	var child1 := object notation::DecorationNode {
		type := VisualId_StateMachine_DecoNode1;
	};
	var child2 := object notation::DecorationNode {
		type := VisualId_StateMachine_DecoNode2;
		var containedElements : OrderedSet(di2::GraphNode) := node.getSubElementsOfPackage();
		containedElements->forEach (containedElement) {
			var shape : notation::Shape ::= containedElement.map stateDiagNode2Shape();		
			if (shape.type != "") then {
				--don't add invalid IDs
				children += shape;
			} endif;
		};
	};

	return OrderedSet {
		child1, child2
	};
}

helper setChildrenForRegion(in node : di2::GraphNode) : OrderedSet(notation::Node)
{
	-- first child	
	var child1 := object notation::DecorationNode {
		type := VisualId_Region_DecoNode;
		var containedElements : OrderedSet(di2::GraphNode) := node.getSubElementsOfPackage();
		containedElements->forEach (containedElement) {
			var shape : notation::Shape ::= containedElement.map stateDiagNode2Shape();
			if (shape.type != "") then {		
				--don't add invalid IDs
				children += shape;
			} endif;
		};
	};

	return OrderedSet {
		child1
	};
}

/*
--in contrained attributes: properties or nested classes
helper setPropertiesForState(in contained:OrderedSet(di2::DiagramElement)) : OrderedSet(notation::Node)
{
	var setOfChildren:OrderedSet(notation::Node); 
	var child:notation::Node;																
	contained ->forEach (node|node.oclIsTypeOf(di2::GraphNode)) {
	
		if(node.oclAsType(di2::GraphNode).getElement().oclIsTypeOf(uml::Property)) then {
			child := node.oclAsType(di2::GraphNode).map ComponentClass2Property();
			setOfChildren += child;
		} endif;
		if (node.oclAsType(di2::GraphNode).getElement().oclIsTypeOf(uml::Class)) then {
			child := node.oclAsType(di2::GraphNode).map ComponentClass2Class(node.oclAsType(di2::GraphNode));
			setOfChildren += child;
		} endif;
	};								

	return setOfChildren;
}


-----------------------------------------------------------------------------
-- case of properties
mapping di2::GraphNode::ComponentClass2Property() : notation::Shape  {

	type := VisualId_Component_Property ;
	--seteAnnotation
	eAnnotations := setEAnnotations ();
	--setchildren
	children:=setChildrenForComponentProperty();	
	
	--set size and width and high 
	layoutConstraint := object notation::Bounds {
		var size : notation::Size :=  self.size.map dimension2Size();
		var location : notation::Location := self.oclAsType(di2::GraphNode).position.map point2Location();
		x := location.x; 
		y := location.y; 		
		width := size.width;
		height := size.height; 
	};	
	--set element	
	element := self.getElement().oclAsType(ecore::EObject);
}  

helper setChildrenForComponentProperty() : OrderedSet(notation::Node)
{
      --<children xmi:type="notation:DecorationNode"     type="5126"/>
      --<children xmi:type="notation:BasicCompartment"   type="7077">
      --	<layoutConstraint xmi:type="notation:Bounds" />
      --</children>

	-- first child	
	var child1 := object notation::DecorationNode {
		type:=VisualId_Component_Property_Label;
		--the id is set automatically
	};

	-- second child	
	var child2 := object notation::BasicCompartment {
		type:=VisualId_Component_Property_Compartiment;
		layoutConstraint:=object notation::Bounds {};
	};

	return OrderedSet {child1, child2};
}


-----------------------------------------------------------------------------
-- case of nested classes

mapping di2::GraphNode::ComponentClass2Class(in node:di2::GraphNode) : notation::Shape {

	type := VisualId_Component_Class;
	--seteAnnotation
	eAnnotations := setEAnnotations ();
	--setchildren
	children:=setChildrenForComponentClass(node);	
	
	--set size and width and high 
	layoutConstraint := object notation::Bounds {
		var size : notation::Size :=  self.size.map dimension2Size();
		var location : notation::Location := self.oclAsType(di2::GraphNode).position.map point2Location();
		x := location.x; 
		y := location.y; 		
		width := size.width;
		height := size.height; 
	};
	
	--set element
	element := self.getElement().oclAsType(ecore::EObject);
} 

helper setChildrenForComponentClass(in node:di2::GraphNode) : OrderedSet(notation::Node)
{
      --<children xmi:type="notation:DecorationNode"     type="5126"/>
      --<children xmi:type="notation:BasicCompartment"   type="7077">
      --	<layoutConstraint xmi:type="notation:Bounds" />
      --</children>

	-- first child	
	var child1 := object notation::DecorationNode {
		type:=VisualId_Component_Class_Label;
		--the id is set automatically
	};

	-- second child	
	var child2 := object notation::BasicCompartment {
		type:=VisualId_Component_Class_Compartiment;
		
		--set children as properties in the case that the nested class contains properties
		children:= setPropertiesForState(node.contained);
		layoutConstraint:=object notation::Bounds {};
	};
	
	return OrderedSet{child1, child2};
}


*/