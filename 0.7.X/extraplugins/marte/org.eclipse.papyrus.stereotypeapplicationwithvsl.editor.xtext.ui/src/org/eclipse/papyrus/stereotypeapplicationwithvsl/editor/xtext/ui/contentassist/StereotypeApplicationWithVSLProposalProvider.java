/*
* generated by Xtext
*/
package org.eclipse.papyrus.stereotypeapplicationwithvsl.editor.xtext.ui.contentassist;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.jface.text.contentassist.CompletionProposal;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.papyrus.core.utils.DisplayUtils;
import org.eclipse.papyrus.marte.vsl.ui.contentassist.ProposalUtils;
import org.eclipse.papyrus.stereotypeapplicationwithvsl.editor.xtext.stereotypeApplicationWithVSL.StereotypeApplicationRule;
import org.eclipse.papyrus.stereotypeapplicationwithvsl.editor.xtext.stereotypeApplicationWithVSL.TagSpecificationRule;
import org.eclipse.papyrus.stereotypeapplicationwithvsl.editor.xtext.ui.contentassist.AbstractStereotypeApplicationWithVSLProposalProvider;
import org.eclipse.uml2.uml.Classifier;
import org.eclipse.uml2.uml.Element;
import org.eclipse.uml2.uml.NamedElement;
import org.eclipse.uml2.uml.Property;
import org.eclipse.uml2.uml.TypedElement;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
/**
 * see http://www.eclipse.org/Xtext/documentation/latest/xtext.html#contentAssist on how to customize content assistant
 */
public class StereotypeApplicationWithVSLProposalProvider extends AbstractStereotypeApplicationWithVSLProposalProvider {

	private ILabelProvider labelProvider = DisplayUtils.getLabelProvider() ;
	
	
	/* *************************************************
	 * 
	 * Private Utility method for creating a completion proposal
	 * 
	 **************************************************/
	
	protected ICompletionProposal createCompletionProposal(NamedElement namedElement, 
														String completionString, 
														String displayString, 
														ContentAssistContext context) {
		String additionalProposalInfo = "" + namedElement.getQualifiedName() + "\n" + '(' + namedElement.eClass().getName() + ')' ;
		
		ICompletionProposal completionProposal = new CompletionProposal(completionString, 	// String to be inserted 
				context.getOffset(),  							// Offset
				context.getSelectedText().length(),				// Replacement length
				completionString.length(),						// cursorPosition
				labelProvider.getImage(namedElement)	,	// image
				" " + displayString,									// displayString
				null							,				// contextInformation
				additionalProposalInfo							// additionalProposalInfo
				);
		return completionProposal ;
	}
	
	protected ICompletionProposal createCompletionProposal( 
			String completionString, 
			String displayString, 
			ContentAssistContext context) {

		ICompletionProposal completionProposal = new CompletionProposal(completionString, 	// String to be inserted 
				context.getOffset(),  							// Offset
				context.getSelectedText().length(),				// Replacement length
				completionString.length(),						// cursorPosition
				null	,	// image
				" " + displayString,									// displayString
				null							,				// contextInformation
				""							// additionalProposalInfo
		);
		return completionProposal ;
	}
	
	/**
	 * Private Utility method for creating a completion proposal with replacement of prefix
	 * 
	 * @param namedElement The named element for which completion proposal must be created
	 * @param completionString The actual completion string
	 * @param displayString The way the completion is displayed in the completion list
	 * @param context Some information related to the context of the completion
	 * @return
	 */
	protected ICompletionProposal createCompletionProposalWithReplacementOfPrefix(NamedElement namedElement, 
														String completionString, 
														String displayString, 
														ContentAssistContext context) {
		String additionalProposalInfo = "" + namedElement.getQualifiedName() + "\n" + '(' + namedElement.eClass().getName() + ')' ;
		
		ICompletionProposal completionProposal = new CompletionProposal(completionString, 	// String to be inserted 
				context.getOffset() - context.getPrefix().length(),  							// Offset
				context.getPrefix().length(),				// Replacement length
				completionString.length(),						// cursorPosition
				labelProvider.getImage(namedElement)	,	// image
				" " + displayString,									// displayString
				null							,				// contextInformation
				additionalProposalInfo							// additionalProposalInfo
				);
		return completionProposal ;
	}
	
	@Override
	public void completeTagSpecificationRule_Property(EObject model,
			Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		List<NamedElement> visibleProperties = getVisibleProperties(model) ;
		visibleProperties = this.sortByKindAndName(visibleProperties) ;
		for (EObject o : visibleProperties) {
			NamedElement namedElement = (NamedElement) o ;
			if (namedElement.getName().startsWith(context.getPrefix())) {
				String completionString = namedElement.getName().substring(context.getPrefix().length()) ;
				String displayString = namedElement.getName() ;
				if (namedElement instanceof TypedElement) {
					TypedElement typedElement = (TypedElement) namedElement ;
					displayString += typedElement.getType() != null ?
										" : " + typedElement.getType().getName():
										"" ;
				}
				ICompletionProposal completionProposal = createCompletionProposal(namedElement, completionString, displayString, context) ;
				acceptor.accept(completionProposal) ;
			}
		}
	}
	
	private List<NamedElement> getVisibleProperties(EObject rule) {
		List<NamedElement> visibleProperties = new ArrayList<NamedElement>() ;
		// first retrieves the context stereotype
		EObject context = rule ;
		while (context != null && !(context instanceof StereotypeApplicationRule)) {
			context = context.eContainer() ;
		}
		if (context != null) {
			// retrieves the stereotype which is applied
			StereotypeApplicationRule stAppRule = (StereotypeApplicationRule)context ;
			if (stAppRule.getStereotype() != null) {
				// add all the available properties for this stereotype 
				visibleProperties.addAll(stAppRule.getStereotype().getAllAttributes()) ;
				// removes derived properties or those which name starts with "base_"
				List<Property> filteredList = new ArrayList<Property>(stAppRule.getStereotype().getAllAttributes()) ;
				for (Property p : filteredList) {
					if (p.getName() == null ||
							p.getName().startsWith("base_") ||
							p.isDerived())
						visibleProperties.remove(p) ;
				}
				// removes the ones which have already been used
				if (stAppRule.getTagSpecification() != null) {
					for (TagSpecificationRule tag : stAppRule.getTagSpecification()) {
						if (tag.getProperty() != null && visibleProperties.contains(tag.getProperty()))
							visibleProperties.remove(tag.getProperty()) ;
					}
				}
			}
		}
		return visibleProperties ;
	}

	
	
	/* *************************************************
	 * 
	 * Private utility method for sorting a list of NamedElement by kind and name
	 * 
	 **************************************************/

	protected List<NamedElement> sortByKindAndName(List<NamedElement> list) {
		List<NamedElement> sortedList = new ArrayList<NamedElement>() ;
		HashMap<EClass, List<NamedElement>> namedElementGroups = new HashMap<EClass, List<NamedElement>>() ;
		
		for (NamedElement n : list) {
			if (! namedElementGroups.containsKey(n.eClass())) {
				List<NamedElement> group = new ArrayList<NamedElement>() ;
				group.add(n) ;
				namedElementGroups.put(n.eClass(), group) ;
			}
			else {
				List<NamedElement> group = namedElementGroups.get(n.eClass()) ;
				boolean inserted = false ;
				for (int i = 0 ; inserted == false && i < group.size() ; i++) {
					if (group.get(i).getName().compareTo(n.getName()) > 0) {
						group.add(i, n) ;
						inserted = true ;
					}
				}
				if (!inserted) group.add(n) ;
				namedElementGroups.put(n.eClass(), group) ;
			}
		}
		
		for (EClass c : namedElementGroups.keySet()) {
			List<NamedElement> group = namedElementGroups.get(c) ;
			sortedList.addAll(group) ;
		}
		
		return sortedList ;
	}
	
	
	@Override
	public void completeExpressionValueRule_Expression(EObject model,
			Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		// TODO Auto-generated method stub
		if (model.eContainer() == null || !(model.eContainer() instanceof TagSpecificationRule))
			return ;
		TagSpecificationRule tagSpecificationRule = (TagSpecificationRule)model.eContainer() ;
		
		if (tagSpecificationRule.getProperty() == null || tagSpecificationRule.getProperty().getType() == null)
			return ;
		
		Property p = tagSpecificationRule.getProperty() ;
		
		Map<String, Element> allProposals = ProposalUtils.buildProposalForType((Classifier)p.getType(), p) ; 
		
		// List<String> allProposals = ProposalUtils.buildProposalForType((Classifier)p.getType()) ;
		for (String s : allProposals.keySet()) {
			String completionString = s.substring(context.getPrefix().length()) ;
			String displayString = s ;
			ICompletionProposal completionProposal = null ;
			if (allProposals.get(s) == null) {
				completionString = s.substring(context.getPrefix().length()) ;
				displayString = s ;
				completionProposal = createCompletionProposal(completionString, displayString, context) ;
				acceptor.accept(completionProposal) ;
			}
			else {
				completionString = s ;
				displayString = s ;
				if (displayString.contains(context.getPrefix())) {
					completionProposal = createCompletionProposalWithReplacementOfPrefix((NamedElement)allProposals.get(s), completionString, displayString, context) ;
					acceptor.accept(completionProposal) ;
				}
			}
		}
		//super.completeExpressionValueRule_Expression(model, assignment, context,
		//		acceptor);
	}
}
