/*****************************************************************************
 * Copyright (c) 2013, 2016 CEA LIST, Christian W. Damus, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Camille Letavernier (CEA LIST) camille.letavernier@cea.fr - Initial API and implementation
 *  Christian W. Damus - bug 465656
 *****************************************************************************/
import RSAToPapyrus;

modeltype notation "strict" uses 'http://www.eclipse.org/gmf/runtime/1.0.2/notation';
modeltype umlNotation "strict" uses 'http://www.eclipse.org/papyrus/umlnotation';
modeltype uml "strict" uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype sash "strict" uses 'http://www.eclipse.org/papyrus/0.7.0/sashdi';
modeltype config "strict" uses 'http:///RSAToPapyrusParameters.ecore';

transformation RSAActivityDiagram(inout semantics : uml, inout graphics : notation, out di : sash, in params : config);

main() {
	semantics.rootObjects()[uml::Element]->map toOwnedDiagrams();
}

query View::getDiagramType() : String{
	return 'PapyrusUMLActivityDiagram';
}

mapping notation::Diagram::generateDiagram() : notation::Diagram inherits Diagram::toPapyrusDiagram when {
	self.type = 'Activity'
}{
	end {
		graphics.objectsOfType(Shape)->any(type = 'Activity_Shape').map fixFramePosition();
		graphics.objectsOfType(Shape)->any(type = 'Activity_Shape').map createHeaders();
		
		graphics.objectsOfType(Shape)->select(type='Comment_Shape').map addCommentDecoration();
		graphics.objectsOfType(Shape)->select(type = 'Constraint_Shape').map addConstraintDecoration();
		
		graphics.objectsOfType(Shape)->select(type = 'ActivityPartition_Shape').map fixPartitionsLayout();
		
		graphics.objectsOfType(Shape).map fixDefaultSize();
	}
}

/**
*	Fix the default size for Join, Fork, Merge and Decision nodes
*/
mapping inout Shape::fixDefaultSize() disjuncts Shape::fixJoinForkSize, Shape::fixMergeDecisionSize {
	//Disjuncts
}

mapping inout Shape::fixJoinForkSize() when {
	self.type = 'JoinNode_Shape' or self.type = 'ForkNode_Shape'
} {
	var layout : Bounds := self.layoutConstraint.oclAsType(Bounds);
	
	if layout.width = -1 then layout.width := 101 endif;
	if layout.height = -1 then layout.height := 11 endif; 
}

mapping inout Shape::fixMergeDecisionSize() when {
	self.type = 'MergeNode_Shape' or self.type = 'DecisionNode_Shape'
} {
	var layout : Bounds := self.layoutConstraint.oclAsType(Bounds);
	
	if layout.width = -1 then layout.width := 50 endif;
	if layout.height = -1 then layout.height := 50 endif;
}

property partitionX : Integer = 20;

mapping inout Node::fixPartitionsLayout() {
	var width: Integer := 200; //Approximation. In RSA, the layout can be computed automatically based on the Partition's Contents. In Papyrus, this must be specified explicitely
	var marginHeight := 10; //Note: Papyrus currently has an additional margin in the bottom of Activities, which is ~60px. As a result, marginHeight rather corresponds to "marginTop" (Bug 459888)
	
	var bounds : Bounds := self.layoutConstraint.oclAsType(Bounds); 
	
	var parentCompartment : DecorationNode := self.oclAsType(EObject).eContainer().oclAsType(DecorationNode);
	var parent : Shape := parentCompartment.oclAsType(EObject).eContainer().oclAsType(Shape);
	var parentBounds := parent.layoutConstraint.oclAsType(Bounds);
	var parentHeight := parentBounds.height;
	
	var previousPosition : Integer := parentCompartment.children->select(type = 'ActivityPartition_Shape')->indexOf(self) - 1; 
	var previousPartition : Node := parentCompartment.children->select(type = 'ActivityPartition_Shape')->at(previousPosition);
	
	if previousPartition.oclIsUndefined() then { /* First partition */
		bounds.x := partitionX;
	} else {
		previousPartition.map fixPartitionsLayout(); /* Ensure that partition n-1 is already fixed */
		var previousBounds := previousPartition.layoutConstraint.oclAsType(Bounds);
		bounds.x := previousBounds.x + previousBounds.width - 1; //-1 to force Partition border overlap 
	} endif;
	
	bounds.width := width.max(bounds.width);
	bounds.y := marginHeight;
	bounds.height := (parentHeight - marginHeight * 2).max(bounds.height).max(400);
}

mapping inout Shape::addCommentDecoration() when {
	self.type = 'Comment_Shape' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := 'Comment_BodyLabel';
	}

}

mapping inout Shape::addConstraintDecoration() when {
	self.type = 'Constraint_Shape' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := 'Constraint_BodyLabel'; //Constraint specification
	}	

}


/* Add a margin on the top and left */
mapping inout Shape::fixFramePosition() {
	var bounds := self.layoutConstraint.oclAsType(Bounds);
	var margin := 10;
	if bounds.x < margin then bounds.x := margin endif;
	if bounds.y < margin then bounds.y := margin endif;
}

mapping inout Shape::createHeaders() : param: DecorationNode, pre: DecorationNode, post: DecorationNode {
	self.children += param;
	self.children += pre;
	self.children += post;
	
	param.type := 'Activity_ParameterCompartment';
	pre.type := 'Activity_PreconditionCompartment';
	post.type := 'Activity_PostconditionCompartment';
}

mapping Node::toNode() : Node disjuncts
	UMLShape::toPapyrusShape,
	UMLShapeCompartment::toStructureCompartment,
	BasicSemanticCompartment::toListCompartment,
	BasicDecorationNode::toConnectorLabel,
	BasicDecorationNode::toLabel
	//TODO: Disjunct nodes mapping
;

mapping Edge::toEdge() : Edge disjuncts
	UMLConnector::toCommentLink,
	UMLConnector::toConstraintLink,
	UMLConnector::toPapyrusConnector
	//TODO: Disjunct edges mapping
;

mapping UMLShapeCompartment::toStructureCompartment() : DecorationNode inherits UMLShapeCompartment::toAbstractStructureCompartment when {
	self.type = 'StructureCompartment' or self.type = 'PackageContents' or self.type = 'ActivityCompartment' or self.type='PartitionCompartment' or self.type='StructuredActivityNodeCompartment' 
	and not self.getType().oclIsUndefined();
}{
	
}


/***** Nodes **********/

mapping UMLShape::toPapyrusShape() : Shape inherits Shape::toPapyrusShape when {
	self.type = 'Activity Frame' or self.type = 'Partition' or (
		self.type = '' and not self.getType().oclIsUndefined() and (
			self.element.oclIsTypeOf(Constraint)or
			self.element.oclIsTypeOf(FlowFinalNode)or
			self.element.oclIsTypeOf(ActivityPartition)or
			self.element.oclIsTypeOf(IntervalConstraint)or
			self.element.oclIsTypeOf(ActionInputPin)or
			self.element.oclIsTypeOf(BroadcastSignalAction)or
			self.element.oclIsTypeOf(ActionInputPin)or
			self.element.oclIsTypeOf(ValuePin)or
			self.element.oclIsTypeOf(Constraint)or
			self.element.oclIsTypeOf(ValuePin)or
			self.element.oclIsTypeOf(SequenceNode)or
			self.element.oclIsTypeOf(ActionInputPin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(ReadSelfAction)or
			self.element.oclIsTypeOf(ActivityFinalNode)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(SendSignalAction)or
			self.element.oclIsTypeOf(InitialNode)or
			self.element.oclIsTypeOf(AddStructuralFeatureValueAction)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(DurationConstraint)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(LoopNode)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(ForkNode)or
			self.element.oclIsTypeOf(ExpansionNode)or
			self.element.oclIsTypeOf(ActionInputPin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(CallOperationAction)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(IntervalConstraint)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(Constraint)or
			self.element.oclIsTypeOf(AddVariableValueAction)or
			self.element.oclIsTypeOf(ExpansionNode)or
			self.element.oclIsTypeOf(ValuePin)or
			self.element.oclIsTypeOf(Parameter)or
			self.element.oclIsTypeOf(ReadVariableAction)or
			self.element.oclIsTypeOf(OpaqueAction)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(ValuePin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(InterruptibleActivityRegion)or
			self.element.oclIsTypeOf(Constraint)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(JoinNode)or
			self.element.oclIsTypeOf(StructuredActivityNode)or
			self.element.oclIsTypeOf(ConditionalNode)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(ActionInputPin)or
			self.element.oclIsTypeOf(Constraint)or
			self.element.oclIsTypeOf(TimeConstraint)or
			self.element.oclIsTypeOf(DecisionNode)or
			self.element.oclIsTypeOf(ActivityParameterNode)or
			self.element.oclIsTypeOf(ActionInputPin)or
			self.element.oclIsTypeOf(ActionInputPin)or
			self.element.oclIsTypeOf(CentralBufferNode)or
			self.element.oclIsTypeOf(Comment)or
			self.element.oclIsTypeOf(DestroyObjectAction)or
			self.element.oclIsTypeOf(CreateObjectAction)or
			self.element.oclIsTypeOf(ValuePin)or
			self.element.oclIsTypeOf(ValuePin)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(DataStoreNode)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(ActionInputPin)or
			self.element.oclIsTypeOf(CallBehaviorAction)or
			self.element.oclIsTypeOf(ExpansionRegion)or
			self.element.oclIsTypeOf(SendObjectAction)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(TimeConstraint)or
			self.element.oclIsTypeOf(MergeNode)or
			self.element.oclIsTypeOf(DurationConstraint)or
			self.element.oclIsTypeOf(ValuePin)or
			self.element.oclIsTypeOf(ValueSpecificationAction)or
			self.element.oclIsTypeOf(AcceptEventAction)or
			self.element.oclIsTypeOf(Activity)or
			self.element.oclIsTypeOf(InputPin)or
			self.element.oclIsTypeOf(ReadStructuralFeatureAction)or
			self.element.oclIsTypeOf(OutputPin)or
			self.element.oclIsTypeOf(ValuePin)
		)
	)
}{
	
}


/****** Connector Labels ******/

mapping BasicDecorationNode::toConnectorLabel() : DecorationNode inherits Node::toPapyrusConnectorLabel when {
	not self.getType().oclIsUndefined() and (
		self.type = 'ToMultiplicityLabel' or
		self.type = 'ToRoleLabel' or
		self.type = 'FromMultiplicityLabel' or
		self.type = 'FromRoleLabel' or
		self.type = 'NameLabel' or
		self.type = 'KindLabel' or
		self.type = 'ObjectNodeNameLabel'
	)
}{}


/****** Compartments *******/

mapping BasicDecorationNode::toLabel() : DecorationNode inherits Node::toPapyrusNode when {
	not self.getType().oclIsUndefined() and
	self.element.oclIsKindOf(uml::NamedElement) and 
	(self.type = 'Name' or self.type = 'PartitionName' or self.type = 'ObjectNodeNameLabel')
}{}

mapping BasicSemanticCompartment::toListCompartment() : BasicCompartment inherits Node::toPapyrusNode, DrawerStyle::toDrawerStyle when {
	self.type.endsWith('Compartment') and not self.getType().oclIsUndefined()
}{
	result.children := self.findElement().map toContents(self);
}

mapping Element::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Activity::toContents
;

mapping Activity::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Activity::toActivityFigureParameterCompartmentContents,
	Activity::toActivityFigurePreconditionCompartmentContents,
	Activity::toActivityFigurePostCondtionCompartmentContents
;

mapping Activity::toActivityFigureParameterCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'Compartment';
}{
	init {
		result := (self.map fillParameter(node))
	}
}

mapping Activity::toActivityFigurePreconditionCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'Compartment';
}{
	init {
		result := (self.map fillConstraint(node))
	}
}

mapping Activity::toActivityFigurePostCondtionCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'Compartment';
}{
	init {
		result := (self.map fillConstraint(node))
	}
}

mapping uml::Activity::fillParameter(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='Compartment';
}{
	init {
		result := self.ownedParameter->selectByKind(Parameter).map toParameterInActivity(node)->asSequence();
	}
}

mapping uml::Activity::fillConstraint(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='Compartment';
}{
	init {
		result := self.precondition->selectByKind(Constraint).map toConstraintInActivity(node)->asSequence();
	}
}

mapping Parameter::toParameterInActivity(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Parameter_ParameterLabel';
}

mapping Constraint::toConstraintInActivity(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Constraint_PreconditionLabel';
}



/******* Edges ********/


mapping UMLConnector::toPapyrusConnector() : Connector inherits Connector::toPapyrusConnector when {
	self.type = '' and 
	not self.getType().oclIsUndefined() and (
		self.element.oclIsTypeOf(ObjectFlow)or
		self.element.oclIsTypeOf(ControlFlow)or
		self.element.oclIsTypeOf(ExceptionHandler)
	)
}{
	result.styles := self.map toFontStyle();
}

mapping UMLConnector::toCommentLink() : Connector inherits Connector::toCommentLink when{
	self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Comment) or 
	 	self.target.element.oclIsKindOf(Comment)
	)
}{
	result.type :='Comment_AnnotatedElementEdge';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
}

mapping UMLConnector::toConstraintLink() : Connector inherits Connector::toPapyrusConnector when{
	self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Constraint) or 
	 	self.target.element.oclIsKindOf(Constraint)
	)
}{	
	result.type :='Constraint_ConstrainedElementEdge';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
}


/****** Element Type queries ******/

query View::getNodeType(element : Element) : String {
	
	var type : String := null;
	var parent := element.container();
	
	//Specific cases for Output pins
	if element.oclIsTypeOf(OutputPin) then {
		
		type := switch {
			case (parent.oclIsTypeOf(OpaqueAction)) 'OutputPin_OpaqueActionOutputShape'; 
			case (parent.oclIsTypeOf(CreateObjectAction)) 'OutputPin_CreateObjectActionResultShape';
			case (parent.oclIsTypeOf(ReadStructuralFeatureAction)) 'OutputPin_ReadStructuralFeatureActionResultShape';
			case (parent.oclIsTypeOf(AcceptEventAction)) 'OutputPin_AcceptEventActionResultShape';
			case (parent.oclIsTypeOf(ValueSpecificationAction)) 'OutputPin_ValueSpecificationActionResultShape';
			case (parent.oclIsTypeOf(AddStructuralFeatureValueAction)) 'OutputPin_AddStructuralFeatureValueActionResultShape';
			case (parent.oclIsTypeOf(CallOperationAction)) 'OutputPin_CallOperationActionResultShape';
			case (parent.oclIsTypeOf(CallBehaviorAction)) 'OutputPin_CallBehaviorActionResultShape';
			case (parent.oclIsTypeOf(ReadVariableAction)) 'OutputPin_ReadVariableActionResultShape';
			case (parent.oclIsTypeOf(ReadSelfAction)) 'OutputPin_ReadSelfActionResultShape';
			
			case (parent.oclIsTypeOf(LoopNode) and parent.oclAsType(LoopNode).bodyOutput->includes(element.oclAsType(OutputPin))) 'OutputPin_LoopNodeBodyOutputShape';  
			case (parent.oclIsTypeOf(LoopNode) and parent.oclAsType(LoopNode)._result->includes(element.oclAsType(OutputPin))) 'OutputPin_LoopNodeResultShape';
			case (parent.oclIsTypeOf(LoopNode) and parent.oclAsType(LoopNode).loopVariable->includes(element.oclAsType(OutputPin))) 'OutputPin_LoopNodeVariableShape';
			
			else self.fail(); 
		}; 
	} endif;
	
	//Specific cases for Input pins
	if element.oclIsTypeOf(InputPin) then {
			
		type := switch {
			case (parent.oclIsTypeOf(LoopNode))	'InputPin_LoopNodeVariableInputShape';
			case (parent.oclIsTypeOf(ReadStructuralFeatureAction)) 'InputPin_ReadStructuralFeatureActionObjectShape';
			case (parent.oclIsTypeOf(BroadcastSignalAction)) 'InputPin_BroadcastSignalActionArgumentShape';
			case (parent.oclIsTypeOf(DestroyObjectAction)) 'InputPin_DestroyObjectActionTargetShape';
			case (parent.oclIsTypeOf(CallBehaviorAction)) 'InputPin_CallBehaviorActionArgumentShape';
			case (parent.oclIsTypeOf(OpaqueAction))	'InputPin_OpaqueActionInputShape';
			
			case (parent.oclIsTypeOf(SendSignalAction) and parent.oclAsType(SendSignalAction).target->includes(element.oclAsType(InputPin))) 'InputPin_SendSignalActionTargetShape';
			case (parent.oclIsTypeOf(SendSignalAction))	'InputPin_SendSignalActionArgumentShape';
			
			case (parent.oclIsTypeOf(AddStructuralFeatureValueAction) and parent.oclAsType(AddStructuralFeatureValueAction).value->includes(element.oclAsType(InputPin))) 'InputPin_AddStructuralFeatureValueActionValueShape'; 
			case (parent.oclIsTypeOf(AddStructuralFeatureValueAction) and parent.oclAsType(AddStructuralFeatureValueAction)._object->includes(element.oclAsType(InputPin))) 'InputPin_AddStructuralFeatureValueActionObjectShape';
			
			case (parent.oclIsTypeOf(SendObjectAction) and parent.oclAsType(SendObjectAction).target->includes(element.oclAsType(InputPin))) 'InputPin_SendObjectActionTargetShape';
			case (parent.oclIsTypeOf(SendObjectAction) and parent.oclAsType(SendObjectAction).request->includes(element.oclAsType(InputPin))) 'InputPin_SendObjectActionRequestShape';
			 
			case (parent.oclIsTypeOf(CallOperationAction) and parent.oclAsType(CallOperationAction).target->includes(element.oclAsType(InputPin))) 'InputPin_CallOperationActionTargetShape';
			case (parent.oclIsTypeOf(CallOperationAction)) 'InputPin_CallOperationActionArgumentShape';

			case (parent.oclIsTypeOf(AddVariableValueAction) and parent.oclAsType(AddVariableValueAction).insertAt->includes(element.oclAsType(InputPin))) 'InputPin_AddVariableValueActionInsertAtShape';
			case (parent.oclIsTypeOf(AddVariableValueAction) and parent.oclAsType(AddVariableValueAction).value->includes(element.oclAsType(InputPin))) 'InputPin_AddVariableValueActionValueShape';
			
			else self.fail();
		};

	} endif;
	
	//Specific cases for Action input pins
	if element.oclIsTypeOf(ActionInputPin) then {
		type := switch {
			case (parent.oclIsTypeOf(SendSignalAction) and parent.oclAsType(SendSignalAction).target->includes(element.oclAsType(InputPin))) 'ActionInputPin_SendSignalActionTargetShape';
			case (parent.oclIsTypeOf(SendSignalAction)) 'ActionInputPin_SendSignalActionArgumentShape';
			
			case (parent.oclIsTypeOf(SendObjectAction) and parent.oclAsType(SendObjectAction).target->includes(element.oclAsType(InputPin))) 'ActionInputPin_SendObjectActionTargetShape';
			case (parent.oclIsTypeOf(SendObjectAction) and parent.oclAsType(SendObjectAction).request->includes(element.oclAsType(InputPin))) 'ActionInputPin_SendObjectActionRequestShape'; 
			
			case (parent.oclIsTypeOf(CallOperationAction) and parent.oclAsType(CallOperationAction).target->includes(element.oclAsType(InputPin))) 'ActionInputPin_CallOperationActionTargetShape';
			case (parent.oclIsTypeOf(CallOperationAction)) 'ActionInputPin_CallOperationActionArgumentShape';
			
			case (parent.oclIsTypeOf(OpaqueAction)) 'ActionInputPin_OpaqueActionInputShape';
			case (parent.oclIsTypeOf(CallBehaviorAction)) 'ActionInputPin_CallBehaviorActionArgumentShape';
			
			else self.fail();
		};
	
	} endif;
	
	//Specific cases for Value pins
	if element.oclIsTypeOf(ValuePin) then {
		type := switch {		 
			
			case (parent.oclIsTypeOf(CallBehaviorAction)) 'ValuePin_CallBehaviorActionArgumentShape';
			case (parent.oclIsTypeOf(OpaqueAction)) 'ValuePin_OpaqueActionInputShape';
			
			case (parent.oclIsTypeOf(SendSignalAction) and parent.oclAsType(SendSignalAction).target->includes(element.oclAsType(InputPin))) 'ValuePin_SendSignalActionTargetShape';
			case (parent.oclIsTypeOf(SendSignalAction)) 'ValuePin_SendSignalActionArgumentShape';
			
			case (parent.oclIsTypeOf(CallOperationAction) and parent.oclAsType(CallOperationAction).target->includes(element.oclAsType(InputPin))) 'ValuePin_CallOperationActionTargetShape';
			case (parent.oclIsTypeOf(CallOperationAction)) 'ValuePin_CallOperationActionArgumentShape';
			
			case (parent.oclIsTypeOf(SendObjectAction) and parent.oclAsType(SendObjectAction).request->includes(element.oclAsType(InputPin))) 'ValuePin_SendObjectActionRequestShape';
			case (parent.oclIsTypeOf(SendObjectAction) and parent.oclAsType(SendObjectAction).target->includes(element.oclAsType(InputPin))) 'ValuePin_SendObjectActionTargetShape';

			else self.fail();
		};
	} endif;

	//TODO: specific cases for constraints (pre/post/...)
	
	if type <> null then 
		return type 
	endif;

	//Generated cases
	return
		if element.oclIsTypeOf(Constraint) then 'Constraint_Shape'
		elif element.oclIsTypeOf(Constraint) then 'Constraint_PreconditionLabel'
		elif element.oclIsTypeOf(Constraint) then 'Constraint_PostconditionLabel'
		elif element.oclIsTypeOf(Constraint) then 'Constraint_LocalPreconditionShape'
		elif element.oclIsTypeOf(Constraint) then 'Constraint_LocalPostconditionShape'
		elif element.oclIsTypeOf(IntervalConstraint) then 'IntervalConstraint_LocalPostconditionShape'
		elif element.oclIsTypeOf(IntervalConstraint) then 'IntervalConstraint_LocalPreconditionShape' 		
		elif element.oclIsTypeOf(DurationConstraint) then 'DurationConstraint_LocalPostconditionShape'
		elif element.oclIsTypeOf(TimeConstraint) then 'TimeConstraint_LocalPreconditionShape'
		elif element.oclIsTypeOf(TimeConstraint) then 'TimeConstraint_LocalPostconditionShape'
		elif element.oclIsTypeOf(DurationConstraint) then 'DurationConstraint_LocalPreconditionShape'
		elif element.oclIsTypeOf(FlowFinalNode) then 'FlowFinalNode_Shape' 
		elif element.oclIsTypeOf(ActivityPartition) then 'ActivityPartition_Shape'
		elif element.oclIsTypeOf(BroadcastSignalAction) then 'BroadcastSignalAction_Shape'
		elif element.oclIsTypeOf(SequenceNode) then 'SequenceNode_Shape'
		elif element.oclIsTypeOf(ReadSelfAction) then 'ReadSelfAction_Shape' 
		elif element.oclIsTypeOf(ActivityFinalNode) then 'ActivityFinalNode_Shape'
		elif element.oclIsTypeOf(SendSignalAction) then 'SendSignalAction_Shape' 
		elif element.oclIsTypeOf(InitialNode) then 'InitialNode_Shape' 
		elif element.oclIsTypeOf(AddStructuralFeatureValueAction) then 'AddStructuralFeatureValueAction_Shape'
		elif element.oclIsTypeOf(LoopNode) then 'LoopNode_Shape' 
		elif element.oclIsTypeOf(ForkNode) then 'ForkNode_Shape' 
		elif element.oclIsTypeOf(ExpansionNode) then 'ExpansionNode_InputShape' 
		elif element.oclIsTypeOf(CallOperationAction) then 'CallOperationAction_Shape'
		elif element.oclIsTypeOf(AddVariableValueAction) then 'AddVariableValueAction_Shape' 
		elif element.oclIsTypeOf(ExpansionNode) then 'ExpansionNode_OutputShape' 
		elif element.oclIsTypeOf(Parameter) then 'Parameter_ParameterLabel' 
		elif element.oclIsTypeOf(ReadVariableAction) then 'ReadVariableAction_Shape' 
		elif element.oclIsTypeOf(OpaqueAction) then 'OpaqueAction_Shape'
		elif element.oclIsTypeOf(InterruptibleActivityRegion) then 'InterruptibleActivityRegion_Shape'
		elif element.oclIsTypeOf(JoinNode) then 'JoinNode_Shape' 
		elif element.oclIsTypeOf(StructuredActivityNode) then 'StructuredActivityNode_Shape' 
		elif element.oclIsTypeOf(ConditionalNode) then 'ConditionalNode_Shape'
		elif element.oclIsTypeOf(DecisionNode) then 'DecisionNode_Shape' 
		elif element.oclIsTypeOf(ActivityParameterNode) then 'ActivityParameterNode_Shape' 
		elif element.oclIsTypeOf(CentralBufferNode) then 'CentralBufferNode_Shape' 
		elif element.oclIsTypeOf(Comment) then 'Comment_Shape' 
		elif element.oclIsTypeOf(DestroyObjectAction) then 'DestroyObjectAction_Shape' 
		elif element.oclIsTypeOf(CreateObjectAction) then 'CreateObjectAction_Shape'
		elif element.oclIsTypeOf(DataStoreNode) then 'DataStoreNode_Shape'		 
		elif element.oclIsTypeOf(CallBehaviorAction) then 'CallBehaviorAction_Shape' 
		elif element.oclIsTypeOf(ExpansionRegion) then 'ExpansionRegion_Shape' 
		elif element.oclIsTypeOf(SendObjectAction) then 'SendObjectAction_Shape'
		elif element.oclIsTypeOf(MergeNode) then 'MergeNode_Shape'
		elif element.oclIsTypeOf(ValueSpecificationAction) then 'ValueSpecificationAction_Shape' 
		elif element.oclIsTypeOf(AcceptEventAction) then 'AcceptEventAction_Shape' 
		elif element.oclIsTypeOf(Activity) then 'Activity_Shape' 
		elif element.oclIsTypeOf(ReadStructuralFeatureAction) then 'ReadStructuralFeatureAction_Shape' 		 
		else self.fail()
	endif;
	
	
	
}


query View::getDecorationType(element : Element) : String{
	var res := self.doGetDecorationType(element);
	
	/*
	log('Get papyrus ID for'+ self.element.eClass().name+', '+self.type);
	
	log(res);
	
	if self.container().oclIsKindOf(Node) then 
		log('IsNode')
	else 
		log('IsEdge')
	endif;
	*/
	
	return res;
	
}

query View::doGetDecorationType(element : Element) : String{
	return if self.container().oclIsKindOf(Node) then {
		return if element.oclIsTypeOf(ActivityPartition) then
			return switch {
				case (self.type = 'PartitionName') 'ActivityPartition_NameLabel';
				case (self.type = 'PartitionCompartment') 'ActivityPartition_ActivityNodeCompartment';
			}
			elif element.oclIsTypeOf(Constraint) then
				return switch {
					case (self.type = 'Name') 'Constraint_NameLabel';
				}
			elif element.oclIsTypeOf(IntervalConstraint) then
				return switch {
					case (self.type = 'Name') 'IntervalConstraint_LocalPostconditionNameLabel';
					
				}
			elif element.oclIsTypeOf(BroadcastSignalAction) then
				return switch {
					case (self.type = 'Name') 'BroadcastSignalAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(SequenceNode) then
				return switch {
					
					case (self.type = 'StructureCompartment') 'SequenceNode_ActivityNodeCompartment';
				}
			elif element.oclIsTypeOf(ReadSelfAction) then
				return switch {
					case (self.type = 'Name') 'ReadSelfAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(SendSignalAction) then
				return switch {
					case (self.type = 'Name') 'SendSignalAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(AddStructuralFeatureValueAction) then
				return switch {
					case (self.type = 'Name') 'AddStructuralFeatureValueAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(DurationConstraint) then
				return switch {
					case (self.type = 'Name') 'DurationConstraint_LocalPostconditionNameLabel';
					
				}
			elif element.oclIsTypeOf(LoopNode) then
				return switch {
					
					case (self.type = 'StructureCompartment') 'LoopNode_ActivityNodeCompartment';
				}
			elif element.oclIsTypeOf(CallOperationAction) then
				return switch {
					case (self.type = 'Name') 'CallOperationAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(IntervalConstraint) then
				return switch {
					case (self.type = 'Name') 'IntervalConstraint_LocalPreconditionNameLabel';
					
				}
			elif element.oclIsTypeOf(Constraint) then
				return switch {
					case (self.type = 'Name') 'Constraint_LocalPreconditionNameLabel';
					
				}
			elif element.oclIsTypeOf(AddVariableValueAction) then
				return switch {
					case (self.type = 'Name') 'AddVariableValueAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(ReadVariableAction) then
				return switch {
					case (self.type = 'Name') 'ReadVariableAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(OpaqueAction) then
				return switch {
					case (self.type = 'Name') 'OpaqueAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(InterruptibleActivityRegion) then
				return switch {
					
					case (self.type = 'StructureCompartment') 'InterruptibleActivityRegion_ActivityNodeCompartment';
				}
			elif element.oclIsTypeOf(Constraint) then
				return switch {
					case (self.type = 'Name') 'Constraint_LocalPostconditionNameLabel';
					
				}
			elif element.oclIsTypeOf(StructuredActivityNode) then
				return switch {
					case (self.type = 'Name') 'StructuredActivityNode_KeywordLabel';
					case (self.type = 'StructuredActivityNodeCompartment') 'StructuredActivityNode_ActivityNodeCompartment';
				}
			elif element.oclIsTypeOf(ConditionalNode) then
				return switch {
					
					case (self.type = 'StructureCompartment') 'ConditionalNode_ActivityNodeCompartment';
				}
			elif element.oclIsTypeOf(TimeConstraint) then
				return switch {
					case (self.type = 'Name') 'TimeConstraint_LocalPreconditionNameLabel';
					
				}
			elif element.oclIsTypeOf(ActivityParameterNode) then
				return switch {
					case (self.type = 'ObjectNodeNameLabel') 'ActivityParameterNode_NameLabel';
					
				}
			elif element.oclIsTypeOf(DestroyObjectAction) then
				return switch {
					case (self.type = 'Name') 'DestroyObjectAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(CreateObjectAction) then
				return switch {
					case (self.type = 'Name') 'CreateObjectAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(CallBehaviorAction) then
				return switch {
					case (self.type = 'Name') 'CallBehaviorAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(ExpansionRegion) then
				return switch {
					
					case (self.type = 'StructureCompartment') 'ExpansionRegion_ActivityNodeCompartment';
				}
			elif element.oclIsTypeOf(SendObjectAction) then
				return switch {
					case (self.type = 'Name') 'SendObjectAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(TimeConstraint) then
				return switch {
					case (self.type = 'Name') 'TimeConstraint_LocalPostconditionNameLabel';
					
				}
			elif element.oclIsTypeOf(DurationConstraint) then
				return switch {
					case (self.type = 'Name') 'DurationConstraint_LocalPreconditionNameLabel';
					
				}
			elif element.oclIsTypeOf(ValueSpecificationAction) then
				return switch {
					case (self.type = 'Name') 'ValueSpecificationAction_NameLabel';
					
				}
			elif element.oclIsTypeOf(Activity) then
				return switch {
					case (self.type = 'Name') 'Activity_NameLabel';
					case (self.type = 'ActivityCompartment') 'Activity_ActivityNodeCompartment';
				}
			elif element.oclIsTypeOf(ReadStructuralFeatureAction) then
				return switch {
					case (self.type = 'Name') 'ReadStructuralFeatureAction_NameLabel';
				}
			elif element.oclIsTypeOf(AcceptEventAction) then 
				return switch {
					case (self.type = 'Name') 'AcceptEventAction_NameLabel';
				}
			elif element.oclIsTypeOf(InputPin) then
				'InputPin_OpaqueActionInputNameLabel'
			elif element.oclIsTypeOf(ValuePin) then
				'ValuePin_OpaqueActionInputValueLabel'
			elif element.oclIsTypeOf(OutputPin) then
				'OutputPin_OpaqueActionOutputNameLabel'
			elif element.oclIsTypeOf(ActionInputPin) then
				'ActionInputPin_OpaqueActionInputNameLabel'
		endif
	} else {
		return if element.oclIsTypeOf(ObjectFlow)  then
			return switch {
				case (self.type='Name') 'ObjectFlow_NameLabel';		
				case (self.type = 'NameLabel') 'ObjectFlow_NameLabel';
				case (self.type = 'KindLabel') 'ObjectFlow_StereotypeLabel';
				
			}
			elif element.oclIsTypeOf(ControlFlow)  then
				return switch {
					case (self.type='Name') 'ControlFlow_NameLabel';		
					case (self.type = 'NameLabel') 'ControlFlow_NameLabel';
					case (self.type = 'KindLabel') 'ControlFlow_StereotypeLabel';
				}
		endif
	} endif;
}


query View::getEdgeType(element : Element) : String {
	return
		if self.type = 'Reference' then '' /* Constraint/Comment links handled separately */
		elif element.oclIsTypeOf(ObjectFlow) then 'ObjectFlow_Edge'
		elif element.oclIsTypeOf(ControlFlow) then 'ControlFlow_Edge'
		elif element.oclIsTypeOf(ExceptionHandler) then 'ExceptionHandler_Edge'
		else self.fail()
	endif;
}

