/*****************************************************************************
 * Copyright (c) 2013, 2016 CEA LIST, Christian W. Damus, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Camille Letavernier (CEA LIST) camille.letavernier@cea.fr - Initial API and implementation
 *  Christian W. Damus - bug 465656
 *****************************************************************************/
import RSAToPapyrus;

modeltype notation "strict" uses 'http://www.eclipse.org/gmf/runtime/1.0.2/notation';
modeltype umlNotation "strict" uses 'http://www.eclipse.org/papyrus/umlnotation';
modeltype uml "strict" uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype sash "strict" uses 'http://www.eclipse.org/papyrus/0.7.0/sashdi';
modeltype config "strict" uses 'http:///RSAToPapyrusParameters.ecore';

transformation RSASequenceDiagram(inout semantics : uml, inout graphics : notation, out di : sash, in param : config);

main() {
	semantics.rootObjects()[uml::Element]->map toOwnedDiagrams();
}

query View::getDiagramType() : String{
	return 'PapyrusUMLSequenceDiagram';
}

mapping notation::Diagram::generateDiagram() : notation::Diagram inherits Diagram::toPapyrusDiagram when {
	self.type = 'Sequence'
}{
	end {
		graphics.objectsOfType(Shape)->select(type = 'BehaviorExecutionSpecification_Shape').map fixExecutionSpecification();
		graphics.objectsOfType(Shape)->select(type = 'Lifeline_Shape').map fixLifelineHeight();
		graphics.objectsOfType(Shape)->select(type = 'StateInvariant_Shape').map fixStateInvariant();
		
		graphics.objectsOfType(Shape)->select(type = 'Comment_Shape').map addCommentDecoration();
		graphics.objectsOfType(Shape)->select(type = 'Constraint_Shape').map addConstraintDecoration();
	}
}

mapping inout Shape::addCommentDecoration() when {
	self.type = 'Comment_Shape' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := 'Comment_BodyLabel'; //Comment body
	}	

}

mapping inout Shape::addConstraintDecoration() when {
	self.type = 'Constraint_Shape' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := 'Constraint_BodyLabel'; //Constraint specification
	}	

}

mapping inout Shape::fixLifelineHeight() {
	self.layoutConstraint.oclAsType(Location).y := 10;
}

mapping inout Shape::fixExecutionSpecification() {
	self.children := self.children->including(object DecorationNode {
		type := 'BehaviorExecutionSpecification_Behavior';
		layoutConstraint := object Location {
			x := 18;
			y := 18;
		}
	});
	
	var lifeline := semantics.objectsOfType(Lifeline)->any(ll | ll.coveredBy->includes(self.element.oclAsType(InteractionFragment)));
	var lifelineShape := graphics.objectsOfType(Shape)->any(element = lifeline.oclAsType(EObject));
	lifelineShape.children := lifelineShape.children->including(self);
	var lifelineWidth := lifelineShape.layoutConstraint.oclAsType(Bounds).width;
	
	var speficationBounds := self.layoutConstraint.oclAsType(Bounds);
	speficationBounds.x := ((lifelineWidth - 15)/2).round();
	
	/* Cannot be selected in Papyrus when it is too small */
	var minHeight := 50;
	if speficationBounds.height < minHeight then
		speficationBounds.height := minHeight
	endif;
}

mapping inout Shape::fixStateInvariant() {
	
	var lifeline := semantics.objectsOfType(Lifeline)->any(ll | ll.coveredBy->includes(self.element.oclAsType(StateInvariant)));
	var lifelineShape := graphics.objectsOfType(Shape)->any(element = lifeline.oclAsType(EObject));
	
	lifelineShape.children := lifelineShape.children->including(self);
}

mapping Node::toNode() : Node disjuncts
	UMLShape::toPapyrusShape,
	UMLShapeCompartment::toStructureCompartment,
	BasicSemanticCompartment::toListCompartment,
	BasicDecorationNode::toConnectorLabel,
	BasicDecorationNode::toLabel
	//TODO: Disjunct nodes mapping
;

mapping Edge::toEdge() : Edge disjuncts
	UMLConnector::toPapyrusConnector
	//TODO: Disjunct edges mapping
;

mapping UMLShapeCompartment::toStructureCompartment() : DecorationNode inherits UMLShapeCompartment::toAbstractStructureCompartment when {
	(self.type = 'StructureCompartment' or 
	self.type = 'PackageContents' or
	self.type = 'interaction_compartment' or
	self.type.oclIsUndefined() or self.type = '')
	and not self.getType().oclIsUndefined();
}{
	
}


/***** Nodes **********/

mapping UMLShape::toPapyrusShape() : Shape inherits Shape::toPapyrusShape when {
	self.type = '' and not self.getType().oclIsUndefined() and (
		self.element.oclIsTypeOf(ActionExecutionSpecification)or
		self.element.oclIsTypeOf(BehaviorExecutionSpecification)or
		self.element.oclIsTypeOf(TimeObservation)or
		self.element.oclIsTypeOf(InteractionUse)or
		self.element.oclIsTypeOf(CombinedFragment)or
		self.element.oclIsTypeOf(Comment)or
		self.element.oclIsTypeOf(Lifeline)or
		self.element.oclIsTypeOf(InteractionOperand)or
		self.element.oclIsTypeOf(TimeConstraint)or
		self.element.oclIsTypeOf(StateInvariant)or
		self.element.oclIsTypeOf(CombinedFragment)or
		self.element.oclIsTypeOf(Continuation)or
		self.element.oclIsTypeOf(Interaction)or
		self.element.oclIsTypeOf(Constraint)or
		self.element.oclIsTypeOf(DurationConstraint)or
		self.element.oclIsTypeOf(DurationObservation)or
		self.element.oclIsTypeOf(ConsiderIgnoreFragment)or
		self.element.oclIsTypeOf(DurationConstraint)or
		self.element.oclIsTypeOf(DestructionOccurrenceSpecification)
		
	)
}{}


/****** Connector Labels ******/

mapping BasicDecorationNode::toConnectorLabel() : DecorationNode inherits Node::toPapyrusConnectorLabel when {
	not self.getType().oclIsUndefined() and (
		self.type = 'ToMultiplicityLabel' or
		self.type = 'ToRoleLabel' or
		self.type = 'FromMultiplicityLabel' or
		self.type = 'FromRoleLabel' or
		self.type = 'NameLabel' or
		self.type = 'KindLabel'
	)
}{
	
}

/****** Compartments *******/

mapping BasicDecorationNode::toLabel() : DecorationNode inherits Node::toPapyrusNode when {
	not self.getType().oclIsUndefined() and
	self.element.oclIsKindOf(uml::NamedElement) and 
	self.type = 'Name'
}{
	
}

mapping BasicSemanticCompartment::toListCompartment() : BasicCompartment inherits Node::toPapyrusNode, DrawerStyle::toDrawerStyle when {
	self.type.endsWith('Compartment') and not self.getType().oclIsUndefined()
}{
	result.children := self.findElement().map toContents(self);
}

mapping Element::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	CombinedFragment::toContents
;

mapping CombinedFragment::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	CombinedFragment::toCombinedFragmentCompartmentContents
;

mapping CombinedFragment::toCombinedFragmentCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'Compartment';
}{

}







/******* Edges ********/


mapping UMLConnector::toPapyrusConnector() : Connector inherits Connector::toPapyrusConnector when {
	self.type = '' and 
	not self.getType().oclIsUndefined() and (
		self.element.oclIsTypeOf(Message)or
		self.element.oclIsTypeOf(Message)or
		self.element.oclIsTypeOf(Message)or
		self.element.oclIsTypeOf(Message)or
		self.element.oclIsTypeOf(Message)or
		self.element.oclIsTypeOf(Message)or
		self.element.oclIsTypeOf(Message)or
		self.element.oclIsTypeOf(GeneralOrdering)
	)
}{
	result.styles := self.map toFontStyle();
}

/****** Element Type queries ******/

query View::getNodeType(element : Element) : String {
	return
		if element.oclIsTypeOf(TimeObservation) then 'TimeObservation_Shape' 
		elif element.oclIsTypeOf(InteractionUse) then 'InteractionUse_Shape' 
		elif element.oclIsTypeOf(CombinedFragment) then 'CombinedFragment_Shape' 
		elif element.oclIsTypeOf(CombinedFragment) then 'CombinedFragment_CoRegionShape' 
		elif element.oclIsTypeOf(Comment) then 'Comment_Shape' 
		elif element.oclIsTypeOf(Lifeline) then 'Lifeline_Shape' 
		elif element.oclIsTypeOf(InteractionOperand) then 'InteractionOperand_Shape' 
		elif element.oclIsTypeOf(TimeConstraint) then 'TimeConstraint_Shape' 
		elif element.oclIsTypeOf(StateInvariant) then 'StateInvariant_Shape' 
		elif element.oclIsTypeOf(Continuation) then 'Continuation_Shape' 
		elif element.oclIsTypeOf(Interaction) then 'Interaction_Shape' 
		elif element.oclIsTypeOf(Constraint) then 'Constraint_Shape' 
		elif element.oclIsTypeOf(DurationConstraint) then 'DurationConstraint_Shape' 
		elif element.oclIsTypeOf(DurationObservation) then 'DurationObservation_Shape' 
		elif element.oclIsTypeOf(ConsiderIgnoreFragment) then 'ConsiderIgnoreFragment_Shape' 
		elif element.oclIsTypeOf(ActionExecutionSpecification) then 'ActionExecutionSpecification_Shape' 
		elif element.oclIsTypeOf(DurationConstraint) then 'DurationConstraint_Shape_CN' 
		elif element.oclIsTypeOf(DestructionOccurrenceSpecification) then 'DestructionOccurrenceSpecification_Shape' 
		elif element.oclIsTypeOf(BehaviorExecutionSpecification) then 'BehaviorExecutionSpecification_Shape' 
		else self.fail()
	endif;
}


query View::getDecorationType(element : Element) : String{
	var res := self.doGetDecorationType(element);
	
	/*log('Get papyrus ID for'+ self.element.eClass().name+', '+self.type);
	
	log(res);
	
	if self.container().oclIsKindOf(Node) then 
		log('IsNode')
	else 
		log('IsEdge')
	endif;*/
	
	return res;
	
}

query View::doGetDecorationType(element : Element) : String{
	return if self.container().oclIsKindOf(Node) then {
		return if element.oclIsTypeOf(InteractionUse) then
				return switch {
					case (self.type = 'Name') 'InteractionUse_NameLabel';
					
				}
			elif element.oclIsTypeOf(Lifeline) then
				return switch {
					case (self.type = 'Name') 'Lifeline_NameLabel';
					
				}
			elif element.oclIsTypeOf(StateInvariant) then
				return switch {
					case (self.type = 'Name') 'StateInvariant_NameLabel';
					
				}
			elif element.oclIsTypeOf(InteractionOperand) then
				return switch {
					
					case (self.type.oclIsUndefined() or self.type = '') 'CombinedFragment_SubfragmentCompartment';
				}
			elif element.oclIsTypeOf(Continuation) then
				return switch {
					case (self.type = 'Name') 'Continuation_NameLabel';
					
				}
			elif element.oclIsTypeOf(Interaction) then
				return switch {
					case (self.type = 'Name') 'Interaction_NameLabel';
					case (self.type = 'interaction_compartment') 'Interaction_SubfragmentCompartment';
				}
			elif element.oclIsTypeOf(Constraint) then
				return switch {
					case (self.type = 'Name') 'Constraint_NameLabel';
					
				}
		endif
	} else {
		return if element.oclIsTypeOf(Message) and (element.oclIsKindOf(uml::InteractionFragment)) and (element.oclIsKindOf(uml::InteractionFragment) or element.oclIsKindOf(uml::Lifeline)) then
			return switch {
				case (self.type='Name') 'Message_SynchNameLabel';		
				case (self.type = 'NameLabel') 'Message_SynchNameLabel';
				case (self.type = 'KindLabel') 'Message_SynchStereotypeLabel';
			}
		
			elif element.oclIsTypeOf(Message) and ((element.oclIsKindOf(uml::Lifeline) or element.oclIsKindOf(uml::InteractionFragment) or element.oclIsKindOf(uml::Gate))) and true then
				return switch {
							
					case (self.type = 'NameLabel') 'Message_AsynchNameLabel';
					case (self.type = 'KindLabel') 'Message_AsynchStereotypeLabel';
				}
			
			elif element.oclIsTypeOf(Message) and (element.oclIsKindOf(uml::InteractionFragment)) and ((element.oclIsKindOf(uml::Lifeline) or element.oclIsKindOf(uml::InteractionFragment) or element.oclIsKindOf(uml::Gate))) then
				return switch {
							
					case (self.type = 'NameLabel') 'Message_ReplyNameLabel';
					case (self.type = 'KindLabel') 'Message_ReplyStereotypeLabel';
				}
			
			elif element.oclIsTypeOf(Message) and (element.oclIsKindOf(uml::InteractionFragment) or element.oclIsKindOf(uml::Lifeline)) and (element.oclIsKindOf(uml::Lifeline)) then
				return switch {
							
					case (self.type = 'NameLabel') 'Message_CreateNameLabel';
					case (self.type = 'KindLabel') 'Message_CreateStereotypeLabel';
				}
			
			elif element.oclIsTypeOf(Message) and (element.oclIsKindOf(uml::InteractionFragment) or element.oclIsKindOf(uml::Lifeline)) and (element.oclIsKindOf(uml::DestructionOccurrenceSpecification) or element.oclIsKindOf(uml::Lifeline)) then
				return switch {
							
					case (self.type = 'NameLabel') 'Message_DeleteNameLabel';
					case (self.type = 'KindLabel') 'Message_DeleteStereotypeLabel';
				}
			
			elif element.oclIsTypeOf(Message) and ((element.oclIsKindOf(uml::Lifeline) or element.oclIsKindOf(uml::InteractionFragment) or element.oclIsKindOf(uml::Gate))) and (element.oclIsKindOf(uml::Interaction)) then
				return switch {
							
					case (self.type = 'NameLabel') 'Message_LostNameLabel';
					case (self.type = 'KindLabel') 'Message_LostStereotypeLabel';
				}
			
			elif element.oclIsTypeOf(Message) and (element.oclIsKindOf(uml::Interaction)) and ((element.oclIsKindOf(uml::Lifeline) or element.oclIsKindOf(uml::InteractionFragment) or element.oclIsKindOf(uml::Gate))) then
				return switch {
							
					case (self.type = 'NameLabel') 'Message_FoundNameLabel';
					case (self.type = 'KindLabel') 'Message_FoundStereotypeLabel';
				}
			
			elif element.oclIsTypeOf(GeneralOrdering)  then
				return switch {
							
					case (self.type = 'KindLabel') 'GeneralOrdering_StereotypeLabel';
				}
			
		endif
	} endif;
}


query View::getEdgeType(element : Element) : String {
	return
		if element.oclIsTypeOf(Message) then 'Message_SynchEdge'
		elif element.oclIsTypeOf(Message) then 'Message_AsynchEdge'
		elif element.oclIsTypeOf(Message) then 'Message_ReplyEdge'
		elif element.oclIsTypeOf(Message) then 'Message_CreateEdge'
		elif element.oclIsTypeOf(Message) then 'Message_DeleteEdge'
		elif element.oclIsTypeOf(Message) then 'Message_LostEdge'
		elif element.oclIsTypeOf(Message) then 'Message_FoundEdge'
		elif element.oclIsTypeOf(GeneralOrdering) then 'GeneralOrdering_Edge'
		else self.fail()
	endif;
}

