/*****************************************************************************
 * Copyright (c) 2013, 2016 CEA LIST, Christian W. Damus, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Camille Letavernier (CEA LIST) camille.letavernier@cea.fr - Initial API and implementation
 *  Christian W. Damus - bug 465656
 *****************************************************************************/
import RSAToPapyrus;
import org.eclipse.papyrus.m2m.qvto.Properties;

modeltype notation "strict" uses 'http://www.eclipse.org/gmf/runtime/1.0.2/notation';
modeltype umlNotation "strict" uses 'http://www.eclipse.org/papyrus/umlnotation';
modeltype uml "strict" uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype sash "strict" uses 'http://www.eclipse.org/papyrus/0.7.0/sashdi';
modeltype vpconfig "strict" uses 'http://www.eclipse.org/papyrus/infra/viewpoints/configuration';
modeltype vpstyle "strict" uses 'http://www.eclipse.org/papyrus/infra/viewpoints/policy/style';
modeltype config "strict" uses 'http:///RSAToPapyrusParameters.ecore';

transformation RSAClassDiagram(inout semantics : uml, inout graphics : notation, out di : sash, in param : config);

main() {
	semantics.rootObjects()[uml::Element]->map toOwnedDiagrams();
}

query View::getDiagramType() : String{
	return 'PapyrusUMLClassDiagram';
}



mapping notation::Diagram::generateDiagram() : notation::Diagram inherits Diagram::toPapyrusDiagram when {
	(self.type = 'Class' or self.type='Object') and not self.findElement().oclIsTypeOf(Profile)
}{

	end {
	
		/* Post action: Move AssociationClasses to the right parent (Dashed Edge + Node) */
		/* Easier to do in post-treatment than during the transformation (The transformation can remain generic) */
		result.map handleAssociationClasses();
		graphics.objectsOfType(Shape)->select(type = 'Comment_Shape').map addCommentDecoration();
		graphics.objectsOfType(Shape)->select(type = 'Constraint_PackagedElementShape').map addConstraintDecoration();
		if not result.element.oclIsKindOf(Package) then
			result.map toInnerClassDiagram()
		endif;
	}
}

mapping inout Diagram::toInnerClassDiagram() : PapyrusViewStyle{
	result.owner := self.element;
	result._configuration := getInnerClassDiagramView();
	
	self.styles += result;
}

query getInnerClassDiagramView() : PapyrusDiagram {
	return getEObjectProperty('InnerClassDiagramView').oclAsType(PapyrusDiagram);
}

mapping inout Shape::addCommentDecoration() when {
	self.type = 'Comment_Shape' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := 'Comment_BodyLabel'; //Comment body
	}	

}

mapping inout Shape::addConstraintDecoration() when {
	self.type = 'Constraint_PackagedElementShape' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := 'Constraint_BodyLabel'; //Constraint specification
	}	

}

mapping inout Diagram::handleAssociationClasses() {
	graphics.objectsOfType(Shape)->select(type = 'AssociationClass_Shape').map updateLocation();

	self.children := self.children->union(graphics.objectsOfKind(Node)->select(diagram = self and type = 'AssociationClass_Shape'));
}

mapping inout Shape::updateLocation() {
	var dashedEdge := graphics.objectsOfType(Connector)->select(type = 'AssociationClass_TetherEdge' and source = self or target = self)->any(true);
	
	var association := dashedEdge.findConnector();
	
	var source := association.source.oclAsType(Shape);
	var target := association.target.oclAsType(Shape); 
	
	var sourcePosition := source.getBounds();
	var targetPosition := target.getBounds();
	
	var bounds := self.getBounds();
	
	bounds.x := (((sourcePosition.x + targetPosition.x)/2) + bounds.x).round(); 
	bounds.y := (((sourcePosition.y + targetPosition.y)/2) + bounds.y).round();
}
	
/**
*	From the Dashed edge of an Association Class, returns the actual Association connector
*/
query Connector::findConnector() : Connector {
	var view := if self.source.oclIsKindOf(Connector) then self.source else self.target endif;
	return view.oclAsType(Connector);
}

query Shape::getBounds() : Bounds {
	return self.oclAsType(Shape).layoutConstraint.oclAsType(Bounds);
}

/**
*	In Papyrus, an AssociationClass is composed of two edges and a Node (Full edge for association, dashed edge for Association class, Node for the class)
*	In RSA, an AssociationClass is a single Edge with compartments
*/
mapping UMLConnector::toAssociationClass() : Connector inherits Connector::toPapyrusConnector when {
	self.element.oclIsTypeOf(AssociationClass)
}{
	result.styles := self.map toFontStyle();
	var dashedEdge := object Connector {
		type := 'AssociationClass_TetherEdge';
		target := self.children->selectByKind(UMLShape)->any(true).map toPapyrusShape();
		source := result;
		styles := object FontStyle{};
		bendpoints := object RelativeBendpoints{};
		sourceAnchor := object IdentityAnchor{};
		targetAnchor := object IdentityAnchor{};
	};
	
	var targetDiagram := self.diagram.map generateDiagram();
	targetDiagram.edges += dashedEdge;
}


mapping Node::toNode() : Node disjuncts
	UMLShape::toPapyrusShape,
	UMLShapeCompartment::toStructureCompartment,
	BasicSemanticCompartment::toListCompartment,
	ListCompartment::toListCompartment,
	BasicDecorationNode::toConnectorLabel,
	BasicDecorationNode::toLabel
	//TODO: Disjunct nodes mapping
;

mapping Edge::toEdge() : Edge disjuncts
	UMLConnector::toCommentLink,
	UMLConnector::toConstraintLink,
	/*UMLConnector::toContextLink,*/
	UMLConnector::toPapyrusConnector,
	UMLConnector::toGeneralizationConnector,
	UMLConnector::toAssociationClass
;

mapping UMLShapeCompartment::toStructureCompartment() : DecorationNode inherits UMLShapeCompartment::toAbstractStructureCompartment when {
	self.type = 'StructureCompartment' or self.type = 'PackageContents' and not self.getType().oclIsUndefined();
}{
	
}


/***** Nodes **********/

mapping UMLShape::toPapyrusShape() : Shape inherits Shape::toPapyrusShape when {
	self.type = '' and (
		self.element.oclIsTypeOf(Dependency)or
	self.element.oclIsTypeOf(AssociationClass)or
	self.element.oclIsTypeOf(Association)or
	self.element.oclIsTypeOf(InstanceSpecification)or
	self.element.oclIsTypeOf(Component)or
	self.element.oclIsTypeOf(Signal)or
	self.element.oclIsTypeOf(Interface)or
	self.element.oclIsTypeOf(Model)or
	self.element.oclIsTypeOf(Enumeration)or
	self.element.oclIsTypeOf(Package)or
	self.element.oclIsTypeOf(InformationItem)or
	self.element.oclIsTypeOf(Class)or
	self.element.oclIsTypeOf(PrimitiveType)or
	self.element.oclIsTypeOf(DataType)or
	self.element.oclIsTypeOf(Constraint)or
	self.element.oclIsTypeOf(Comment)or
	self.element.oclIsTypeOf(Diagram)or
	self.element.oclIsTypeOf(DurationObservation)or
	self.element.oclIsTypeOf(TimeObservation)or
	self.element.oclIsKindOf(NamedElement)
	)
}{
	
}


/****** Connector Labels ******/

mapping BasicDecorationNode::toConnectorLabel() : DecorationNode inherits Node::toPapyrusConnectorLabel when {
	not self.getType().oclIsUndefined() and (
		self.type = 'ToMultiplicityLabel' or
		self.type = 'ToRoleLabel' or
		self.type = 'FromMultiplicityLabel' or
		self.type = 'FromRoleLabel' or
		self.type = 'NameLabel' or
		self.type = 'KindLabel'
	)
}{
	
}

/****** Compartments *******/

mapping BasicDecorationNode::toLabel() : DecorationNode inherits Node::toPapyrusNode when {
	self.element.oclIsKindOf(uml::NamedElement) and 
	self.type = 'Name'
}{
	
}

//Synchronized Compartments
mapping BasicSemanticCompartment::toListCompartment() : BasicCompartment inherits Node::toPapyrusNode, DrawerStyle::toDrawerStyle when {
	//TODO: EndsWith('Compartment')
	self.type = 'OperationCompartment' or
	self.type = 'SignalCompartment' or
	self.type = 'AttributeCompartment' or
	self.type.endsWith('Compartment')
}{
	result.children += self.findElement().map toContents(self);
}

//Standard Compartments (e.g. slots)
mapping ListCompartment::toListCompartment() : BasicCompartment inherits Node::toPapyrusNode, DrawerStyle::toDrawerStyle when {
	self.type.endsWith('Compartment')
} {
	//Super class implementation is sufficient. It will already transform the children and set the compartment ID
	result.children += self.findElement().map toContents(self);
}

mapping Element::toContents(node : ListCompartment) : Sequence(Node) disjuncts 
	InstanceSpecification::toContents
;

mapping Element::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	AssociationClass::toContents,
	Component::toContents,
	Signal::toContents,
	Interface::toContents,
	Enumeration::toContents,
	Class::toContents,
	PrimitiveType::toContents,
	DataType::toContents
;

mapping AssociationClass::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	AssociationClass::toAttributeCompartmentContents,
	AssociationClass::toOperationCompartmentContents,
	AssociationClass::toNestedClassifierCompartmentContents
;

mapping InstanceSpecification::toContents(node : ListCompartment) : Sequence(Node) disjuncts
	InstanceSpecification::toSlotCompartmentContents
;

mapping Component::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Component::toAttributeCompartmentContents,
	Component::toOperationCompartmentContents,
	Component::toNestedClassifierCompartmentContents
;

mapping Signal::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Signal::toAttributeCompartmentContents
;

mapping Interface::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Interface::toAttributeCompartmentContents,
	Interface::toOperationCompartmentContents,
	Interface::toNestedClassifierCompartmentContents
;

mapping Enumeration::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Enumeration::toEnumerationLiteralCompartmentContents
;

mapping Class::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Class::toAttributeCompartmentContents,
	Class::toOperationCompartmentContents,
	Class::toNestedClassifierCompartmentContents
;

mapping PrimitiveType::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	PrimitiveType::toAttributeCompartmentContents,
	PrimitiveType::toOperationCompartmentContents
;

mapping DataType::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	DataType::toAttributeCompartmentContents,
	DataType::toOperationCompartmentContents
;

mapping AssociationClass::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping AssociationClass::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	}
}

mapping AssociationClass::toNestedClassifierCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'SignalCompartment';
}{
	init {
		result := (self.map fillClass(node))
	}
}

mapping InstanceSpecification::toSlotCompartmentContents(node : ListCompartment) : Sequence(Node) when {
	node.type = 'SlotCompartment';
}{
	init {
		result := (self.map fillSlot(node))
	}
}

mapping Component::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping Component::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	->union(self.map fillReception(node))
	}
}

mapping Component::toNestedClassifierCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'SignalCompartment';
}{
	init {
		result := (self.map fillClass(node))
	->union(self.map fillInterface(node))
	->union(self.map fillEnumeration(node))
	->union(self.map fillPrimitiveType(node))
	->union(self.map fillDataType(node))
	->union(self.map fillSignal(node))
	}
}

mapping Signal::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping Interface::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping Interface::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	->union(self.map fillReception(node))
	}
}

mapping Interface::toNestedClassifierCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'SignalCompartment';
}{
	init {
		result := (self.map fillClass(node))
	->union(self.map fillInterface(node))
	->union(self.map fillEnumeration(node))
	->union(self.map fillPrimitiveType(node))
	->union(self.map fillDataType(node))
	->union(self.map fillSignal(node))
	}
}

mapping Enumeration::toEnumerationLiteralCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'EnumerationCompartment';
}{
	init {
		result := (self.map fillEnumerationLiteral(node))
	}
}

mapping Class::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping Class::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillReception(node))
	->union(self.map fillOperation(node))
	}
}

mapping Class::toNestedClassifierCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'SignalCompartment';
}{
	init {
		result := (self.map fillClass(node))
	->union(self.map fillInterface(node))
	->union(self.map fillEnumeration(node))
	->union(self.map fillPrimitiveType(node))
	->union(self.map fillDataType(node))
	->union(self.map fillSignal(node))
	}
}

mapping PrimitiveType::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping PrimitiveType::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	}
}

mapping DataType::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping DataType::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'OperationCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	}
}

mapping uml::Class::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInClass(node)->asSequence();
	}
}

mapping uml::Component::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInComponent(node)->asSequence();
	}
}

mapping uml::Signal::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInSignal(node)->asSequence();
	}
}

mapping uml::Interface::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInInterface(node)->asSequence();
	}
}

mapping uml::PrimitiveType::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInPrimitiveType(node)->asSequence();
	}
}

mapping uml::DataType::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property)->select(association.oclIsUndefined()).map toPropertyInDataType(node)->asSequence();
	}
}

mapping uml::Class::fillClass(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Class).map toClassInClass(node)->asSequence();
	}
}

mapping uml::Component::fillClass(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Class).map toClassInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillClass(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Class).map toClassInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInClass(node)->asSequence();
	}
}

mapping uml::Component::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInInterface(node)->asSequence();
	}
}

mapping uml::PrimitiveType::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInPrimitiveType(node)->asSequence();
	}
}

mapping uml::DataType::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInDataType(node)->asSequence();
	}
}

mapping uml::RedefinableTemplateSignature::fillConnectableElementTemplateParameter(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='TemplateParameterCompartment';
}{
	init {
		result := self.parameter->selectByKind(ConnectableElementTemplateParameter).map toConnectableElementTemplateParameterInRedefinableTemplateSignature(node)->asSequence();
	}
}

mapping uml::TemplateSignature::fillOperationTemplateParameter(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='TemplateParameterCompartment';
}{
	init {
		result := self.parameter->selectByKind(OperationTemplateParameter).map toOperationTemplateParameterInTemplateSignature(node)->asSequence();
	}
}

mapping uml::RedefinableTemplateSignature::fillClassifierTemplateParameter(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='TemplateParameterCompartment';
}{
	init {
		result := self.parameter->selectByKind(ClassifierTemplateParameter).map toClassifierTemplateParameterInRedefinableTemplateSignature(node)->asSequence();
	}
}

mapping uml::RedefinableTemplateSignature::fillTemplateParameter(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='TemplateParameterCompartment';
}{
	init {
		result := self.parameter->selectByKind(TemplateParameter).map toTemplateParameterInRedefinableTemplateSignature(node)->asSequence();
	}
}

mapping uml::Enumeration::fillEnumerationLiteral(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='EnumerationCompartment';
}{
	init {
		result := self.ownedLiteral->selectByKind(EnumerationLiteral).map toEnumerationLiteralInEnumeration(node)->asSequence();
	}
}

mapping uml::Class::fillReception(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedReception->selectByKind(Reception).map toReceptionInClass(node)->asSequence();
	}
}

mapping uml::Interface::fillReception(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='OperationCompartment';
}{
	init {
		result := self.ownedReception->selectByKind(Reception).map toReceptionInInterface(node)->asSequence();
	}
}

mapping uml::InstanceSpecification::fillSlot(node : ListCompartment) : Sequence(Node) when {
	node.type='SlotCompartment';
}{
	init {
		result := self.slot->selectByKind(Slot).map toSlotInInstanceSpecification(node)->asSequence();
	}
}

mapping uml::Class::fillInterface(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Interface).map toInterfaceInClass(node)->asSequence();
	}
}

mapping uml::Component::fillInterface(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Interface).map toInterfaceInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillInterface(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Interface).map toInterfaceInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillEnumeration(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Enumeration).map toEnumerationInClass(node)->asSequence();
	}
}

mapping uml::Component::fillEnumeration(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Enumeration).map toEnumerationInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillEnumeration(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Enumeration).map toEnumerationInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillPrimitiveType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(PrimitiveType).map toPrimitiveTypeInClass(node)->asSequence();
	}
}

mapping uml::Component::fillPrimitiveType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(PrimitiveType).map toPrimitiveTypeInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillPrimitiveType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(PrimitiveType).map toPrimitiveTypeInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillDataType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(DataType).map toDataTypeInClass(node)->asSequence();
	}
}

mapping uml::Component::fillDataType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(DataType).map toDataTypeInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillDataType(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(DataType).map toDataTypeInInterface(node)->asSequence();
	}
}

mapping uml::Class::fillSignal(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Signal).map toSignalInClass(node)->asSequence();
	}
}

mapping uml::Component::fillSignal(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Signal).map toSignalInComponent(node)->asSequence();
	}
}

mapping uml::Interface::fillSignal(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='SignalCompartment';
}{
	init {
		result := self.nestedClassifier->selectByKind(Signal).map toSignalInInterface(node)->asSequence();
	}
}

mapping Property::toPropertyInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Property_ClassAttributeLabel';
}

mapping Property::toPropertyInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Property_ComponentAttributeLabel';
}

mapping Property::toPropertyInSignal(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Property_SignalAttributeLabel';
}

mapping Property::toPropertyInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Property_InterfaceAttributeLabel';
}

mapping Property::toPropertyInPrimitiveType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Property_PrimitiveTypeAttributeLabel';
}

mapping Property::toPropertyInDataType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Property_DataTypeAttributeLabel';
}

mapping Class::toClassInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Class_ClassNestedClassifierLabel';
}

mapping Class::toClassInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Class_ComponentNestedClassifierLabel';
}

mapping Class::toClassInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Class_InterfaceNestedClassifierLabel';
}

mapping Operation::toOperationInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Operation_ClassOperationLabel';
}

mapping Operation::toOperationInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Operation_ComponentOperationLabel';
}

mapping Operation::toOperationInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Operation_InterfaceOperationLabel';
}

mapping Operation::toOperationInPrimitiveType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Operation_PrimitiveTypeOperationLabel';
}

mapping Operation::toOperationInDataType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Operation_DataTypeOperationLabel';
}

mapping ConnectableElementTemplateParameter::toConnectableElementTemplateParameterInRedefinableTemplateSignature(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'ConnectableElementTemplateParameter_TemplateParameterLabel';
}

mapping OperationTemplateParameter::toOperationTemplateParameterInTemplateSignature(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'OperationTemplateParameter_TemplateParameterLabel';
}

mapping ClassifierTemplateParameter::toClassifierTemplateParameterInRedefinableTemplateSignature(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'ClassifierTemplateParameter_TemplateParameterLabel';
}

mapping TemplateParameter::toTemplateParameterInRedefinableTemplateSignature(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'TemplateParameter_TemplateParameterLabel';
}

mapping EnumerationLiteral::toEnumerationLiteralInEnumeration(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'EnumerationLiteral_LiteralLabel';
}

mapping Reception::toReceptionInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Reception_ReceptionLabel';
}

mapping Reception::toReceptionInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Reception_InterfaceReceptionLabel';
}

mapping Slot::toSlotInInstanceSpecification(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Slot_SlotLabel';
}

mapping Interface::toInterfaceInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Interface_ClassNestedClassifierLabel';
}

mapping Interface::toInterfaceInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Interface_ComponentNestedClassifierLabel';
}

mapping Interface::toInterfaceInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Interface_InterfaceNestedClassifierLabel';
}

mapping Enumeration::toEnumerationInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Enumeration_ClassNestedClassifierLabel';
}

mapping Enumeration::toEnumerationInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Enumeration_ComponentNestedClassifierLabel';
}

mapping Enumeration::toEnumerationInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Enumeration_InterfaceNestedClassifierLabel';
}

mapping PrimitiveType::toPrimitiveTypeInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'PrimitiveType_ClassNestedClassifierLabel';
}

mapping PrimitiveType::toPrimitiveTypeInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'PrimitiveType_ComponentNestedClassifierLabel';
}

mapping PrimitiveType::toPrimitiveTypeInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'PrimitiveType_InterfaceNestedClassifierLabel';
}

mapping DataType::toDataTypeInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'DataType_ClassNestedClassifierLabel';
}

mapping DataType::toDataTypeInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'DataType_ComponentNestedClassifierLabel';
}

mapping DataType::toDataTypeInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'DataType_InterfaceNestedClassifierLabel';
}

mapping Signal::toSignalInClass(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Signal_ClassNestedClassifierLabel';
}

mapping Signal::toSignalInComponent(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Signal_ComponentNestedClassifierLabel';
}

mapping Signal::toSignalInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Signal_InterfaceNestedClassifierLabel';
}



/******* Edges ********/


mapping UMLConnector::toPapyrusConnector() : Connector inherits Connector::toPapyrusConnector when {
	self.type = '' and (
		/*self.element.oclIsTypeOf(AssociationClass)or*/
		self.element.oclIsTypeOf(Association)or
		self.element.oclIsTypeOf(Association)or
		self.element.oclIsTypeOf(InterfaceRealization)or
		self.element.oclIsTypeOf(Substitution)or
		self.element.oclIsTypeOf(Realization)or
		self.element.oclIsTypeOf(Abstraction)or
		self.element.oclIsTypeOf(Usage)or
		self.element.oclIsTypeOf(Dependency)or
		self.element.oclIsTypeOf(Dependency)or
		self.element.oclIsTypeOf(ElementImport)or
		self.element.oclIsTypeOf(PackageImport)or
		self.element.oclIsTypeOf(PackageMerge)or
		self.element.oclIsTypeOf(ProfileApplication)or
		self.element.oclIsTypeOf(TemplateBinding)or
		self.element.oclIsTypeOf(GeneralizationSet)or
		self.element.oclIsTypeOf(InstanceSpecification)or
		self.element.oclIsTypeOf(InformationFlow)
		
	)
}{
	result.styles := self.map toFontStyle();
}

mapping UMLConnector::toGeneralizationConnector() : Connector inherits Connector::toPapyrusConnector when {
	self.type='' and self.element.oclIsTypeOf(Generalization)
}{
	result.children->forEach(element){
		element.type:='Generalization_StereotypeLabel'
	};
	result.styles := self.map toFontStyle();
	result.sourceAnchor := object IdentityAnchor{};
	result.targetAnchor := object IdentityAnchor{};
	
}

mapping UMLConnector::toCommentLink() : Connector inherits Connector::toCommentLink when{
	self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Comment) or 
	 	self.target.element.oclIsKindOf(Comment)
	)
}{
	result.type :='Comment_AnnotatedElementEdge';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
}

mapping UMLConnector::toConstraintLink() : Connector inherits Connector::toPapyrusConnector when{
	self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Constraint) or 
	 	self.target.element.oclIsKindOf(Constraint)
	)
}{	
	result.type :='Constraint_ConstrainedElementEdge';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
}


/* Context Links are not supported in RSA Class Diagrams */
/*
mapping UMLConnector::toContextLink() : Connector inherits Connector::toPapyrusConnector when{
		self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Constraint) or 
	 	self.target.element.oclIsKindOf(Constraint)
	)
}{	
	result.type :='Constraint_ContextEdge';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
	result.children += object DecorationNode {
		type := 'Constraint_KeywordLabel';
		layoutConstraint := object Location {
			y := 15;
		}
	}
}
*/

/****** Element Type queries ******/

query View::getNodeType(element : Element) : String {
	return
		if element.oclIsTypeOf(Dependency) then 'Dependency_Shape' 
		elif element.oclIsTypeOf(AssociationClass) then 'AssociationClass_Shape' 
		elif element.oclIsTypeOf(Association) then 'Association_Shape' 
		elif element.oclIsTypeOf(InstanceSpecification) then 'InstanceSpecification_Shape' 
		elif element.oclIsTypeOf(Component) then 'Component_Shape' 
		elif element.oclIsTypeOf(Signal) then 'Signal_Shape' 
		elif element.oclIsTypeOf(Interface) then 'Interface_Shape' 
		elif element.oclIsTypeOf(Model) then 'Model_Shape' 
		elif element.oclIsTypeOf(Enumeration) then 'Enumeration_Shape' 
		elif element.oclIsTypeOf(Package) then 'Package_Shape' 
		elif element.oclIsTypeOf(InformationItem) then 'InformationItem_Shape' 
		elif element.oclIsTypeOf(Class) then 'Class_Shape' 
		elif element.oclIsTypeOf(PrimitiveType) then 'PrimitiveType_Shape' 
		elif element.oclIsTypeOf(DataType) then 'DataType_Shape' 
		elif element.oclIsTypeOf(Constraint) then 'Constraint_PackagedElementShape' 
		elif element.oclIsTypeOf(Comment) then 'Comment_Shape' 
		elif element.oclIsTypeOf(Diagram) then 'Diagram_ShortcutShape' 
		elif element.oclIsTypeOf(DurationObservation) then 'DurationObservation_Shape' 
		elif element.oclIsTypeOf(TimeObservation) then 'TimeObservation_Shape' 
		elif element.oclIsKindOf(NamedElement) then 'NamedElement_DefaultShape'
		else self.fail()
	endif;
}


query View::getDecorationType(element : Element) : String{
	var res := self.doGetDecorationType(element);

	/*log('Get papyrus ID for'+ element.oclAsType(EObject).eClass().name+', '+self.type);
	
	log(res);
	
	if self.container().oclIsKindOf(Node) then 
		log('IsNode')
	else 
		log('IsEdge')
	endif;*/
	
	return res;	
}

query View::doGetDecorationType(element : Element) : String{
	
	return if self.container().oclIsKindOf(Node) then {
		return if element.oclIsKindOf(AssociationClass) then
			return switch {
				case (self.type = 'Name') 'AssociationClass_NameLabel';
				case (self.type = 'AttributeCompartment') 'AssociationClass_AttributeCompartment';
				case (self.type = 'OperationCompartment') 'AssociationClass_OperationCompartment';
				case (self.type = 'SignalCompartment') 'AssociationClass_NestedClassifierCompartment';
			}
		elif element.oclIsKindOf(InstanceSpecification) then
			return switch {
				case (self.type = 'Name') 'InstanceSpecification_NameLabel';
				case (self.type = 'SlotCompartment') 'InstanceSpecification_SlotCompartment';
			}
		elif element.oclIsKindOf(Component) then
			return switch {
				case (self.type = 'Name') 'Component_NameLabel';
				case (self.type = 'AttributeCompartment') 'Component_AttributeCompartment';
			case (self.type = 'OperationCompartment') 'Component_OperationCompartment';
			case (self.type = 'SignalCompartment') 'Component_NestedClassifierCompartment';
			}
		elif element.oclIsKindOf(Signal) then
			return switch {
				case (self.type = 'Name') 'Signal_NameLabel';
				case (self.type = 'AttributeCompartment') 'Signal_AttributeCompartment';
			}
		elif element.oclIsKindOf(Interface) then
			return switch {
				case (self.type = 'Name') 'Interface_NameLabel';
				case (self.type = 'AttributeCompartment') 'Interface_AttributeCompartment';
				case (self.type = 'OperationCompartment') 'Interface_OperationCompartment';
				case (self.type = 'SignalCompartment') 'Interface_NestedClassifierCompartment';
			}
		elif element.oclIsKindOf(Model) then
			return switch {
				case (self.type = 'Name') 'Model_NameLabel';
				case (self.type = 'PackageContents') 'Model_PackagedElementCompartment';
			}
		elif element.oclIsKindOf(Enumeration) then
			return switch {
				case (self.type = 'Name') 'Enumeration_NameLabel';
				case (self.type = 'EnumerationCompartment') 'Enumeration_LiteralCompartment';
			}
		elif element.oclIsKindOf(Package) then
			return switch {
				case (self.type = 'Name') 'Package_NameLabel';
				case (self.type = 'PackageContents') 'Package_PackagedElementCompartment';
			}
		elif element.oclIsKindOf(InformationItem) then
			return switch {
				case (self.type = 'Name') 'InformationItem_NameLabel';
				
			}
		elif element.oclIsKindOf(Class) then
			return switch {
				case (self.type = 'Name') 'Class_NameLabel';
				case (self.type = 'AttributeCompartment') 'Class_AttributeCompartment';
				case (self.type = 'OperationCompartment') 'Class_OperationCompartment';
				case (self.type = 'SignalCompartment') 'Class_NestedClassifierCompartment';
			}
		elif element.oclIsKindOf(PrimitiveType) then
			return switch {
				case (self.type = 'Name') 'PrimitiveType_NameLabel';
				case (self.type = 'AttributeCompartment') 'PrimitiveType_AttributeCompartment';
				case (self.type = 'OperationCompartment') 'PrimitiveType_OperationCompartment';
			}
		elif element.oclIsKindOf(DataType) then
			return switch {
				case (self.type = 'Name') 'DataType_NameLabel';
				case (self.type = 'AttributeCompartment') 'DataType_AttributeCompartment';
				case (self.type = 'OperationCompartment') 'DataType_OperationCompartment';
			}
		elif element.oclIsKindOf(Constraint) then
			return switch {
				case (self.type = 'Name') 'Constraint_NameLabel';
				
			}
		elif element.oclIsKindOf(Diagram) then
			return switch {
				case (self.type = 'Name') 'Diagram_NameLabel';
				
			}
		elif element.oclIsKindOf(DurationObservation) then
			return switch {
				case (self.type = 'Name') 'DurationObservation_FloatingNameLabel';
				
			}
		elif element.oclIsKindOf(TimeObservation) then
			return switch {
				case (self.type = 'Name') 'TimeObservation_FloatingNameLabel';
				
			}
		elif element.oclIsKindOf(NamedElement) then
			return switch {
				case (self.type = 'Name') 'NamedElement_NameLabel';
			}
		endif
	} else {
		return if element.oclIsKindOf(Association) then
			return switch {
				case (self.type='Name') 'Association_NameLabel';		
				case (self.type = 'KindLabel') 'Association_StereotypeLabel';
				case (self.type = 'NameLabel') 'Association_NameLabel';
			}
		elif element.oclIsKindOf(Property) then 
			return if element.oclAsType(Property).association.oclIsTypeOf(Association) then
				return switch {
					case (self.type = 'ToRoleLabel') 'Association_TargetRoleLabel';
				
					case (self.type = 'FromRoleLabel') 'Association_SourceRoleLabel';
					
					case (self.type = 'FromMultiplicityLabel') 'Association_SourceMultiplicityLabel';
					
					case (self.type = 'ToMultiplicityLabel') 'Association_TargetMultiplicityLabel';
				}
			elif element.oclAsType(Property).association.oclIsTypeOf(AssociationClass) then
				return switch {
					case (self.type = 'ToRoleLabel') 'AssociationClass_TargetRoleLabel';
					case (self.type = 'FromRoleLabel') 'AssociationClass_SourceRoleLabel';
				}
			endif
		elif element.oclIsKindOf(Generalization) then
			return switch {
						
				case (self.type = 'KindLabel') 'Generalization_StereotypeLabel';
			}
		
		elif element.oclIsKindOf(InterfaceRealization) then
			return switch {
				case (self.type='Name') 'InterfaceRealization_NameLabel';		
				case (self.type = 'KindLabel') 'InterfaceRealization_StereotypeLabel';
				case (self.type = 'NameLabel') 'InterfaceRealization_NameLabel';
			}
		
		elif element.oclIsKindOf(Substitution) then
			return switch {
				case (self.type='Name') 'Substitution_NameLabel';		
				case (self.type = 'KindLabel') 'Substitution_StereotypeLabel';
				case (self.type = 'NameLabel') 'Substitution_NameLabel';
			}
		
		elif element.oclIsKindOf(Realization) then
			return switch {
				case (self.type='Name') 'Realization_NameLabel';		
				case (self.type = 'KindLabel') 'Realization_StereotypeLabel';
				case (self.type = 'NameLabel') 'Realization_NameLabel';
			}
		
		elif element.oclIsKindOf(Abstraction) then
			return switch {
				case (self.type='Name') 'Abstraction_NameLabel';		
				case (self.type = 'NameLabel') 'Abstraction_NameLabel';
				case (self.type = 'KindLabel') 'Abstraction_StereotypeLabel';
			}
		
		elif element.oclIsKindOf(Usage) then
			return switch {
				case (self.type='Name') 'Usage_NameLabel';		
				case (self.type = 'NameLabel') 'Usage_NameLabel';
				case (self.type = 'KindLabel') 'Usage_StereotypeLabel';
			}
		
		elif element.oclIsKindOf(Dependency) then
			return switch {
				case (self.type='Name') 'Dependency_NameLabel';		
				case (self.type = 'NameLabel') 'Dependency_NameLabel';
				case (self.type = 'KindLabel') 'Dependency_StereotypeLabel';
			}

		elif element.oclIsKindOf(ElementImport) then
			return switch {
						
				
				case (self.type = 'KindLabel') 'ElementImport_StereotypeLabel';
			}
		
		elif element.oclIsKindOf(PackageImport) then
			return switch {
						
				case (self.type = 'KindLabel') 'PackageImport_StereotypeLabel';
			}
		
		elif element.oclIsKindOf(PackageMerge) then
			return switch {
						
				case (self.type = 'KindLabel') 'PackageMerge_StereotypeLabel';
			}
		
		elif element.oclIsKindOf(TemplateBinding) then
			return switch {
						
				
				case (self.type = 'KindLabel') 'TemplateBinding_StereotypeLabel';
			}
		
		elif element.oclIsKindOf(GeneralizationSet) then
			return switch {
						
				
				case (self.type = 'KindLabel') 'GeneralizationSet_StereotypeLabel';
			}

		elif element.oclIsKindOf(InformationFlow) then
			return switch {
						
				
				case (self.type = 'KindLabel') 'InformationFlow_StereotypeLabel';
			}		
		endif;
	} endif;
}


query View::getEdgeType(element : Element) : String {
	return if self.type = 'Reference' then '' /* Context and Constraint Links handled separately */
		elif element.oclIsTypeOf(AssociationClass) then 'AssociationClass_Edge'
		elif element.oclIsTypeOf(Association) then 'Association_Edge'
		elif element.oclIsTypeOf(Association) then 'Association_BranchEdge'
		elif element.oclIsTypeOf(Generalization) then 'Generalization_Edge'
		elif element.oclIsTypeOf(InterfaceRealization) then 'InterfaceRealization_Edge'
		elif element.oclIsTypeOf(Substitution) then 'Substitution_Edge'
		elif element.oclIsTypeOf(Realization) then 'Realization_Edge'
		elif element.oclIsTypeOf(Abstraction) then 'Abstraction_Edge'
		elif element.oclIsTypeOf(Usage) then 'Usage_Edge'
		elif element.oclIsTypeOf(Dependency) then 'Dependency_Edge'
		elif element.oclIsTypeOf(Dependency) then 'Dependency_BranchEdge'
		elif element.oclIsTypeOf(ElementImport) then 'ElementImport_Edge'
		elif element.oclIsTypeOf(PackageImport) then 'PackageImport_Edge'
		elif element.oclIsTypeOf(PackageMerge) then 'PackageMerge_Edge'
		elif element.oclIsTypeOf(ProfileApplication) then 'ProfileApplication_Edge'
		elif element.oclIsTypeOf(Comment) then'Comment_AnnotatedElementEdge'
		elif element.oclIsTypeOf(TemplateBinding) then 'TemplateBinding_Edge'
		elif element.oclIsTypeOf(GeneralizationSet) then 'GeneralizationSet_Edge'
		elif element.oclIsTypeOf(InstanceSpecification) then 'InstanceSpecification_Edge'
		elif element.oclIsTypeOf(InformationFlow) then 'InformationFlow_Edge'
		else self.fail()
	endif;
}

