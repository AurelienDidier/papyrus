/*****************************************************************************
 * Copyright (c) 2013, 2016 CEA LIST, Christian W. Damus, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Camille Letavernier (CEA LIST) camille.letavernier@cea.fr - Initial API and implementation
 *  Christian W. Damus - bugs 461980, 497841, 498282, 465656
 *****************************************************************************/
import RSAToPapyrus;

modeltype notation "strict" uses 'http://www.eclipse.org/gmf/runtime/1.0.2/notation';
modeltype umlNotation "strict" uses 'http://www.eclipse.org/papyrus/umlnotation';
modeltype uml "strict" uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype sash "strict" uses 'http://www.eclipse.org/papyrus/0.7.0/sashdi';
modeltype config "strict" uses 'http:///RSAToPapyrusParameters.ecore';

transformation RSAStructureDiagram(inout semantics : uml, inout graphics : notation, out di : sash, in param : config);

main() {
	semantics.rootObjects()[uml::Element]->map toOwnedDiagrams();
}

query View::getDiagramType() : String{
	return 'CompositeStructure';
}

mapping notation::Diagram::generateDiagram() : notation::Diagram inherits Diagram::toPapyrusDiagram when {
	self.type = 'Structure'
}{
	init {
		
	}
	end {
		graphics.objectsOfType(Shape)->select(type = 'Comment_Shape').map addCommentDecoration();
		graphics.objectsOfType(Shape)->select(type = 'Constraint_Shape').map addConstraintDecoration();
	}
}


mapping inout Shape::addCommentDecoration() when {
	self.type = 'Comment_Shape' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := 'Comment_BodyLabel'; //Comment body
	}	

}

mapping inout Shape::addConstraintDecoration() when {
	self.type = 'Constraint_Shape' and self.diagram.type = self.getDiagramType()
} {
	
	self.children += object DecorationNode{
		type := 'Constraint_BodyLabel'; //Constraint specification
	}
}


mapping Node::toNode() : Node disjuncts
	UMLShape::toPapyrusShape,
	UMLShapeCompartment::toStructureCompartment,
	BasicSemanticCompartment::toListCompartment,
	BasicDecorationNode::toConnectorLabel,
	BasicDecorationNode::toLabel
	//TODO: Disjunct nodes mapping
;

mapping Edge::toEdge() : Edge disjuncts
	UMLConnector::toCommentLink,
	UMLConnector::toConstraintLink,
	UMLConnector::toPapyrusConnector
	//TODO: Disjunct edges mapping
;

mapping UMLShapeCompartment::toStructureCompartment() : DecorationNode inherits UMLShapeCompartment::toAbstractStructureCompartment when {
	self.type = 'StructureCompartment' or self.type = 'PackageContents' and not self.getType().oclIsUndefined();
}{
	
}

query Diagram::getDiagramFrame() : Node {
	// Class_Shape denotes the structure frame in this diagram
	return self.children->any(type = 'Class_Shape').oclAsType(notation::Node);
}

mapping inout Node::defaultFrameSize() {
	var size : Size = self.layoutConstraint.oclAsType(notation::Size);
	if (size.width = -1) then {
		size.width := 600;
	} endif;
	if (size.height = -1) then {
		size.height := 400;
	} endif;
}

mapping inout Node::defaultSize(dWidth : Integer, dHeight : Integer) when {
	self.layoutConstraint.oclIsKindOf(notation::Size) and
		let size = self.layoutConstraint.oclAsType(notation::Size) in
			size.width = -1 or size.height = -1
} {
	var size : Size = self.layoutConstraint.oclAsType(notation::Size);
	if (size.width = -1) then {
		size.width := dWidth;
	} endif;
	if (size.height = -1) then {
		size.height := dHeight;
	} endif;
}

/***** Nodes **********/

mapping UMLShape::toPapyrusShape() : Shape inherits Shape::toPapyrusShape when {
	not self.getType().oclIsUndefined() and (
		self.element.oclIsTypeOf(DurationInterval)or
	self.element.oclIsTypeOf(UseCase)or
	self.element.oclIsTypeOf(Port)or
	self.element.oclIsTypeOf(LiteralInteger)or
	self.element.oclIsTypeOf(Node)or
	self.element.oclIsTypeOf(Class)or
	self.element.oclIsTypeOf(Expression)or
	self.element.oclIsTypeOf(IntervalConstraint)or
	self.element.oclIsTypeOf(InteractionConstraint)or
	self.element.oclIsTypeOf(TimeConstraint)or
	self.element.oclIsTypeOf(OpaqueBehavior)or
	self.element.oclIsTypeOf(Duration)or
	self.element.oclIsTypeOf(Actor)or
	self.element.oclIsTypeOf(TimeEvent)or
	self.element.oclIsTypeOf(DurationConstraint)or
	//self.element.oclIsTypeOf(Interface)or
	self.element.oclIsTypeOf(SignalEvent)or
	self.element.oclIsTypeOf(TimeExpression)or
	self.element.oclIsTypeOf(Enumeration)or
	self.element.oclIsTypeOf(OpaqueExpression)or
	self.element.oclIsTypeOf(LiteralBoolean)or
	self.element.oclIsTypeOf(AnyReceiveEvent)or
	self.element.oclIsTypeOf(FunctionBehavior)or
	self.element.oclIsTypeOf(LiteralUnlimitedNatural)or
	self.element.oclIsTypeOf(Activity)or
	self.element.oclIsTypeOf(Signal)or
	self.element.oclIsTypeOf(Parameter)or
	self.element.oclIsTypeOf(StringExpression)or
	self.element.oclIsTypeOf(Interval)or
	self.element.oclIsTypeOf(PrimitiveType)or
	self.element.oclIsTypeOf(CollaborationUse)or
	self.element.oclIsTypeOf(TimeObservation)or
	self.element.oclIsTypeOf(DeploymentSpecification)or
	self.element.oclIsTypeOf(StateMachine)or
	self.element.oclIsTypeOf(Device)or
	self.element.oclIsTypeOf(Comment)or
	self.element.oclIsTypeOf(InformationItem)or
	self.element.oclIsTypeOf(Artifact)or
	self.element.oclIsTypeOf(Collaboration)or
	self.element.oclIsTypeOf(ProtocolStateMachine)or
	self.element.oclIsTypeOf(TimeInterval)or
	self.element.oclIsTypeOf(CallEvent)or
	self.element.oclIsTypeOf(InstanceValue)or
	self.element.oclIsTypeOf(DurationObservation)or
	self.element.oclIsTypeOf(Property)or
	self.element.oclIsTypeOf(Constraint)or
	self.element.oclIsTypeOf(ExecutionEnvironment)or
	self.element.oclIsTypeOf(LiteralString)or
	self.element.oclIsTypeOf(DataType)or
	self.element.oclIsTypeOf(ChangeEvent)or
	self.element.oclIsTypeOf(Component)or
	self.element.oclIsTypeOf(LiteralNull)or
	self.element.oclIsTypeOf(Interaction)
	)
}{

	if (result.type = 'Property_Shape') {
		// Handle default size of part shape
		result.map defaultSize(160, 40);
	}
}

/****** Adjustments to newly attached output views ******/

mapping inout Node::adjustNode() disjuncts
	Node::adjustStructureCompartment,
	Node::adjustPort
;

mapping inout Node::adjustStructureCompartment() when {
	self.type = 'Class_StructureCompartment'
} {
	// All ports, even internal ports, are children of the frame
	self.children->select(type = 'Port_Shape').map hoistPortNode();
}

mapping inout Node::adjustPort() when {
	self.type = 'Port_Shape'
		and self.element.oclIsKindOf(Port)
		and self.element.oclAsType(Port).isConjugated
} {
	// If the port is conjugated, we need to enable the default visualization,
	// not the colour (if any) imported from RSA
	self.unset('fillColor');
}

mapping inout Node::hoistPortNode()	{
	self.parentNode().parentNode().children += self;
	
	// Add the height of the name label to account for the placement in the frame
	// instead of the structure compartment
	var loc = self.layoutConstraint.oclAsType(Location);
	loc.y := loc.y + 20;
}

/****** Connector Labels ******/

mapping BasicDecorationNode::toConnectorLabel() : DecorationNode inherits Node::toPapyrusConnectorLabel when {
	not self.getType().oclIsUndefined() and (
		self.type = 'ToMultiplicityLabel' or
		self.type = 'ToRoleLabel' or
		self.type = 'FromMultiplicityLabel' or
		self.type = 'FromRoleLabel' or
		self.type = 'NameLabel' or
		self.type = 'KindLabel' or
		self.type = 'PartTextCompartment' or
		self.type = 'PartName' or
		self.type = 'CommentBody'
	)
}{
	
}

/****** Compartments *******/

mapping BasicDecorationNode::toLabel() : DecorationNode inherits Node::toPapyrusNode when {
	not self.getType().oclIsUndefined() and
	self.element.oclIsKindOf(uml::NamedElement) and 
	self.type = 'Name' or self.type = 'PartName'
}{
	
}

mapping BasicSemanticCompartment::toListCompartment() : BasicCompartment inherits Node::toPapyrusNode, DrawerStyle::toDrawerStyle when {
	self.type.endsWith('Compartment') and not self.getType().oclIsUndefined()
}{
	result.children := self.findElement().map toContents(self);
}

mapping Element::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Enumeration::toContents,
	DataType::toContents
;

mapping Enumeration::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Enumeration::toliteralsContents
;

mapping DataType::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	DataType::topropertiesContents,
	DataType::tooperationsContents
;

mapping Enumeration::toliteralsContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'EnumerationLiteralCompartment';
}{
	init {
		result := (self.map fillEnumerationLiteral(node))
	}
}

mapping DataType::topropertiesContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'Compartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping DataType::tooperationsContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'Compartment';
}{
	init {
		result := (self.map fillOperation(node))
	}
}

mapping uml::DataType::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='Compartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property).map toPropertyInDataType(node)->asSequence();
	}
}

mapping uml::DataType::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='Compartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInDataType(node)->asSequence();
	}
}



mapping uml::Enumeration::fillEnumerationLiteral(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='EnumerationLiteralCompartment';
}{
	init {
		result := self.ownedLiteral->selectByKind(EnumerationLiteral).map toEnumerationLiteralInEnumeration(node)->asSequence();
	}
}

mapping UMLConnector::toCommentLink() : Connector inherits Connector::toCommentLink when{
	self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Comment) or 
	 	self.target.element.oclIsKindOf(Comment)
	)
}{	
	result.type :='Comment_AnnotatedElementEdge';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
}

mapping UMLConnector::toConstraintLink() : Connector inherits Connector::toPapyrusConnector when{
	self.type='Reference' and ( 
	 	self.source.element.oclIsTypeOf(Constraint) or 
	 	self.target.element.oclIsKindOf(Constraint)
	)
}{	
	result.type :='Constraint_ConstrainedElementEdge';
	result.bendpoints := self.bendpoints.map toBendpoint(self.diagram);
	result.sourceAnchor := object IdentityAnchor{};		
}

mapping Property::toPropertyInDataType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Property_AttributeLabel';
}

mapping Operation::toOperationInDataType(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Operation_OperationLabel';
}

mapping Reception::toReceptionIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3100';
}

mapping EnumerationLiteral::toEnumerationLiteralInEnumeration(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'EnumerationLiteral_LiteralLabel';
}

mapping Activity::toActivityIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3103';
}

mapping Interaction::toInteractionIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3104';
}

mapping ProtocolStateMachine::toProtocolStateMachineIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3105';
}

mapping StateMachine::toStateMachineIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3106';
}

mapping FunctionBehavior::toFunctionBehaviorIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3107';
}

mapping OpaqueBehavior::toOpaqueBehaviorIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3108';
}

mapping Collaboration::toCollaborationIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3109';
}

mapping Interface::toInterfaceIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3110';
}

mapping Enumeration::toEnumerationIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3111';
}

mapping PrimitiveType::toPrimitiveTypeIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3112';
}

mapping DataType::toDataTypeIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3113';
}

mapping Class::toClassIn(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := '3114';
}



/******* Edges ********/


mapping UMLConnector::toPapyrusConnector() : notation::Connector inherits Connector::toPapyrusConnector when {
	not self.getType().oclIsUndefined() and (
		self.element.oclIsTypeOf(ComponentRealization)or
		self.element.oclIsTypeOf(InterfaceRealization)or
		self.element.oclIsTypeOf(Substitution)or
		self.element.oclIsTypeOf(Realization)or
		self.element.oclIsTypeOf(Manifestation)or
		self.element.oclIsTypeOf(Abstraction)or
		self.element.oclIsTypeOf(Usage)or
		self.element.oclIsTypeOf(Deployment)or
		self.element.oclIsTypeOf(Dependency)or
		self.element.oclIsTypeOf(Dependency)or
		self.element.oclIsTypeOf(uml::Connector)or
		self.element.oclIsTypeOf(Generalization)or
		self.element.oclIsTypeOf(InformationFlow)
	)
}{
	result.styles := self.map toFontStyle();
}

/****** Element Type queries ******/

query View::getNodeType(element : Element) : String {
	return
		if element.oclIsTypeOf(DurationInterval) then 'DurationInterval_Shape' 
		elif element.oclIsTypeOf(UseCase) then 'UseCase_Shape' 
		elif element.oclIsTypeOf(Port) then 'Port_Shape' 
		elif element.oclIsTypeOf(LiteralInteger) then 'LiteralInteger_Shape' 
		elif element.oclIsTypeOf(Node) then 'Node_Shape' 
		elif element.oclIsTypeOf(Class) then 'Class_Shape' 
		elif element.oclIsTypeOf(Expression) then 'Expression_Shape' 
		elif element.oclIsTypeOf(IntervalConstraint) then 'IntervalConstraint_Shape' 
		elif element.oclIsTypeOf(InteractionConstraint) then 'InteractionConstraint_Shape' 
		elif element.oclIsTypeOf(TimeConstraint) then 'TimeConstraint_Shape' 
		elif element.oclIsTypeOf(OpaqueBehavior) then 'OpaqueBehavior_Shape' 
		elif element.oclIsTypeOf(Duration) then 'Duration_Shape' 
		elif element.oclIsTypeOf(Actor) then 'Actor_Shape' 
		elif element.oclIsTypeOf(TimeEvent) then 'TimeEvent_Shape' 
		elif element.oclIsTypeOf(DurationConstraint) then 'DurationConstraint_Shape' 
		//elif element.oclIsTypeOf(Interface) then 'Interface_Shape' 
		elif element.oclIsTypeOf(SignalEvent) then 'SignalEvent_Shape' 
		elif element.oclIsTypeOf(TimeExpression) then 'TimeExpression_Shape' 
		elif element.oclIsTypeOf(Enumeration) then 'Enumeration_Shape' 
		elif element.oclIsTypeOf(OpaqueExpression) then 'OpaqueExpression_Shape' 
		elif element.oclIsTypeOf(LiteralBoolean) then 'LiteralBoolean_Shape' 
		elif element.oclIsTypeOf(AnyReceiveEvent) then 'AnyReceiveEvent_Shape' 
		elif element.oclIsTypeOf(FunctionBehavior) then 'FunctionBehavior_Shape' 
		elif element.oclIsTypeOf(LiteralUnlimitedNatural) then 'LiteralUnlimitedNatural_Shape' 
		elif element.oclIsTypeOf(Activity) then 'Activity_Shape' 
		elif element.oclIsTypeOf(Signal) then 'Signal_Shape' 
		elif element.oclIsTypeOf(Parameter) then 'Parameter_Shape' 
		elif element.oclIsTypeOf(StringExpression) then 'StringExpression_PackagedElementShape' 
		elif element.oclIsTypeOf(Interval) then 'Interval_Shape' 
		elif element.oclIsTypeOf(PrimitiveType) then 'PrimitiveType_Shape' 
		elif element.oclIsTypeOf(CollaborationUse) then 'CollaborationUse_Shape' 
		elif element.oclIsTypeOf(TimeObservation) then 'TimeObservation_Shape' 
		elif element.oclIsTypeOf(DeploymentSpecification) then 'DeploymentSpecification_Shape' 
		elif element.oclIsTypeOf(StateMachine) then 'StateMachine_Shape' 
		elif element.oclIsTypeOf(Device) then 'Device_Shape' 
		elif element.oclIsTypeOf(Comment) then 'Comment_Shape' 
		elif element.oclIsTypeOf(InformationItem) then 'InformationItem_Shape' 
		elif element.oclIsTypeOf(Artifact) then 'Artifact_Shape' 
		elif element.oclIsTypeOf(Collaboration) then 'Collaboration_Shape' 
		elif element.oclIsTypeOf(ProtocolStateMachine) then 'ProtocolStateMachine_Shape' 
		elif element.oclIsTypeOf(TimeInterval) then 'TimeInterval_Shape' 
		elif element.oclIsTypeOf(CallEvent) then 'CallEvent_Shape' 
		elif element.oclIsTypeOf(InstanceValue) then 'InstanceValue_Shape' 
		elif element.oclIsTypeOf(DurationObservation) then 'DurationObservation_Shape' 
		elif element.oclIsTypeOf(Property) then 'Property_Shape' 
		elif element.oclIsTypeOf(Constraint) then 'Constraint_Shape' 
		elif element.oclIsTypeOf(ExecutionEnvironment) then 'ExecutionEnvironment_Shape' 
		elif element.oclIsTypeOf(LiteralString) then 'LiteralString_Shape' 
		elif element.oclIsTypeOf(DataType) then 'DataType_Shape' 
		elif element.oclIsTypeOf(ChangeEvent) then 'ChangeEvent_Shape' 
		elif element.oclIsTypeOf(Component) then 'Component_Shape' 
		elif element.oclIsTypeOf(LiteralNull) then 'LiteralNull_Shape' 
		elif element.oclIsTypeOf(Interaction) then 'Interaction_Shape' 
		else self.fail()
	endif;
}


query View::getDecorationType(element : Element) : String{
	var res := self.doGetDecorationType(element);
	
	
	/*log('Get papyrus ID for'+ self.element.eClass().name+', '+self.type);
	
	log(res);
	
	if self.container().oclIsKindOf(Node) then 
		log('IsNode')
	else 
		log('IsEdge')
	endif;*/
	
	
	return res;
}

query View::doGetDecorationType(element : Element) : String{
	return if self.container().oclIsKindOf(Node) then {
		return if element.oclIsTypeOf(DurationInterval) then
			return switch {
				case (self.type = 'Name' or self.type = 'PartName') 'DurationInterval_NameLabel';
				
			}
			elif element.oclIsTypeOf(UseCase) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'UseCase_NameLabel';
					
				}
			elif element.oclIsTypeOf(Port) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Port_NameLabel';
					
				}
			elif element.oclIsTypeOf(LiteralInteger) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'LiteralInteger_NameLabel';
					
				}
			elif element.oclIsTypeOf(Node) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Node_NameLabel';
					case (self.type = 'StructureCompartment') 'Node_StructureCompartment';
				}
			elif element.oclIsTypeOf(Class) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Class_NameLabel';
					case (self.type = 'StructureCompartment') 'Class_StructureCompartment';
				}
			elif element.oclIsTypeOf(Expression) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Expression_NameLabel';
					
				}
			elif element.oclIsTypeOf(IntervalConstraint) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'IntervalConstraint_NameLabel';
					
				}
			elif element.oclIsTypeOf(InteractionConstraint) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'InteractionConstraint_NameLabel';
					
				}
			elif element.oclIsTypeOf(TimeConstraint) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'TimeConstraint_NameLabel';
					
				}
			elif element.oclIsTypeOf(OpaqueBehavior) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'OpaqueBehavior_NameLabel';
					case (self.type = 'StructureCompartment') 'OpaqueBehavior_StructureCompartment';
				}
			elif element.oclIsTypeOf(Duration) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Duration_NameLabel';
					
				}
			elif element.oclIsTypeOf(Actor) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Actor_NameLabel';
					
				}
			elif element.oclIsTypeOf(TimeEvent) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'TimeEvent_NameLabel';
					
				}
			elif element.oclIsTypeOf(DurationConstraint) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'DurationConstraint_NameLabel';
					
				}
			elif element.oclIsTypeOf(Interface) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Interface_NameLabel';
					
				}
			elif element.oclIsTypeOf(SignalEvent) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'SignalEvent_NameLabel';
					
				}
			elif element.oclIsTypeOf(TimeExpression) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'TimeExpression_NameLabel';
					
				}
			elif element.oclIsTypeOf(Enumeration) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Enumeration_NameLabel';
					case (self.type = 'EnumerationLiteralCompartment') 'Enumeration_LiteralCompartment';
				}
			elif element.oclIsTypeOf(OpaqueExpression) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'OpaqueExpression_NameLabel';
					
				}
			elif element.oclIsTypeOf(LiteralBoolean) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'LiteralBoolean_NameLabel';
					
				}
			elif element.oclIsTypeOf(AnyReceiveEvent) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'AnyReceiveEvent_NameLabel';
					
				}
			elif element.oclIsTypeOf(FunctionBehavior) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'FunctionBehavior_NameLabel';
					case (self.type = 'StructureCompartment') 'FunctionBehavior_StructureCompartment';
				}
			elif element.oclIsTypeOf(LiteralUnlimitedNatural) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'LiteralUnlimitedNatural_NameLabel';
					
				}
			elif element.oclIsTypeOf(Activity) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Activity_NameLabel';
					case (self.type = 'StructureCompartment') 'Activity_StructureCompartment';
				}
			elif element.oclIsTypeOf(Signal) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Signal_NameLabel';
					
				}
			elif element.oclIsTypeOf(Parameter) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Parameter_NameLabel';
					
				}
			elif element.oclIsTypeOf(StringExpression) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'StringExpression_NameLabel';
					
				}
			elif element.oclIsTypeOf(Interval) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Interval_NameLabel';
					
				}
			elif element.oclIsTypeOf(PrimitiveType) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'PrimitiveType_NameLabel';
					
				}
			elif element.oclIsTypeOf(CollaborationUse) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'CollaborationUse_NameLabel';
					
				}
			elif element.oclIsTypeOf(TimeObservation) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'TimeObservation_NameLabel';
					
				}
			elif element.oclIsTypeOf(DeploymentSpecification) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'DeploymentSpecification_NameLabel';
					
				}
			elif element.oclIsTypeOf(StateMachine) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'StateMachine_NameLabel';
					case (self.type = 'StructureCompartment') 'StateMachine_StructureCompartment';
				}
			elif element.oclIsTypeOf(Device) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Device_NameLabel';
					case (self.type = 'StructureCompartment') 'Device_StructureCompartment';
				}
			elif element.oclIsTypeOf(InformationItem) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'InformationItem_NameLabel';
					
				}
			elif element.oclIsTypeOf(Artifact) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Artifact_NameLabel';
					
				}
			elif element.oclIsTypeOf(Collaboration) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Collaboration_NameLabel';
					case (self.type = 'StructureCompartment') 'Collaboration_StructureCompartment';
				}
			elif element.oclIsTypeOf(ProtocolStateMachine) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'ProtocolStateMachine_NameLabel';
					case (self.type = 'StructureCompartment') 'ProtocolStateMachine_StructureCompartment';
				}
			elif element.oclIsTypeOf(TimeInterval) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'TimeInterval_NameLabel';
					
				}
			elif element.oclIsTypeOf(CallEvent) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'CallEvent_NameLabel';
					
				}
			elif element.oclIsTypeOf(InstanceValue) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'InstanceValue_NameLabel';
					
				}
			elif element.oclIsTypeOf(DurationObservation) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'DurationObservation_NameLabel';
					
				}
			elif element.oclIsTypeOf(Property) then
				return switch {
					case (self.type = 'PartName' or self.type='PartTextCompartment') 'Property_NameLabel';
					case (self.type = 'StructureCompartment') 'Property_StructureCompartment';
				}
			elif element.oclIsTypeOf(Constraint) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Constraint_NameLabel';
					
				}
			elif element.oclIsTypeOf(ExecutionEnvironment) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'ExecutionEnvironment_NameLabel';
					case (self.type = 'StructureCompartment') 'ExecutionEnvironment_StructureCompartment';
				}
			elif element.oclIsTypeOf(LiteralString) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'LiteralString_NameLabel';
					
				}
			elif element.oclIsTypeOf(DataType) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'DataType_NameLabel';
					case (self.type = 'Compartment') 'DataType_AttributeCompartment';
				case (self.type = 'Compartment') 'DataType_OperationCompartment';
				}
			elif element.oclIsTypeOf(ChangeEvent) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'ChangeEvent_NameLabel';
					
				}
			elif element.oclIsTypeOf(Component) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Component_NameLabel';
					case (self.type = 'StructureCompartment') 'Component_StructureCompartment';
				}
			elif element.oclIsTypeOf(LiteralNull) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'LiteralNull_NameLabel';
					
				}
			elif element.oclIsTypeOf(Interaction) then
				return switch {
					case (self.type = 'Name' or self.type = 'PartName') 'Interaction_NameLabel';
					case (self.type = 'StructureCompartment') 'Interaction_StructureCompartment';
				}
			elif element.oclIsTypeOf(Comment) then
				return switch {
					case (self.type = 'CommentBody') 'Comment_BodyLabel';
				}
		endif
	} else {
		return if element.oclIsTypeOf(ComponentRealization)  then
			return switch {
				case (self.type='Name') 'ComponentRealization_NameLabel';		
				case (self.type = 'NameLabel') 'ComponentRealization_NameLabel';
				case (self.type = 'KindLabel') 'ComponentRealization_StereotypeLabel';
			}
			elif element.oclIsTypeOf(InterfaceRealization)  then
				return switch {
					case (self.type='Name') 'InterfaceRealization_NameLabel';		
					case (self.type = 'NameLabel') 'InterfaceRealization_NameLabel';
					case (self.type = 'KindLabel') 'InterfaceRealization_StereotypeLabel';
				}
			elif element.oclIsTypeOf(Substitution)  then
				return switch {
					case (self.type='Name') 'Substitution_NameLabel';		
					case (self.type = 'NameLabel') 'Substitution_NameLabel';
					case (self.type = 'KindLabel') 'Substitution_StereotypeLabel';
				}
			elif element.oclIsTypeOf(Realization)  then
				return switch {
					case (self.type='Name') 'Realization_NameLabel';		
					case (self.type = 'NameLabel') 'Realization_NameLabel';
					case (self.type = 'KindLabel') 'Realization_StereotypeLabel';
				}
			elif element.oclIsTypeOf(Manifestation)  then
				return switch {
					case (self.type='Name') 'Manifestation_NameLabel';		
					case (self.type = 'NameLabel') 'Manifestation_NameLabel';
					case (self.type = 'KindLabel') 'Manifestation_StereotypeLabel';
				}
			elif element.oclIsTypeOf(Abstraction)  then
				return switch {
					case (self.type='Name') 'Abstraction_NameLabel';		
					case (self.type = 'NameLabel') 'Abstraction_NameLabel';
					case (self.type = 'KindLabel') 'Abstraction_StereotypeLabel';
				}
			elif element.oclIsTypeOf(Usage)  then
				return switch {
					case (self.type='Name') 'Usage_NameLabel';		
					case (self.type = 'NameLabel') 'Usage_NameLabel';
					case (self.type = 'KindLabel') 'Usage_StereotypeLabel';
				}
			elif element.oclIsTypeOf(Deployment)  then
				return switch {
					case (self.type='Name') 'Deployment_NameLabel';		
					case (self.type = 'NameLabel') 'Deployment_NameLabel';
					case (self.type = 'KindLabel') 'Deployment_StereotypeLabel';
				}
			elif element.oclIsTypeOf(Dependency)  then
				return switch {
					case (self.type='Name') 'Dependency_RoleBindingNameLabel';		
					case (self.type = 'NameLabel') 'Dependency_RoleBindingNameLabel';
					case (self.type = 'KindLabel') 'Dependency_RoleBindingStereotypeLabel';
				}
			elif element.oclIsTypeOf(Dependency)  then
				return switch {
					case (self.type='Name') 'Dependency_NameLabel';		
					case (self.type = 'NameLabel') 'Dependency_NameLabel';
					case (self.type = 'KindLabel') 'Dependency_StereotypeLabel';
				}
			elif element.oclIsTypeOf(uml::Connector)  then
				return switch {
					case (self.type='Name') 'Connector_NameLabel';		
					case (self.type = 'KindLabel') 'Connector_StereotypeLabel';
					case (self.type = 'NameLabel') 'Connector_NameLabel';
					case (self.type = 'FromMultiplicityLabel') 'Connector_SourceMultiplicityLabel';
					case (self.type = 'ToMultiplicityLabel') 'Connector_TargetMultiplicityLabel';
				}
			elif element.oclIsTypeOf(Generalization)  then
				return switch {
							
					case (self.type = 'KindLabel') 'Generalization_StereotypeLabel';
				}
			elif element.oclIsTypeOf(InformationFlow)  then
				return switch {
							
					
					case (self.type = 'KindLabel') 'InformationFlow_StereotypeLabel';
				}
		endif
	} endif;
}


query View::getEdgeType(element : Element) : String {
	return
		if self.type = 'Reference' then '' /* Comment/Constraint Links handled separately */
		elif element.oclIsTypeOf(ComponentRealization) then 'ComponentRealization_Edge'
		elif element.oclIsTypeOf(InterfaceRealization) then 'InterfaceRealization_Edge'
		elif element.oclIsTypeOf(Substitution) then 'Substitution_Edge'
		elif element.oclIsTypeOf(Realization) then 'Realization_Edge'
		elif element.oclIsTypeOf(Manifestation) then 'Manifestation_Edge'
		elif element.oclIsTypeOf(Abstraction) then 'Abstraction_Edge'
		elif element.oclIsTypeOf(Usage) then 'Usage_Edge'
		elif element.oclIsTypeOf(Deployment) then 'Deployment_Edge'
		elif element.oclIsTypeOf(Dependency) then 'Dependency_RoleBindingEdge'
		elif element.oclIsTypeOf(Dependency) then 'Dependency_Edge'
		elif element.oclIsTypeOf(uml::Connector) then 'Connector_Edge'
		elif element.oclIsTypeOf(Generalization) then 'Generalization_Edge'
		elif element.oclIsTypeOf(InformationFlow) then 'InformationFlow_Edge'
		else self.fail()
	endif;
}

