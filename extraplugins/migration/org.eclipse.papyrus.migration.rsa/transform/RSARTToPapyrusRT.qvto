/*****************************************************************************
 * Copyright (c) 2013, 2014 CEA LIST.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Camille Letavernier (CEA LIST) camille.letavernier@cea.fr - Initial API and implementation
 *****************************************************************************/
import org.eclipse.papyrus.migration.rsa.RTMappings;
import org.eclipse.papyrus.m2m.qvto.EMFResource;
import libraries.EclipseUI;
 
modeltype uml "strict" uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype notation "strict" uses 'http://www.eclipse.org/gmf/runtime/1.0.2/notation';
modeltype umlrt "strict" uses 'http://www.eclipse.org/papyrus/umlrt';
modeltype umlrtsm "strict" uses 'http://www.eclipse.org/papyrus/umlrt/statemachine';
modeltype sourcert "strict" uses 'http://www.eclipse.org/papyrus/profile/umlrt'; 
modeltype ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';

transformation RSARTToPapyrusRT(inout semantics : uml, inout graphics : notation, in profiles : uml, in profileDefinitions : ecore);

property UML_RT_URI : String = 'http://www.eclipse.org/papyrus/umlrt';

property UML_RT_SM_URI : String = 'http://www.eclipse.org/papyrus/umlrt/statemachine';

property RT_PROFILE_URI_PREFIX : String = 'pathmap://RT_PROPERTIES/UMLRealTime.epx';

property UML_DEFINITION_SOURCE : String = 'http://www.eclipse.org/uml2/2.0.0/UML';

main() {
	semantics.objectsOfType(ProfileApplication).map toPapyrusRTProfile();
	
	//Apply new RT Stereotypes first
	semantics.objectsOfType(StateMachine).map applyRTStateMachine();
	semantics.objectsOfType(Region).map applyRTRegion();
	semantics.objectsOfType(State).map applyRTState();
	semantics.objectsOfType(Pseudostate).map applyRTPseudostate();

	semantics.objectsOfType(sourcert::AbstractEvent)->select(findInterface().oclIsUndefined())->forEach (e){
		var elementLabel : String := if e.base_CallEvent.oclIsUndefined() then
			"<Undefined>"
		elif e.base_CallEvent.operation.name.oclIsUndefined() then
			'<Unnamed>'
		else 
			e.base_CallEvent.operation.name
		endif;
		
		var stereotypeLabel := if e.oclIsKindOf(InEvent) then "<<InEvent>>" else "<<OutEvent>>" endif;
		warning("The "+stereotypeLabel+" CallEvent "+elementLabel+" isn't associated to an operation contained in an Interface. An equivalent RTMessageSet cannot be created");
		semantics.removeElement(e);
	};
	
	semantics.objectsOfType(sourcert::AbstractEvent).map toMessageSet();
	semantics.objectsOfType(sourcert::Capsule).map toCapsule();
	semantics.objectsOfType(sourcert::CapsulePart).map toCapsulePart();
	semantics.objectsOfType(sourcert::Protocol).map toProtocol();
	semantics.objectsOfType(sourcert::ProtocolContainer).map toProtocolPackage();
	semantics.objectsOfType(sourcert::RTConnector).map toRTConnector();
	semantics.objectsOfType(sourcert::RTHistorystate).map toHistorystate();
	semantics.objectsOfType(sourcert::RTPort).map toRTPort();
	semantics.objectsOfType(sourcert::RTRedefinableElement).map toRTRExcludedElement();
	semantics.objectsOfType(sourcert::Trigger).map toRTTrigger();
	semantics.objectsOfType(sourcert::Coregion).map delete();
}

mapping inout ProfileApplication::toPapyrusRTProfile() : ProfileApplication when {
	self.getDefinition().oclAsType(EObject).getURI().startsWith(RT_PROFILE_URI_PREFIX);
}{
	//UML-RT
	self.appliedProfile := getRTProfile();
	
	self.getDefinitionAnnotation()._references := profileDefinitions.rootObjects()[EPackage]->any(nsURI = UML_RT_URI).oclAsType(EObject);
	self.eAnnotations := self.getDefinitionAnnotation(); //Remove all other annotations
	
	//UML-RT StateMachine extension
	result.appliedProfile := getRTSMProfile();
	
	result.eAnnotations := object EAnnotation {
		_references := profileDefinitions.rootObjects()[EPackage]->any(nsURI = UML_RT_SM_URI).oclAsType(EObject);
		source := UML_DEFINITION_SOURCE;
	};
	
	self.applyingPackage.profileApplication += result;
}

/* TriggerEvent removed in Papyrus UMLRT V3 (Replaced with RTMessageSet) */
mapping AbstractEvent::toMessageSet() when {
	not self.findInterface().oclIsUndefined() 
}{
	var owningInterface : Interface := self.findInterface();
	
	//An interface can have several operations. 
	//Inout mapping ensures that the stereotype can be created at most once for each interface
	var direction : RTMessageKind := self.getDirection();
	var messageSet : RTMessageSet := owningInterface.map createMessageSet(direction);
	
	//Ensure that the model is consistent: the resulting messageSet shall have the same direction. If not, then the source model is inconsistent
	if messageSet.rtMsgKind <> direction then
		warning("Inconsistent input model: interface "+owningInterface.name+" has operations with different directions")
	endif;
	
	semantics.removeElement(self);
}

mapping inout Interface::createMessageSet(direction : RTMessageKind) : RTMessageSet {
	result.base_Interface := self;
	result.rtMsgKind := direction; 
}

query AbstractEvent::findInterface() : Interface {
	var baseEvent := self.base_CallEvent;
	var operation := baseEvent.operation;
	var owningInterface := operation.interface;
	
	return owningInterface;
}

mapping sourcert::Capsule::toCapsule() : umlrt::Capsule {
	result.base_Class := self.base_Class;
	
	semantics.removeElement(self);
}

mapping sourcert::CapsulePart::toCapsulePart() : umlrt::CapsulePart {
	result.base_Property := self.base_Property;
	
	semantics.removeElement(self);
}

mapping sourcert::Protocol::toProtocol() : umlrt::Protocol {
	result.base_Collaboration := self.base_Collaboration;
	
	semantics.removeElement(self);
}

mapping sourcert::ProtocolContainer::toProtocolPackage() : umlrt::ProtocolContainer {
	result.base_Package := self.base_Package;
	
	semantics.removeElement(self);
}

mapping sourcert::RTConnector::toRTConnector() : umlrt::RTConnector {
	result.base_Connector := self.base_Connector;
	
	semantics.removeElement(self);
}

mapping sourcert::RTHistorystate::toHistorystate() {
	if self.historyKind = HistoryKind::Deep then self.base_Pseudostate.kind := PseudostateKind::deepHistory endif;
	if self.historyKind = HistoryKind::Shallow then self.base_Pseudostate.kind := PseudostateKind::shallowHistory endif;
	
	semantics.removeElement(self);
}

mapping sourcert::RTPort::toRTPort() : umlrt::RTPort {
	result.isNotification := self.isNotification;
	result.isPublish := self.isPublish;
	result.isWired := self.isWired;
	result.registration := self.registration.getPapyrusType();
	result.registrationOverride := self.registrationOverride;
	
	result.base_Port := self.base_Port;
	result.base_Port.isConjugated := self.isConjugate;
	
	semantics.removeElement(self);
}

mapping sourcert::RTRedefinableElement::toRTRExcludedElement() : umlrt::RTRExcludedElement {
	result.base_RedefinableElement := self.base_RedefinableElement;
	
	semantics.removeElement(self);
}

mapping sourcert::Trigger::toRTTrigger() : RTTrigger {
	result.base_Operation := self.base_Operation;

	semantics.removeElement(self);
}

mapping Coregion::delete() {
	semantics.removeElement(self);
}

query sourcert::PortRegistrationType::getPapyrusType() : umlrt::PortRegistrationType {
	return switch {
		case (self = sourcert::PortRegistrationType::Automatic) 
			umlrt::PortRegistrationType::Automatic;
		case (self = sourcert::PortRegistrationType::Automatic) 
			umlrt::PortRegistrationType::Automatic;
		else 
			umlrt::PortRegistrationType::ApplicationLocked;
	};
}

query sourcert::AbstractEvent::getDirection() : RTMessageKind {
	return if self.oclIsTypeOf(InEvent) then 
		RTMessageKind::_in
	else
		RTMessageKind::_out
	endif;
}

/** StateMachine Stereotypes (Auto-applied) */

mapping StateMachine::applyRTStateMachine() : RTStateMachine when {
	self.isRT()
}{
	result.base_StateMachine := self;
}

mapping State::applyRTState() : RTState when {
	self.isRT()
}{
	result.base_State := self;
}

mapping Pseudostate::applyRTPseudostate() : RTPseudostate when {
	self.isRT()
}{
	result.base_Pseudostate := self;
}

mapping Region::applyRTRegion() : RTRegion when {
	self.isRT()
}{
	result.base_Region := self;
}

query StateMachine::isRT() : Boolean {
	return semantics.rootObjects()[sourcert::Capsule]->exists(c | c.base_Class = self.getClassifier());
}

query StateMachine::getClassifier() : BehavioredClassifier {
	return if 
		self.owner.oclIsKindOf(BehavioredClassifier) 
		and self.owner.oclAsType(BehavioredClassifier).classifierBehavior = self 
	then 
		self.owner.oclAsType(BehavioredClassifier) 
	else 
		null 
	endif;
}

query Region::isRT() : Boolean {
	return if not self.stateMachine.oclIsUndefined() then
		self.stateMachine.isRT()
	else
		self.state.isRT()
	endif;
}

query State::isRT() : Boolean {
	return self.owner.oclAsType(Region).isRT();
}

query Pseudostate::isRT() : Boolean {
	return switch {
		case (self.owner.oclIsKindOf(Region)) self.owner.oclAsType(Region).isRT();
		case (self.owner.oclIsKindOf(StateMachine)) self.owner.oclAsType(StateMachine).isRT();
		case (self.owner.oclIsKindOf(State)) self.owner.oclAsType(State).isRT();
		else false;
	};
}

/** Profile application */

query ProfileApplication::getDefinitionAnnotation() : EAnnotation {
	return self.getEAnnotation(UML_DEFINITION_SOURCE);
}

query ProfileApplication::getDefinition() : EPackage {
	return self.getDefinitionAnnotation()._references->any(oclIsKindOf(EPackage)).oclAsType(EPackage);
}

query getRTProfile() : Profile {
	return profiles.rootObjects()[Profile]->any(URI = UML_RT_URI);
}

query getRTSMProfile() : Profile {
	return profiles.rootObjects()[Profile]->any(URI = UML_RT_SM_URI);
}
