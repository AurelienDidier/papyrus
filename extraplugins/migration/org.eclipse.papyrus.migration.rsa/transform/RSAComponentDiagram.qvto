/*****************************************************************************
 * Copyright (c) 2013, 2016 CEA LIST, Christian W. Damus, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Camille Letavernier (CEA LIST) camille.letavernier@cea.fr - Initial API and implementation
 *  Christian W. Damus - bug 465656
 *****************************************************************************/
import RSAToPapyrus;

modeltype notation "strict" uses 'http://www.eclipse.org/gmf/runtime/1.0.2/notation';
modeltype umlNotation "strict" uses 'http://www.eclipse.org/papyrus/umlnotation';
modeltype uml "strict" uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype config "strict" uses 'http:///RSAToPapyrusParameters.ecore';

transformation RSAComponentDiagram(inout semantics : uml, out graphics : notation, in param : config) extends RSAToPapyrus;

query View::getDiagramType() : String{
	return 'PapyrusUMLComponentDiagram';
}

mapping notation::Diagram::toPapyrusComponentDiagram() : notation::Diagram inherits Diagram::toPapyrusDiagram when {
	self.type = 'Component'
}{
	
}

mapping Node::toNode() : Node disjuncts
	UMLShape::toPapyrusShape,
	UMLShapeCompartment::toStructureCompartment,
	BasicSemanticCompartment::toListCompartment,
	BasicDecorationNode::toConnectorLabel,
	BasicDecorationNode::toLabel
	//TODO: Disjunct nodes mapping
;

mapping Edge::toEdge() : Edge disjuncts
	UMLConnector::toPapyrusConnector
	//TODO: Disjunct edges mapping
;

mapping UMLShapeCompartment::toStructureCompartment() : DecorationNode inherits UMLShapeCompartment::toAbstractStructureCompartment when {
	self.type = 'StructureCompartment' or self.type = 'PackageContents' and not self.getType().oclIsUndefined();
}{
	
}


/***** Nodes **********/

mapping UMLShape::toPapyrusShape() : Shape inherits Shape::toPapyrusShape when {
	self.type = '' and not self.getType().oclIsUndefined() and (
		self.element.oclIsTypeOf(Component)or
	self.element.oclIsTypeOf(Dependency)or
	self.element.oclIsTypeOf(Package)or
	self.element.oclIsTypeOf(Port)or
	self.element.oclIsTypeOf(Comment)or
	self.element.oclIsTypeOf(Interface)or
	self.element.oclIsTypeOf(Model)or
	self.element.oclIsTypeOf(Property)or
	self.element.oclIsTypeOf(Constraint)or
	self.element.oclIsTypeOf(Operation)or
	self.element.oclIsTypeOf(Reception)
	)
}{
	
}


/****** Connector Labels ******/

mapping BasicDecorationNode::toConnectorLabel() : DecorationNode inherits Node::toPapyrusConnectorLabel when {
	not self.getType().oclIsUndefined() and (
		self.type = 'ToMultiplicityLabel' or
		self.type = 'ToRoleLabel' or
		self.type = 'FromMultiplicityLabel' or
		self.type = 'FromRoleLabel' or
		self.type = 'NameLabel' or
		self.type = 'KindLabel'
	)
}{}

/****** Compartments *******/

mapping BasicDecorationNode::toLabel() : DecorationNode inherits Node::toPapyrusNode when {
	not self.getType().oclIsUndefined() and
	self.element.oclIsKindOf(uml::NamedElement) and 
	self.type = 'Name'
}{}

mapping BasicSemanticCompartment::toListCompartment() : BasicCompartment inherits Node::toPapyrusNode, DrawerStyle::toDrawerStyle when {
	self.type.endsWith('Compartment') and not self.getType().oclIsUndefined()
}{
	result.children := self.findElement().map toContents(self);
}

mapping Element::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Interface::toContents
;

mapping Interface::toContents(node : BasicSemanticCompartment) : Sequence(Node) disjuncts
	Interface::toAttributeCompartmentContents,
	Interface::toOperationCompartmentContents
;

mapping Interface::toAttributeCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'AttributeCompartment';
}{
	init {
		result := (self.map fillProperty(node))
	}
}

mapping Interface::toOperationCompartmentContents(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type = 'ReceptionCompartment';
}{
	init {
		result := (self.map fillOperation(node))
	->union(self.map fillReception(node))
	}
}

mapping uml::Interface::fillProperty(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='AttributeCompartment';
}{
	init {
		result := self.ownedAttribute->selectByKind(Property).map toPropertyInInterface(node)->asSequence();
	}
}

mapping uml::Interface::fillOperation(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='ReceptionCompartment';
}{
	init {
		result := self.ownedOperation->selectByKind(Operation).map toOperationInInterface(node)->asSequence();
	}
}

mapping uml::Interface::fillReception(node : BasicSemanticCompartment) : Sequence(Node) when {
	node.type='ReceptionCompartment';
}{
	init {
		result := self.ownedReception->selectByKind(Reception).map toReceptionInInterface(node)->asSequence();
	}
}

mapping Property::toPropertyInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Property_InterfaceAttributeLabel';
}

mapping Operation::toOperationInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Operation_InterfaceOperationLabel';
}

mapping Reception::toReceptionInInterface(node : Node) : Shape inherits Element::toCompartmentEntry {
	result.type := 'Reception_InterfaceReceptionLabel';
}



/******* Edges ********/


mapping UMLConnector::toPapyrusConnector() : Connector inherits Connector::toPapyrusConnector when {
	self.type = '' and 
	not self.getType().oclIsUndefined() and (
		self.element.oclIsTypeOf(Usage)or
		self.element.oclIsTypeOf(InterfaceRealization)or
		self.element.oclIsTypeOf(Generalization)or
		self.element.oclIsTypeOf(Substitution)or
		self.element.oclIsTypeOf(Manifestation)or
		self.element.oclIsTypeOf(ComponentRealization)or
		self.element.oclIsTypeOf(Abstraction)or
		self.element.oclIsTypeOf(Dependency)or
		self.element.oclIsTypeOf(Dependency)
	)
}{
	result.styles := self.map toFontStyle();
}

/****** Element Type queries ******/

query View::getNodeType(element : Element) : String {
	return
		if element.oclIsTypeOf(Component) then 'Component_PackagedElementShape' 
		elif element.oclIsTypeOf(Dependency) then 'Dependency_Shape' 
		elif element.oclIsTypeOf(Package) then 'Package_Shape' 
		elif element.oclIsTypeOf(Port) then 'Port_Shape' 
		elif element.oclIsTypeOf(Comment) then 'Comment_Shape' 
		elif element.oclIsTypeOf(Interface) then 'Interface_ClassifierShape' 
		elif element.oclIsTypeOf(Model) then 'Model_Shape' 
		elif element.oclIsTypeOf(Property) then 'Property_InterfaceAttributeLabel' 
		elif element.oclIsTypeOf(Constraint) then 'Constraint_Shape' 
		elif element.oclIsTypeOf(Operation) then 'Operation_InterfaceOperationLabel' 
		elif element.oclIsTypeOf(Reception) then 'Reception_InterfaceReceptionLabel' 
		else self.fail()
	endif;
}


query View::getDecorationType(element : Element) : String{
	return self.doGetDecorationType(element);
	
}

query View::doGetDecorationType(element : Element) : String{
	return if self.container().oclIsKindOf(Node) then {
		return if element.oclIsTypeOf(Component) then
			return switch {
				case (self.type = 'Name') 'Component_NameLabel';
				case (self.type = 'StructureCompartment') 'Component_StructureCompartment';
			}
			elif element.oclIsTypeOf(Package) then
				return switch {
					case (self.type = 'Name') 'Package_NameLabel';
					case (self.type = 'PackageContents') 'Package_PackagedElementCompartment';
				}
			elif element.oclIsTypeOf(Port) then
				return switch {
					case (self.type = 'Name') 'Port_NameLabel';
					
				}
			elif element.oclIsTypeOf(Interface) then
				return switch {
					case (self.type = 'Name') 'Interface_ClassifierNameLabel';
					case (self.type = 'AttributeCompartment') 'Interface_AttributeCompartment';
				case (self.type = 'ReceptionCompartment') 'Interface_OperationCompartment';
				}
			elif element.oclIsTypeOf(Model) then
				return switch {
					case (self.type = 'Name') 'Model_NameLabel';
					case (self.type = 'StructureCompartment') 'Model_PackagedElementCompartment';
				}
			elif element.oclIsTypeOf(Constraint) then
				return switch {
					case (self.type = 'Name') 'Constraint_NameLabel';
					
				}

		endif
	} else {
		return if element.oclIsTypeOf(Generalization) then
				return switch {
							
					case (self.type = 'KindLabel') 'Generalization_StereotypeLabel';
				}
			
			elif element.oclIsTypeOf(Substitution) then
				return switch {
					case (self.type='Name') 'Substitution_NameLabel';		
					case (self.type = 'NameLabel') 'Substitution_NameLabel';
					case (self.type = 'KindLabel') 'Substitution_StereotypeLabel';
				}
			
			elif element.oclIsTypeOf(Manifestation) then
				return switch {
					case (self.type='Name') 'Manifestation_NameLabel';		
					case (self.type = 'NameLabel') 'Manifestation_NameLabel';
					case (self.type = 'KindLabel') 'Manifestation_StereotypeLabel';
				}
			
			elif element.oclIsTypeOf(ComponentRealization) then
				return switch {
					case (self.type='Name') 'ComponentRealization_NameLabel';		
					case (self.type = 'NameLabel') 'ComponentRealization_NameLabel';
					case (self.type = 'KindLabel') 'ComponentRealization_StereotypeLabel';
				}
			
			elif element.oclIsTypeOf(Abstraction) then
				return switch {
					case (self.type='Name') 'Abstraction_NameLabel';		
					case (self.type = 'NameLabel') 'Abstraction_NameLabel';
					case (self.type = 'KindLabel') 'Abstraction_StereotypeLabel';
				}
			
			elif element.oclIsTypeOf(Dependency) then
				return switch {
					case (self.type='Name') 'Dependency_NameLabel';		
					case (self.type = 'NameLabel') 'Dependency_NameLabel';
					case (self.type = 'KindLabel') 'Dependency_StereotypeLabel';
				}
			
		endif
	} endif;
}


query View::getEdgeType(element : Element) : String {
	return
		if element.oclIsTypeOf(Usage) then 'Usage_Edge'
		elif element.oclIsTypeOf(InterfaceRealization) then 'InterfaceRealization_Edge'
		elif element.oclIsTypeOf(Generalization) then 'Generalization_Edge'
		elif element.oclIsTypeOf(Substitution) then 'Substitution_Edge'
		elif element.oclIsTypeOf(Manifestation) then 'Manifestation_Edge'
		elif element.oclIsTypeOf(ComponentRealization) then 'ComponentRealization_Edge'
		elif element.oclIsTypeOf(Abstraction) then 'Abstraction_Edge'
		elif element.oclIsTypeOf(Dependency) then 'Dependency_Edge'
		elif element.oclIsTypeOf(Dependency) then 'Dependency_BranchEdge'
		else self.fail()
	endif;
}

