/*****************************************************************************
 * Copyright (c) 2016 CEA LIST.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Vincent Lorenzo (CEA LIST) vincent.lorenzo@cea.fr - Initial API and implementation
 *****************************************************************************/
 
import org.eclipse.papyrus.migration.rhapsody.blackboxes.Rhapsody2PapyrusNotationBlackboxes;
import org.eclipse.papyrus.migration.rhapsody.blackboxes.rhapsody.RhapsodyHelper;

modeltype umlrhapsody "strict" uses 'http://www.eclipse.org/Papyrus/UMLRhapsody/1.0.0';
modeltype ecore "strict" uses 'http://www.eclipse.org/emf/2002/Ecore';

/**
* This file provides useful method for Rhapsody elements
*/
library RhapsodyUtils;

/**
* Return true if the Rhapsody IDiagram is a CGIClassChart
*/
query rhapsodymetamodel::IDiagram::isRhapsodyClassChart():Boolean{
	return self.graphicChart![GraphicChartType].oclIsTypeOf(CGIClassChart);
}

/**
* Return true if the IDiagram represents a UML Class Diagram without applied stereotypes
*/
query rhapsodymetamodel::IDiagram::isUMLPureClassDiagram():Boolean{
	return self.isRhapsodyClassChart() and self.Stereotypes->isEmpty();
}

/**
* Return true if the IDiagram is a CGIStateChart
*/
query rhapsodymetamodel::IDiagram::isRhapsodyStateChart():Boolean{
	return self.graphicChart![GraphicChartType].oclIsTypeOf(CGIStateChart);
}

/**
* Return true if the IDiagram represents a UML State Machine Diagram without applied stereotypes
*/
query rhapsodymetamodel::IDiagram::isUMLPureStateMachineDiagram():Boolean{
	return self.isRhapsodyStateChart() and self.Stereotypes->isEmpty();
}

/**
*
* This query returns true if the diagram is a User diagram
*/
query rhapsodymetamodel::IDiagram::isUserModelDiagram():Boolean{
//never write the next code, because if the user rename the default Package, it didn't work yet
//	var res:EResource:= self.getResource();
//	return res.toString().endsWith("Default.umlrhapsody'");

	return not (
		self.isRhapsodyPredefinedC_LibraryDiagram() or 
		self.isRhapsodyPredefinedCPP_LibraryDiagram() or
		self.isRhapsodySysMLLibraryDiagram() or
		self.isRhapsodyPredefinedTypeLibraryDiagram() or
		self.isRhapsodyMarteLibraryDiagram()
	);
}

/**
* Return true if the diagram comes from the Rhapsody C library
*/
helper umlrhapsody::IDiagram::isRhapsodyPredefinedC_LibraryDiagram():Boolean {
	var resourceName:String:=self[EObject].eResource()![EResource].toString();
	return resourceName.endsWith("PredefinedTypes.umlrhapsody'");
}

/**
* Return true if the diagram comes from the Rhapsody CPP library
*/
helper umlrhapsody::IDiagram::isRhapsodyPredefinedCPP_LibraryDiagram():Boolean {
	var resourceName:String:=self[EObject].eResource()![EResource].toString();
	return resourceName.endsWith("PredefinedTypesC++.umlrhapsody'");
} 

/**
* Return true if the diagram comes from the Rhapsody SysML library
*/
helper umlrhapsody::IDiagram::isRhapsodySysMLLibraryDiagram():Boolean {
	var resourceName:String:=self[EObject].eResource()![EResource].toString();
	return resourceName.endsWith("SysML.umlrhapsody'");
}

/**
* Return true if the diagram comes from the Rhapsody Predefined Type library
*/
helper umlrhapsody::IDiagram::isRhapsodyPredefinedTypeLibraryDiagram():Boolean {
	var resourceName:String:=self[EObject].eResource()![EResource].toString();
	return resourceName.endsWith("PredefinedTypes.umlrhapsody'");
}

/**
* Return true if the diagram comes from the Rhapsody Marte library
*/
helper umlrhapsody::IDiagram::isRhapsodyMarteLibraryDiagram():Boolean {
	var resourceName:String:=self[EObject].eResource()![EResource].toString();
	return resourceName.endsWith("MARTE.umlrhapsody'");
}

/**
* Returns true if the type come from a Rhapsody Library
*/
helper umlrhapsody::IType::isRhapsodyLibraryType():Boolean{
	return isComingFromARhapsodyLibraryResource(self.oclAsType(EObject));
}

/**
* Return true if the type is a Rhapsody C type
*/
helper umlrhapsody::IType::isRhapsodyPredefinedC_Type():Boolean {
	var resourceName:String:=self[EObject].eResource()![EResource].toString();
	return resourceName.endsWith("PredefinedTypesC.umlrhapsody'");
}

/**
* Return true if the type is a Rhapsody C++ type
*/
helper umlrhapsody::IType::isRhapsodyPredefinedCPP_Type():Boolean {
	var resourceName:String:=self[EObject].eResource()![EResource].toString();
	return resourceName.endsWith("PredefinedTypesC++.umlrhapsody'");
} 

/**
* Return true if the type is a Rhapsody SysML type
*/
helper umlrhapsody::IType::isRhapsodySysMLType():Boolean {
	var resourceName:String:=self[EObject].eResource()![EResource].toString();
	return resourceName.endsWith("SysML.umlrhapsody'");
}

/**
* Return true if the type is a Rhapsody Predefined Type
*/
helper umlrhapsody::IType::isRhapsodyPredefinedType():Boolean {
	var resourceName:String:=self[EObject].eResource()![EResource].toString();
	return resourceName.endsWith("PredefinedTypes.umlrhapsody'");
}


/**
* Returns the resource of the Rhapsody element
*/
query rhapsodymetamodel::IModelElement::getResource():EResource{
	return self![EObject].eResource()![EResource];
}

/**
* Returns the width for the element
*/

query umlrhapsody::CGIDiagramFrame::get_Width():Integer{
	var mpolygon:List(String):= self![CGIDiagramFrame].m_polygon->asList();
	var mtransform:List(String):= self![CGIDiagramFrame].m_transform->asList();
	return getWidth(mpolygon,mtransform);
}

/**
* Returns the heigth for the element
*/
query umlrhapsody::CGIDiagramFrame::get_Height():Integer{
	var mpolygon:List(String):= self![CGIDiagramFrame].m_polygon->asList();
	var mtransform:List(String):= self![CGIDiagramFrame].m_transform->asList();
	return getHeight(mpolygon,mtransform);
}


/**
* returns the X position
*/
query umlrhapsody::CGIDiagramFrame::get_X_Position():Integer{
	return self![CGIDiagramFrame].m_transform->at(5).get_int_from_String();
}

/**
* returns the Y position
*/
query umlrhapsody::CGIDiagramFrame::get_Y_Position():Integer{
		return self![CGIDiagramFrame].m_transform->at(6).get_int_from_String();
}


//TODO : we should check inheritance in a test of isStereotypedBy!
/**
* Returns true if the diagram is stereotyped by a stereotype with the name stereotypeName
*/ 
query rhapsodymetamodel::IDiagram::isStereotypedWith(stereotypeName:String):Boolean{
	return self.Stereotypes->selectByKind(IStereotype)->select( ste | ste.name=stereotypeName)->one(true);
}

/**
* Returns true if the IClass is stereotyped by a stereotype with the name stereotypeName
*/ 
query rhapsodymetamodel::IClass::isStereotypedWith(stereotypeName:String):Boolean{
	self.Stereotypes->selectByType(IStereotype)->forEach(ste){
		if(ste.name=stereotypeName){
			return true;
		};
		if(ste.getAllSuperStereotype()->select(s | s.name=stereotypeName)->one(true)){
			return true;
		}
	};
	return false;
}

/**
* Returns true if the IPart is stereotyped by a stereotype with the name stereotypeName
*/ 
query rhapsodymetamodel::IPart::isStereotypedWith(stereotypeName:String):Boolean{
	return self.Stereotypes->selectByKind(IStereotype)->select( ste | ste.name=stereotypeName)->one(true);
}

/**
* Returns true if the IType is stereotyped by a stereotype with the name stereotypeName
*/ 
query rhapsodymetamodel::IType::isStereotypedWith(stereotypeName:String):Boolean{
	return self.Stereotypes->selectByKind(IStereotype)->select( ste | ste.name=stereotypeName)->one(true);
}

/**
* Returns true if the IType is stereotyped by a stereotype with the name stereotypeName
*/ 
query rhapsodymetamodel::IObjectLink::isStereotypedWith(stereotypeName:String):Boolean{
	return self.Stereotypes->selectByKind(IStereotype)->select( ste | ste.name=stereotypeName)->one(true);
}
/**
* Convert a string to int
*/
query String::get_int_from_String():Integer{
	var intValue:Integer;
	if (self.asInteger().oclIsUndefined() or self.asInteger().oclIsInvalid()){
		intValue:=self.asFloat().round();
	}else{	
		intValue:=self.asInteger();
	};
	return intValue;
} 

/**
*
* Returns all super stereotypes of itself without itself
*/
query rhapsodymetamodel::IStereotype::getAllSuperStereotype():Set(IStereotype){
	var res:Set(IStereotype);
	self.Inheritances->forEach(i){
		if(i.dependsOn.oclIsTypeOf(IStereotype)){
			var ste:IStereotype:=i.dependsOn.oclAsType(IStereotype);
			res+=ste;
			res+=ste.getAllSuperStereotype();
		}
	};
	return res;
}

/**
*
* Return true if the IClass is a Rhapsody Interface
*/
query rhapsodymetamodel::IClass::isInterface():Boolean{
	return self.isStereotypedWith("Interface");
}

/**
*
* return true if the IRelation is a Rhapsody SysML Port (WARNING ISysMLPort comes from the Rhapsody metamodel, not from a Rhapsody profile!), 
* so this place is here and not in the SysML qvto file!
*/
query umlrhapsody::IRelation::isRhapsodyPort(): Boolean{
		return self.oclIsTypeOf(umlrhapsody::ISysMLPort);
}


/**
* Return true if the ISysMLPort is conjugated
*/
helper umlrhapsody::ISysMLPort::isConjugated(): Boolean{
	if(self.reversed="1"){
		return true;
	};
	return false;
}

/**
*
* Return true if the ISysML port is stereotyped by a stereoptype named stereotypeName 
*/
query umlrhapsody::ISysMLPort::isStereotypedWith(stereotypeName:String):Boolean{
	self.Stereotypes->selectByType(IStereotype)->forEach(ste){
		if(ste.name=stereotypeName){
			return true;
		};
		if(ste.getAllSuperStereotype()->select(s | s.name=stereotypeName)->one(true)){
			return true;
		}
	};
	return false;
}


