<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8">
	<title>Qompass</title>
	<link rel="StyleSheet"
        href="../sitestyle.css"
        type="text/css">
</head>
<body>
<h1>MARTE integration</h1>

The integration of MARTE is provided by the plugin org.eclipse.papyrus.qompass.designer.modellibs.marte. This plugin contains
<ul>
<li>A model libraries dedicated for MARTE. This library specifies
	<ol>
	<li>Additional FCM port kinds that correspond to MARTE port kinds (see below for a list of port kinds the chosen mapping).
	<li>A container rule that corresponds to the MARTE HLAM stereotype RtUnit (real-time unit). The rule in turn is based on the
		interception of invocations. The interceptor chooses an execution thread from a pool and evaluates the
		component's protocol state machine. [TODO: more description details]
	<li>A container rule that corresponds to the MARTE HLAM stereotype PpUnit (protected-passive unit). Only a single
		operation of a PpUnit may be executed at a certain moment. Thus, the rule is based on the interception of
		invocations and uses a mutex to block multiple access.
		Currently, each port uses its own interceptor and thus its own mutex, If operations of different ports
		should be protected from concurrent execution, a variant of the rule can be used. In this case, the interceptors use an additional
		container extension as shared mutex object.
	</ol> 
<li>A model listener that synchronizes MARTE and FCM elements automatically:
	<ol>
	<li>MARTE to FCM ports: Whenever the MARTE port changes, it assigns the associated FCM port.
	<li>MARTE RtUnit to FCM container rule: whenever the user applies the MARTE (HLAM) stereotype RtUnit, the
		model listener chooses the corresponding RtUnit container rule.
		If the RtUnit stereotype attribute isMain is true, the rule will make sure that the component inherits
		from the CStart component (part of the Qompass basic model library) defining a start port which is automatically
		called upon startup. It's up to the user to assure that there is a single component instance defining this port,
		there is however a validation rule that marks deployment plans defining more than one entry point (on a single
		node) with an error message.<br>
		Some of the RtUnit stereotype attributes are transformed into configuration values of the
		container extension, e.g. the number of threads in the pool is a configuration property of the
		RtUnit extension which is initialized from the corresponding RtUnit attribute.
	<li><li>MARTE PpUnit to FCM container rule:  whenever the user applies the MARTE (HLAM) stereotype PpUnit, the
		model listener chooses the corresponding PpUnit container rule. As said before there are two variants of
		the PpUnit rule. The user has to refine which rule to use on the FCM level (by default, the variant is
		chosen, i.e. operations from different ports are not protected from concurrent execution).
	</ol>
</ul>

The <b>semantics of a real-time unit (component)</b> depend largely on the model of computation. In case of
control applications for instance, a real-time component typically owns a single periodic thread. It gets its
input data at certain phase within the period and provides the output data at a later point. Interaction typcially
uses data flow ports.

In the Accord approach, a real-time component with client-server ports is reacting on external stimulus,
i.e. method calls. However, the called operation is not executed by the calling thread, but by a thread provided
by the infrastructure (middleware). It is thus a mixed approach, since the called operation may either be
<ol>
<li>&quot;classical&quot; operation calls with return/out parameters that block the calling thread until the
	computation has finished or
<li>operation calls without return/out parameters that are either long running or periodic. Due to these operations,
	the object reacts be active.
</ol>
 
a single exception: calls expecting a return value without RtSpecification are not ...
[well, what makes sense??? The fact that the object is active does not mean that it handles all calls. In typical
RT-systems, it means that the object has a single thread of control (typically peridoc) which is actively polling
for values ...
use depends on the RtFeature passed with the call: if no RtFeature is passed,the call is periodic
FCM as underlying profile. In case of ports, the FCM stereotype application is mandatory. Whenever
you change the MARTE port, the associated FCM port kind is automatically chosen. A convention in FCM is that
operations of a port can be called by a component or trigger a call within a component. Thus, an FCM port has two
derived attributes which show the provided and required interface respectively. In case of a MARTE GCM port,
the derived attributes are recalculated in function of the GCM stereotypes.

<h2><a name="ports">Supported ports</h2>

Currently, the following variants are supported:

<ol>
<li>
	ClientServer ports with an interface based specification with the limitation that only the first provided
	and only the first required interface are supported. This limitation is caused by question how to type
	references representing multiple interface. If multiple interfaces are required, you have to add a
	new interface that extends a set of existing ones.</p>

<li>
    ClientServer ports with a ClientServer specification. Providing an operation is technically quite different
    from requiring an interface. Thus, Qompass produces a pair of derived interfaces that
    contain only the provided and only the required operations, respectively.
    
<li>    
	ClientServer ports with a signal: not supported</p>
    
<li>
	Atomic FlowPorts typed with a data type. Qompass evaluates the direction attribute and produces a derived interface
	for production and/or consumption. In case of consumption, there are two options: either via pulling or via pushing.
	Currently, the user has to refine the variant to use on the FCM level (there is no evaluation of the isBehavior
	property).<br>
	In case of an attribute that is produced as well as consumed, two interfaces are generated - this case is
	handled by the FCM port kind that is also responsible for the flow specification below.
	
<li>
	FlowPorts typed with a flow specification. Qompass evaluates the direction attribute of each property and produces one
	or two derived interfaces (the latter, if two different directions exist in the flow specification). As for the
	atomic flow port, consumption may either be done via pulling or via pushing. 
</ol>           	

A different aspect is related to the real-time feature. If an operation provided by a port of an
RtUnit is called, the caller may want to pass a real-time feature (RTF, see MARTE standard, i.e. a deadline
or an arrival pattern including period length) together with the call. Thus, all GCM client/server ports
will provide a configuration attribute which adds an additional parameter of type RTF to the operation
signatures. In the moment, the RTF parameter is only avaible for the port kind "UseIntfWithRTF".
<p>

Some MARTE ports require a refinement for the implementation. The consumption of data can either be done in a pushing or polling way. The isBehavior attribute is evaluated during creation of FCM stereotypes:
If set to true, the component ports plays an active rule, i.e. polls for data. Currently, we FCM port kind is not re-evaluated
when the value of the isBehavior attribute changes.
           
</body>
</html>
