
--Author Manel Fredj-CEA LIST

import Converter.Utils.ConverterLibs;
--import Converter.Utils.ElementType;
--import Converter.Utils.VisualIds;
import VisualIDs;
import ElementType;
import NotationQueries;


modeltype di uses 'http://www.eclipse.org/papyrus/0.7.0/sashdi';
modeltype di2 uses 'http://www.papyrusuml.org/di2';
modeltype notation uses 'http://www.eclipse.org/gmf/runtime/1.0.2/notation';
modeltype ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype uml uses 'http://www.eclipse.org/uml2/2.1.0/UML';


transformation Transfo(in src : di2, out target1 : notation, out target2:di);


abstract mapping di2::GraphElement::Element2View() : notation::View
{
   --assign visibility attribute
	visible := self.isVisible;

	--assign the type
 	--type:=self.semanticModel.SeamnticModelBridge2Type();  	

 	--assign the fontcolor
	styles->select (e|e.oclIsTypeOf(notation::FontStyle))->forEach(style){
		style.oclAsType (notation::FontStyle).fontColor := self.fontColor.rgb2int()
	};		

	--element=self.getElement();	
	element := self.getElement().oclAsType(ecore::EObject);	
}

mapping di2::Diagram::diagram2diagram() : notation::Diagram inherits di2::GraphElement::Element2View
{
	--the id is set automatically
	--assign type
	type := self.getDiagramtype();
	--assign name
	name := self.name;

	--assign element
	measurementUnit := notation::MeasurementUnit::Pixel;

	--transform contained nodes
	children := setChildrenForDiagram(self.contained);

	-- transform contained edges
	--var edges : OrderedSet(notation::Edge) := self.contained->select(e|e.oclIsTypeOf(di2::GraphEdge))->forEach(e){ e.oclAsType(di2::GraphEdge).map GraphEdge2Edge()};
	edges := setEdgesForDiagram(self.contained);

	--Set Style of diagram
	styles := setStylesForDiagram();
}


mapping di2::GraphNode::Graphnode2Node() : notation::Node inherits di2::GraphElement::Element2View
{
}


mapping di2::GraphNode::Graphnode2Shape() : notation::Shape inherits di2::GraphNode::Graphnode2Node --di2::GraphElement::Element2View
{
	
	if (self.getElement().oclIsTypeOf(uml::Class)) then {
	
			type := VisualId_Class;
	}endif;
	
	if (self.getElement().oclIsTypeOf(uml::Comment)) then {
	
			type := VisualId_Comment;
	}endif;
	--switch {
	--	case (self.getElement().oclIsTypeOf(uml::Package)) 	type := VisualId_Package;
	--	case (self.oclIsTypeOf(uml::Enumeration)) 			type := VisualId_Enum;
	--	case (self.oclIsTypeOf(uml::DataType)) 				type := VisualId_DataType;
	--	case (self.oclIsTypeOf(uml::PrimitiveType)) 		type := VisualId_PrimitiveType;
	--	case (self.oclIsTypeOf(uml::Class)) 				type := VisualId_Class;
	--	case (self.oclIsTypeOf(uml::Interface)) 			type := VisualId_Interface;
	--	case (self.oclIsTypeOf(uml::Comment)) 				type := VisualId_Comment;
	--	else type := null;
	--};

	
	fontHeight="8";
	lineColor="0";
	
	layoutConstraint := object notation::Bounds {
		var size : notation::Size :=
			self.size.map dimension2Size();
		var location : notation::Location :=
			self.position.map point2Location();	
		x := location.x; 
		y := location.y; 
		width := size.width;
		height := size.height; 
	};
	--adding 3 eAnnotations (shared by all: Class, Comment, Package, interface, primitiveType, datatype,Enumeration)
	eAnnotations := setEAnnotations ();
	
	

	--switch {
	--	case (type = VisualId_Package) 		children := setChildrenForPackage(self);
	--										
	--	case (type = VisualId_Enum) 		children := setChildrenForEnum(self);
	--												
	--	case (type = VisualId_DataType) 	children := setChildrenForDataType(self);
															
	--	case (type = VisualId_PrimitiveType) children := setChildrenForPrimitiveType(self);	
													
	--	case (type = VisualId_Class) 		{
	--										--adding children
	--										children := setChildrenForClass(self);
	--										--adding style
	--										styles := setStylesForClass();
	--										};
	--	case (type = VisualId_Interface) 	children := setChildrenForInterface(self);	
																										
	--	case (type = VisualId_Comment) 		children := setChildrenForComment();
					
	--	else  children := null;
	--};
	
	if type = VisualId_Class then {
		--adding children
	  	children := setChildrenForClass(self);
		--adding style
	    styles := setStylesForClass();
	} endif;
	if type = VisualId_Comment then {
		--adding children
	  	children := setChildrenForComment();
		
	} endif;	

	--if type = VisualId_Enum then {
		
	--} endif;
	--if type = VisualId_PrimitiveType then {
			
	--} endif;
	--if type = VisualId_DataType then {
				
	--} endif;
	--if type = VisualId_Interface then {
			
	--} endif;
}

mapping di2::GraphEdge::GraphEdge2Edge() : notation::Connector inherits di2::GraphElement::Element2View
{
	-----------------------------------------------------------------------
	--under an Edge "association"
	-----------------------------------------------------------------------
	--In the case that we have an association we will have:
		--1 edge with a xmi:type:="notation:Connector", a geneerated Id, type= "4001", a target and a source that includes:
			-- 6 "children" typed with decoration nodes 
			-- 1 "styles
			-- 1 element
			-- 1 bendpoints
			--1 sourceAnchor
			--1targetAnchor
	 -----------------------------------------------------------------------	
  
	--setting the type and children
	if (self.getElement() !=null)then{
	
			if (self.getElement().isGeneralization()=true) then {
	 			type := VisualId_Edge_Generalization;
	 			--adding children
				children := setChildrenForGeneralization();
			} endif;
	
			if (self.getElement().isAssociation()=true) then {
		 		type := VisualId_Edge_Association;
		 		--adding children
				children := setChildrenForAssociation();
			} endif;
	 
			if (self.getElement().isDependency()=true) then {
	 			type := VisualId_Edge_Dependency;
			 	--adding children
				children := setChildrenForDependency();
			} endif;
			if (self.getElement().isRealization()=true) then {
			 	type := VisualId_Edge_Realization;
			 	--adding children
				children := setChildrenForRealization();
			} endif;
	
	}else{
		--it is  a link
		type := VisualId_Edge_Link;
		element:=null;
	} endif;
	--setting the source and target Anchors
	var anchors:OrderedSet (di2::GraphConnector):= self.anchor;
	anchors->forEach (gc) {
		log("the anchor is "+ gc.graphElement.repr());
		gc.graphElement;
	};			
	source := anchors->first().graphElement.oclAsType(di2::GraphNode).late resolveone(notation::Shape);
	target := anchors->last().graphElement.oclAsType(di2::GraphNode).late resolveone(notation::Shape);

	

	--adding style
	styles := setStyleForEdge();

	--adding element
		--already done in View

	--adding the bend points
	bendpoints := setBendpointsForEdge();

	--adding the source and target Anchor	
	sourceAnchor := setSourceAnchor();
	targetAnchor := setTargetAnchor();	
}

-------------------------------------------------------------------------------------------------------------------------
----------------------------------------               Mappings                   ---------------------------------------
-------------------------------------------------------------------------------------------------------------------------

mapping di2::Dimension::dimension2Size() : notation::Size
{
	width := self.dimensionGetWidth();
 	height := self.dimensionGetHeight();
}

-- transformation mapping dimension into location
mapping  di2::Point::point2Location() : notation::Location
{
	x := self.pointGetX();
	y := self.pointGetY();
}

-------------------------------------------------------------------------------------------------------------------------
----------------------------------------         Helpers  for notation            ---------------------------------------
-------------------------------------------------------------------------------------------------------------------------
--Helpers related to a diagram
--------------------------------
helper setStylesForDiagram() : OrderedSet (notation::Style)
{
	--<styles xmi:type="notation:DiagramStyle""/>

	var setofStyles : OrderedSet(notation::Style);
	var style := object notation::DiagramStyle{
		--the id is set automatically
	};

	setofStyles := OrderedSet{style};

	return setofStyles;	
}

--for a diagram
helper setChildrenForDiagram(in contained:OrderedSet(di2::DiagramElement)) : OrderedSet(notation::Node)
{
	var setOfChildren:OrderedSet(notation::Node); 
	var child:notation::Node;																
	contained ->forEach (node|node.oclIsTypeOf(di2::GraphNode)){
					child := node.oclAsType(di2::GraphNode).map Graphnode2Shape();
					setOfChildren += child;
	};								

	return setOfChildren;
}

--for a diagram
helper setEdgesForDiagram (in contained : OrderedSet(di2::DiagramElement)) : OrderedSet (notation::Edge)
{
	var setofEdges : OrderedSet(notation::Edge); 
	var edge : notation::Edge;																
	contained->forEach (node|node.oclIsTypeOf(di2::GraphEdge)) {
			edge := node.oclAsType(di2::GraphEdge).map GraphEdge2Edge();
			setofEdges += edge;
	};

	return setofEdges;
}

--Helpers related to a class
--[ansgar] seems to be not class specific (Package has the same)
--------------------------------






    
    
helper setEAnnotations() : OrderedSet (ecore::EAnnotation)
{	
	-- first eAnnotation	
	var eAnnot1 := object ecore::EAnnotation {
		--the id is set automatically
		--eAnnot1.eModelElement:=self.resolveone(notation::Node);
		source := "ShadowFigure";
		details := object ecore::EStringToStringMapEntry {
			key:="ShadowFigure_Value";
			value:="false";
		};
	};

	-- second annotation
	var eAnnot2 := object ecore::EAnnotation {
		--the id is set automatically
		source := "displayNameLabelIcon";
		details := object ecore::EStringToStringMapEntry {
			 key:="displayNameLabelIcon_value";
			 value:="false";
		};
	};
	
	-- third annotation	
	var eAnnot3 := object ecore::EAnnotation {	
		-- the id is set automatically	
		source := "QualifiedName";
		details := object ecore::EStringToStringMapEntry {
			key:="QualifiedNameDepth";
			value:="1000";
		};	
	};

	-- add the set of annotations to the node
	return OrderedSet {
		eAnnot1, eAnnot2, eAnnot3
	};
}

--for a class
--first argument is related to the contained operations which are integrated in the third child, i.e. the
--basic compartment typed 7018
helper setChildrenForClass (in node:di2::GraphNode) : OrderedSet(notation::Node)
{
   --<children xmi:type="notation:DecorationNode" type="5029"/>

    --<children xmi:type="notation:BasicCompartment"  type="7017">
    --  <styles xmi:type="notation:SortingStyle" />
    -- <styles xmi:type="notation:FilteringStyle"/>
    -- <layoutConstraint xmi:type="notation:Bounds" />
   --</children>

   -- <children xmi:type="notation:BasicCompartment" type="7018">
   --   <styles xmi:type="notation:SortingStyle" xmi:id="..."/>
   --   <styles xmi:type="notation:FilteringStyle" xmi:id=".../>
   --   <layoutConstraint xmi:type="notation:Bounds" xmi:id="..."/>
   -- </children>

   -- <children xmi:type="notation:BasicCompartment" xmi:id="..." type="7019">
   --   <styles xmi:type="notation:SortingStyle" xmi:id="..."/>
   --  <styles xmi:type="notation:FilteringStyle" xmi:id="..."/>
   --  <layoutConstraint xmi:type="notation:Bounds" xmi:id="..."/>
   -- </children>

	-- first child	
	var child1 := object notation::DecorationNode {
		type:=VisualId_Class_Label;
		--the id is set automatically
	};

	-- second child	
	var child2 := object notation::BasicCompartment {
		type:=VisualId_Class_Attributes;
		--the id is set automatically
		--set the operations
		children := setAttributesForClass(node);
		var style1 := object notation::SortingStyle {
			--the id is set automatically
		};
		var style2 := object notation::FilteringStyle {
			--the id is set automatically
		};
		styles := OrderedSet {
			style1, style2
		};
		layoutConstraint:=object notation::Bounds {};
	};
	
	-- third child	includes operations
	var child3 := object notation::BasicCompartment { 
		type := VisualId_Class_Operations;
		--the id is set automatically
		--set the operations
		children := setOperationsForClass(node);
		--set the styles
		var style1 := object notation::SortingStyle {
			--the id is set automatically
		};
		var style2 := object notation::FilteringStyle {
			--the id is set automatically
		};
		styles := OrderedSet {
			style1, style2
		};
		layoutConstraint := object notation::Bounds {};
	};

	-- fourth child	
	var child4 := object notation::BasicCompartment {
		type := VisualId_Class_UseCase;
		--the id is set automatically
		var style1 := object notation::SortingStyle {
			--the id is set automatically
		};
		var style2 := object notation::FilteringStyle {
			--the id is set automatically
		};
		styles := OrderedSet {
			style1,
			style2
		};
		layoutConstraint := object notation::Bounds {};		
	};

	--add the set of children to the node
	return OrderedSet {
		child1, child2, child3, child4
	};
}

--for a package
helper setChildrenForPackage (in node:di2::GraphNode) : OrderedSet(notation::Node)
{
    -- <children xmi:type="notation:DecorationNode" xmi:id="_i40XxNMjEd-9-ci4J3MfKg" type="5020"/>
    -- <children xmi:type="notation:DecorationNode" xmi:id="_i40XxdMjEd-9-ci4J3MfKg" type="7009">
    --  <layoutConstraint xmi:type="notation:Bounds" xmi:id="_i40XxtMjEd-9-ci4J3MfKg"/>
    -- </children>

	-- first child	
	var child1 := object notation::DecorationNode {
		type := VisualId_Package_Label;
		--the id is set automatically
	};

	-- second child	
	var child2 := object notation::DecorationNode {
		type := VisualId_Package_Label2;
		--the id is set automatically
	};

	--add the set of children to the node
	return OrderedSet {
		child1, child2
	};
}

--for a primitive type
helper setChildrenForPrimitiveType (in node:di2::GraphNode) : OrderedSet(notation::Node)
{
    -- <children xmi:type="notation:DecorationNode" xmi:id="_i40XxNMjEd-9-ci4J3MfKg" type="5020"/>
    -- <children xmi:type="notation:DecorationNode" xmi:id="_i40XxdMjEd-9-ci4J3MfKg" type="7009">
    --  <layoutConstraint xmi:type="notation:Bounds" xmi:id="_i40XxtMjEd-9-ci4J3MfKg"/>
    -- </children>

	-- first child	
	var child1 := object notation::DecorationNode {
		type := "5032";
		--the id is set automatically
	};

	--add the set of children to the node
	return OrderedSet {
		child1
	};
}

--for a data type
helper setChildrenForDataType (in node:di2::GraphNode) : OrderedSet(notation::Node)
{
    -- <children xmi:type="notation:DecorationNode" xmi:id="_i40XxNMjEd-9-ci4J3MfKg" type="5020"/>
    -- <children xmi:type="notation:DecorationNode" xmi:id="_i40XxdMjEd-9-ci4J3MfKg" type="7009">
    --  <layoutConstraint xmi:type="notation:Bounds" xmi:id="_i40XxtMjEd-9-ci4J3MfKg"/>
    -- </children>

	-- first child	
		-- first child	
	var child1 := object notation::DecorationNode {
		type := "5035";
		--the id is set automatically
	};

	-- second child	
	var child2 := object notation::BasicCompartment {
		type := "7020";
		--the id is set automatically
		--set the operations
		children := setAttributesForClass(node);
		var style1 := object notation::SortingStyle {
			--the id is set automatically
		};
		var style2 := object notation::FilteringStyle {
			--the id is set automatically
		};
		styles := OrderedSet {
			style1, style2
		};
		layoutConstraint:=object notation::Bounds {};
	};
	
	-- third child	includes operations
	var child3 := object notation::BasicCompartment { 
		type := "7021";
		--the id is set automatically
		--set the operations
		children := setOperationsForClass(node);
		--set the styles
		var style1 := object notation::SortingStyle {
			--the id is set automatically
		};
		var style2 := object notation::FilteringStyle {
			--the id is set automatically
		};
		styles := OrderedSet {
			style1, style2
		};
		layoutConstraint := object notation::Bounds {};
	};
	--add the set of children to the node
	return OrderedSet {
		child1, child2, child3
	};
}

--for an interface
helper setChildrenForInterface (in node:di2::GraphNode) : OrderedSet(notation::Node)
{
    -- <children xmi:type="notation:DecorationNode" xmi:id="_i40XxNMjEd-9-ci4J3MfKg" type="5020"/>
    -- <children xmi:type="notation:DecorationNode" xmi:id="_i40XxdMjEd-9-ci4J3MfKg" type="7009">
    --  <layoutConstraint xmi:type="notation:Bounds" xmi:id="_i40XxtMjEd-9-ci4J3MfKg"/>
    -- </children>

	-- first child	
		-- first child	
	var child1 := object notation::DecorationNode {
		type := "5011";
		--the id is set automatically
	};

	-- second child	
	var child2 := object notation::BasicCompartment {
		type := "7006";
		--the id is set automatically
		--set the operations
		children := setAttributesForClass(node);
		var style1 := object notation::SortingStyle {
			--the id is set automatically
		};
		var style2 := object notation::FilteringStyle {
			--the id is set automatically
		};
		styles := OrderedSet {
			style1, style2
		};
		layoutConstraint:=object notation::Bounds {};
	};
	
	-- third child	includes operations
	var child3 := object notation::BasicCompartment { 
		type := "7007";
		--the id is set automatically
		--set the operations
		children := setOperationsForClass(node);
		--set the styles
		var style1 := object notation::SortingStyle {
			--the id is set automatically
		};
		var style2 := object notation::FilteringStyle {
			--the id is set automatically
		};
		styles := OrderedSet {
			style1, style2
		};
		layoutConstraint := object notation::Bounds {};
	};
	
	-- third child	includes operations
	var child4 := object notation::BasicCompartment { 
		type := "7008";
		--the id is set automatically
		--set the operations
		--children := setOperationsForClass(node);
		--set the styles
		var style1 := object notation::SortingStyle {
			--the id is set automatically
		};
		var style2 := object notation::FilteringStyle {
			--the id is set automatically
		};
		styles := OrderedSet {
			style1, style2
		};
		layoutConstraint := object notation::Bounds {};
	};
	
	--add the set of children to the node
	return OrderedSet {
		child1, child2, child3, child4
	};
}

--for an enumeration
helper setChildrenForEnum (in node : di2::GraphNode) : OrderedSet(notation::Node)
{
    -- <children xmi:type="notation:DecorationNode" xmi:id="_WrbFYtP1Ed-9-ci4J3MfKg" type="5023"/>
    -- <children xmi:type="notation:BasicCompartment" xmi:id="_WrbFY9P1Ed-9-ci4J3MfKg" type="7015">
    --  <styles xmi:type="notation:SortingStyle" xmi:id="_WrbFZNP1Ed-9-ci4J3MfKg"/>
    --  <styles xmi:type="notation:FilteringStyle" xmi:id="_WrbFZdP1Ed-9-ci4J3MfKg"/>
    --  <layoutConstraint xmi:type="notation:Bounds" xmi:id="_WrbFZtP1Ed-9-ci4J3MfKg"/>
    --</children>

	-- first child	
	var child1 := object notation::DecorationNode {
		type := VisualId_Enum_Label;
		--the id is set automatically
	};

	-- second child	
	var child2 := object notation::BasicCompartment {
		type := VisualId_Enum_Literals;
		--set the literals
		children := getLiterals(node);
		var style1 := object notation::SortingStyle { };
		var style2 := object notation::FilteringStyle { };
		styles := OrderedSet {
			style1, style2
		};
		layoutConstraint := object notation::Bounds {};
		--the id is set automatically
	};

	--add the set of children to the node
	return OrderedSet {
		child1, child2
	};
}


helper setStylesForClass() : OrderedSet(notation::Style)
{
	var style:=object notation::HintedDiagramLinkStyle {
		--the id is set automatically
	};

	return OrderedSet{style};	
}

--in containedOp:OrderedSet(ecore::EObject)
helper setOperationsForClass(in node:di2::GraphNode): OrderedSet(notation::Node)
{	
	var operationsShape : OrderedSet(notation::Node); 
	var containedOp : OrderedSet(ecore::EObject) := node.getOperations();
	containedOp->forEach (operation) {
		var operationShape := object notation::Shape {
			--an operation is typed 3013
			type := VisualId_Operation;
			--fontHeight="8";
			--lineColor="0";        						 	
			element := operation;
        	layoutConstraint := object notation::Location{};        					
		};					

		operationsShape += operationShape;
	};

	return operationsShape;
}


--in containedAttr:OrderedSet (ecore::EObject)
helper setAttributesForClass(in node : di2::GraphNode) : OrderedSet(notation::Node)
{
	var attributesShape : OrderedSet(notation::Node); 
	var attributes : OrderedSet(ecore::EObject) := node.getProperties();
	attributes->forEach (attribute) {
		var attributeShape := object notation::Shape {
			-- an attribute is type 3012
			type := "3012";
			--fontName="Sans Serif";
			--lineColor="0";
        	element := attribute;
        	layoutConstraint := object notation::Location{};
		};
		attributesShape += attributeShape;
	};

	return attributesShape;
}

--in containedAttr:OrderedSet (ecore::EObject)
helper getLiterals(in node : di2::GraphNode) : OrderedSet(notation::Node)
{
	var enumLiteralsShape : OrderedSet(notation::Node); 
	var enumLiterals : OrderedSet(ecore::EObject) := node.getEnumLiterals();
	enumLiterals->forEach (enumLiteral) {
		var enumLiteralShape := object notation::Shape {
			-- an attribute is type 3017
			type := "3017";
			--fontName="Sans Serif";
			--lineColor="0";
        	element := enumLiteral;
        	layoutConstraint := object notation::Location{};
		};
		enumLiteralsShape += enumLiteralShape;
	};
									
									
	return enumLiteralsShape;
}


--Helpers related to a Comment
--------------------------------

helper setChildrenForComment () : OrderedSet(notation::Node)
{
 
	--  <children xmi:type="notation:DecorationNode" xmi:id="_OVAHGNhVEd-Fo-h2aSJB1A" type="5038"/>
	var child1 := object notation::DecorationNode {
		type:=VisualId_Comment_Child;
		
	};
	return OrderedSet {child1};
}

    

    
    
    
    
--Helpers related to an Edge
--------------------------------


--generic helper for an edge with two children
--takes as input the visual ids of the the two children

helper setChildrenForEdge2Children(in VisualId1: String, in VisualId2: String): OrderedSet(notation::Node)
{    
	
 
	var child1 := object notation::DecorationNode {
		--the id is set automatically
		type := VisualId1;
		layoutConstraint := object notation::Location {
			y := 40;
		};
	};
	--second child	
	var child2 :=object notation::DecorationNode {
		--the id is set automatically
		type := VisualId2;
		layoutConstraint := object notation::Location {
			y := 60;
		};
	};
	return OrderedSet {child1,child2};
}
helper setChildrenForRealization(): OrderedSet(notation::Node)
{    
	-- <children xmi:type="notation:DecorationNode"  type="6012">
    --   <layoutConstraint xmi:type="notation:Location"  y="40"/>
    -- </children>
    --  <children xmi:type="notation:DecorationNode" type="6013">
    --    <layoutConstraint xmi:type="notation:Location" y="60"/>
    -- </children>
 	return setChildrenForEdge2Children(VisualId_DecoNodeRealiz1, VisualId_DecoNodeRealiz2);
	
}

helper setChildrenForDependency(): OrderedSet(notation::Node)
{    
	  --<children xmi:type="notation:DecorationNode" type="6026">
      --  <layoutConstraint xmi:type="notation:Location" y="40"/>
     -- </children>
     -- <children xmi:type="notation:DecorationNode" type="6027">
     --   <layoutConstraint xmi:type="notation:Location" y="60"/>
     -- </children>
 	return setChildrenForEdge2Children(VisualId_DecoNodeDepend1, VisualId_DecoNodeDepend2);
	
}

helper setChildrenForGeneralization(): OrderedSet(notation::Node)
{    
	 --<children xmi:type="notation:DecorationNode"  type="6007">
      --  <layoutConstraint xmi:type="notation:Location"  y="40"/>
     --</children>
 
	var child1 := object notation::DecorationNode {
		--the id is set automatically
		type := VisualId_DecoNodeGeneralization;
		layoutConstraint := object notation::Location {
			y := 40;
		};
	};
	
	return OrderedSet {child1};
}
helper setChildrenForAssociation(): OrderedSet(notation::Node)
{
	--<children xmi:type="notation:DecorationNode" type="6001">
    --    <layoutConstraint xmi:type="notation:Location" y="-20"/>
    -- </children>
    
    -- <children xmi:type="notation:DecorationNode" type="6002">
    --    <layoutConstraint xmi:type="notation:Location" y="20"/>
    -- </children>
    
    --<children xmi:type="notation:DecorationNode" 4fE2FhZBg" type="6003">
    --    <layoutConstraint xmi:type="notation:Location"  y="-20"/>
    -- </children>
    
    -- <children xmi:type="notation:DecorationNode" type="6005">
    --    <layoutConstraint xmi:type="notation:Location" y="20"/>
    -- </children>
    
    -- <children xmi:type="notation:DecorationNode" g" type="6033">
    --    <layoutConstraint xmi:type="notation:Location" y="20"/>
    -- </children>
    
    -- <children xmi:type="notation:DecorationNode" type="6034">
    --    <layoutConstraint xmi:type="notation:Location" y="-20"/>
    -- </children>   
    
	--first child	
	var child1 := object notation::DecorationNode {
		--the id is set automatically
		type := VisualId_DecoNode1;
		layoutConstraint := object notation::Location {
			y := -20;
		};
	};

	--second child	
	var child2 :=object notation::DecorationNode {
		--the id is set automatically
		type := VisualId_DecoNode2;
		layoutConstraint := object notation::Location {
			y := 20;
		};
	};
	
	--third child	includes operations
	var child3 := object  notation::DecorationNode {
		--the id is set automatically
		type := VisualId_DecoNode3;
		layoutConstraint := object notation::Location {
			y := -20;
		};
	};

	--fourth child	
	var child4 := object  notation::DecorationNode {
		--the id is set automatically
		type := VisualId_DecoNode4;
		layoutConstraint := object notation::Location {
			y := 20;
		};
	};
	
	--fifth child	
	var child5 := object notation::DecorationNode {
		--the id is set automatically
		type := VisualId_DecoNode5;
		layoutConstraint := object notation::Location{
			y := 20;
		};
	};
						
	--sixth child	
	var child6 := object notation::DecorationNode {
		--the id is set automatically
		type := VisualId_DecoNode6;
		layoutConstraint := object notation::Location {
			y := -20;
		};
	};					
						
	--add the set of children to the node
	return OrderedSet {
		child1, child2, child3, child4, child5, child6
	};
}


helper setStyleForEdge() : OrderedSet(notation::Style)
{
	--<styles xmi:type="notation:FontStyle" fontName="Sans Serif"/>
	var style := object notation::FontStyle {
		--the id is set automatically
		--fontName="Sans Serif";
	};

	return OrderedSet{style};
}

helper setSourceAnchor() : notation::Anchor
{
	return object notation::IdentityAnchor { };
}


helper setTargetAnchor():notation::Anchor
{
	return object notation::IdentityAnchor { };
}


helper setBendpointsForEdge():notation::RelativeBendpoints
{
	--<bendpoints xmi:type="notation:RelativeBendpoints" points="[-7, -2, 323, 58]$[-282, -65, 48, -5]"/>
	// var pts : notation::RelativeBendpointList;
 	// var bendpoints:=object notation::RelativeBendpoints { };
	var bendpoints := createBendpoints().oclAsType (notation::RelativeBendpoints);
	
	return bendpoints;
}