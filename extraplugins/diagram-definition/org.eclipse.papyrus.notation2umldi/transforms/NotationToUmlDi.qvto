/**
 * Copyright (c) 2014 CEA LIST.
 *  
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 * Contributors:
 *  CEA LIST - Initial API and implementation
 */
import NotationIds;

modeltype DC uses "http://www.omg.org/spec/DD/20110901/DC";
modeltype DI uses "http://www.omg.org/spec/DD/20110901/DI";
modeltype UMLDI uses "http://www.omg.org/spec/UML/20131001/UMLDI";
modeltype Notation uses "http://www.eclipse.org/gmf/runtime/1.0.2/notation";
modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";
modeltype Style uses "http://www.eclipse.org/papyrus/infra/viewpoints/policy/style";
modeltype Configuration uses "http://www.eclipse.org/papyrus/infra/viewpoints/configuration";
	
transformation NotationToUmlDi(in notation : Notation, out UMLDI);

main() {
	notation.rootObjects()[Notation::Diagram]->sortedBy(name)->forEach(diagram) {
		renderDiagram(diagram);
		diagram.map toUmlDiagram();
		disposeDiagram(diagram);
	}
}

mapping Notation::Diagram::toUmlDiagram() : UMLDI::UmlDiagram
	disjuncts Notation::Diagram::diagramToPackageDiagram,
			  Notation::Diagram::diagramToClassDiagram,
			  Notation::Diagram::diagramToComponentDiagram,
			  Notation::Diagram::diagramToCompositeStructureDiagram,
			  Notation::Diagram::diagramToDeploymentDiagram,
			  Notation::Diagram::diagramToProfileDiagram,
			  Notation::Diagram::diagramToUseCaseDiagram,
			  Notation::Diagram::diagramToStateMachineDiagram,
			  Notation::Diagram::diagramToActivityDiagram,
			  Notation::Diagram::diagramToSequenceDiagram,
			  Notation::Diagram::diagramToCommunicationDiagram,
			  Notation::Diagram::diagramToTimingDiagram,
			  Notation::Diagram::diagramToInteractionOverviewDiagram;

abstract mapping Notation::View::viewToUmlDiagramElement() : UMLDI::UmlDiagramElement 
{
	umlModelElement := self.element.oclAsType(UML::Element);
}

abstract mapping Notation::Diagram::diagramToUmlDiagram() : UMLDI::UmlDiagram 
	inherits Notation::View::viewToUmlDiagramElement
{
	name := self.name;
	topUmlDiagramElement += self.visibleChildren()->map toTopUmlDiagramElement();	
	topUmlDiagramElement += self.visibleEdges()->map toTopUmlDiagramElement();	
}

mapping Notation::Diagram::diagramToClassDiagram() : UMLDI::ClassDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = classDiagramType };

mapping Notation::Diagram::diagramToPackageDiagram() : UMLDI::PackageDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = classDiagramType and 
		   self.styles![Style::PapyrusViewStyle]._configuration.name = packageDiagramType };

mapping Notation::Diagram::diagramToProfileDiagram() : UMLDI::ProfileDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = profileDiagramType };

mapping Notation::Diagram::diagramToComponentDiagram() : UMLDI::ComponentDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = componentDiagramType };

mapping Notation::Diagram::diagramToCompositeStructureDiagram() : UMLDI::CompositeStructureDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = compositeStructureDiagramType };

mapping Notation::Diagram::diagramToDeploymentDiagram() : UMLDI::DeploymentDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = deploymentDiagramType };

mapping Notation::Diagram::diagramToUseCaseDiagram() : UMLDI::UseCaseDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = useCaseDiagramType };

mapping Notation::Diagram::diagramToStateMachineDiagram() : UMLDI::StateMachineDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = stateMachineDiagramType };

mapping Notation::Diagram::diagramToActivityDiagram() : UMLDI::ActivityDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = activityDiagramType };

mapping Notation::Diagram::diagramToSequenceDiagram() : UMLDI::SequenceDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = sequenceDiagramType };

mapping Notation::Diagram::diagramToCommunicationDiagram() : UMLDI::CommunicationDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = communicationDiagramType };

mapping Notation::Diagram::diagramToTimingDiagram() : UMLDI::TimingDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = timingDiagramType };

mapping Notation::Diagram::diagramToInteractionOverviewDiagram() : UMLDI::InteractionOverviewDiagram 
	inherits Notation::Diagram::diagramToUmlDiagram
	when { getViewType(self) = interactionOverviewDiagramType };

//-------------------------------------------------------------------------------------

mapping Notation::View::toTopUmlDiagramElement() : UMLDI::TopUmlDiagramElement {
	init {
		// do nothing
	}
}

//-------------------------------------------------------------------------------------

mapping Notation::Shape::toTopUmlDiagramElement() : UMLDI::TopUmlDiagramElement
	disjuncts Notation::Shape::shapeToRegionShape,
			  Notation::Shape::shapeToStateShape,
			  Notation::Shape::shapeToPseudostateShape,
			  Notation::Shape::shapeToAssociationClassShape,
			  Notation::Shape::shapeToUseCaseShape,
			  Notation::Shape::shapeToActorShape,
			  Notation::Shape::shapeToComponentShape,
			  Notation::Shape::shapeToStereotypeShape,
			  Notation::Shape::shapeToProtocolStateMachineShape,
			  Notation::Shape::shapeToConnectionPointReferenceShape,
			  Notation::Shape::shapeToStateMachineShape,
			  Notation::Shape::shapeToActivityShape,
			  Notation::Shape::shapeToInteractionShape,
			  Notation::Shape::shapeToFunctionBehaviorShape,
			  Notation::Shape::shapeToOpaqueBehaviorShape,
			  Notation::Shape::shapeToExecutionEnvironmentShape,
			  Notation::Shape::shapeToDeviceShape,
			  Notation::Shape::shapeToNodeShape,
			  Notation::Shape::shapeToClassShape,
			  Notation::Shape::shapeToAssociationShape,
			  Notation::Shape::shapeToDependencyShape,
			  Notation::Shape::shapeToInterfaceShape,
			  Notation::Shape::shapeToPrimitiveTypeShape,
			  Notation::Shape::shapeToEnumerationShape,
			  Notation::Shape::shapeToDataTypeShape,
			  Notation::Shape::shapeToDeploymentSpecificationShape,
			  Notation::Shape::shapeToArtifactShape,
			  Notation::Shape::shapeToSignalShape,
			  Notation::Shape::shapeToCollaborationShape,
			  Notation::Shape::shapeToCollaborationUseShape,
			  Notation::Shape::shapeToPropertyShape,
			  Notation::Shape::shapeToProfileShape,
			  Notation::Shape::shapeToModelShape,
			  Notation::Shape::shapeToPackageShape,
			  Notation::Shape::shapeToConstraintShape,
			  Notation::Shape::shapeToCommentShape,
			  Notation::Shape::shapeToInformationItemShape,
			  Notation::Shape::shapeToInstanceSpecificationShape,
			  Notation::Shape::shapeToTimeObservationShape,
			  Notation::Shape::shapeToDurationObservationShape,
			  Notation::Shape::shapeToPortShape,
			  Notation::Shape::shapeToExpansionRegionShape,
			  Notation::Shape::shapeToStructuredActivityNodeShape,
			  Notation::Shape::shapeToActionShape,
			  Notation::Shape::shapeToActivityParameterNodeShape,
			  Notation::Shape::shapeToPinShape,
			  Notation::Shape::shapeToExpansionNodeShape,
			  Notation::Shape::shapeToObjectNodeShape,
			  Notation::Shape::shapeToActivityNodeShape,
			  Notation::Shape::shapeToActivityPartitionShape,
			  Notation::Shape::shapeToActivityGroupShape;

abstract mapping Notation::Shape::shapeToUmlShape() : UMLDI::UmlShape
	inherits Notation::View::viewToUmlDiagramElement
{
	bounds := self.bounds();
	localUmlStyle := object UMLDI::UmlStyle {
		fontName := self.fontName;
		fontSize := self.fontHeight;
	}
}

abstract mapping Notation::Shape::shapeToElementShape() : UMLDI::ElementShape
	inherits Notation::Shape::shapeToUmlShape
{
	var label = self.visibleChildren()->selectOne(c|getViewType(c) = nameLabelType);
	mainLabel := label.oclAsType(Notation::DecorationNode).map nodeToMainLabel();
}

abstract mapping Notation::Shape::shapeToElementWithBodyShape() : UMLDI::ElementWithBodyShape
	inherits Notation::Shape::shapeToElementShape
{
	var label = self.visibleChildren()->selectOne(c|getViewType(c) = bodyLabelType);
	bodyLabel := label.oclAsType(Notation::DecorationNode).map nodeToBodyLabel();
}

abstract mapping Notation::Shape::shapeToTemplatableElementShape() : UMLDI::TemplateableElementShape
	inherits Notation::Shape::shapeToElementShape
{
	var signature = self.visibleChildren()->selectOne(element.oclIsKindOf(UML::TemplateSignature));
	if (signature->notEmpty()) {
		var compartment = signature.visibleChildren()->selectOne(c|getViewType(c) = templateParameterCompartmentType);
		templateParameterCompartment := compartment.map nodeToTemplateParameterCompartment();
	}
}

abstract mapping Notation::Shape::shapeToElementWithPackagedElementsShape() : UMLDI::ElementWithPackagedElementsShape
	inherits Notation::Shape::shapeToElementShape
{
	var compartment = self.visibleChildren()->selectOne(c|packagedElementCompartmentType->includes(getViewType(c)));
	packagedElementCompartment := compartment.map nodeToPackagedElementCompartment();
}

abstract mapping Notation::Shape::shapeToElementWithInternalStructureShape() : UMLDI::ElementWithInternalStructureShape
	inherits Notation::Shape::shapeToElementShape
{
	var compartment = self.visibleChildren()->selectOne(c|internalStructueCompartmentType->includes(getViewType(c)));
	internalStructureCompartment := compartment.map nodeToInternalStructureCompartment();
}

abstract mapping Notation::Shape::shapeToElementWithPortsShape() : UMLDI::ElementWithPortsShape
	inherits Notation::Shape::shapeToElementWithInternalStructureShape
{
	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::Port));
	portShape += children.oclAsType(Notation::Shape)->map shapeToPortShape();	
}

abstract mapping Notation::Shape::shapeToClassifierShape() : UMLDI::ClassifierShape
	inherits Notation::Shape::shapeToTemplatableElementShape
{
	useClassifierNotation := customShapeType->excludes(getViewType(self));
	
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = useCaseCompartmentType);
	ownedUseCaseCompartment := compartment.map nodeToOwnedUseCaseCompartment();
}

abstract mapping Notation::Shape::shapeToClassifierWithAttributesShape() : UMLDI::ClassifierWithAttributesShape
	inherits Notation::Shape::shapeToClassifierShape
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = attributeCompartmentType);
	attributeCompartment := compartment.map nodeToAttributeCompartment();
}

abstract mapping Notation::Shape::shapeToClassifierWithOperationsShape() : UMLDI::ClassifierWithOperationsShape
	inherits Notation::Shape::shapeToClassifierWithAttributesShape
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = operationCompartmentType);
	if (compartment.visibleChildren()->isEmpty() or compartment.visibleChildren()->forAll(element.oclIsKindOf(UML::Operation))) {
		operationCompartment := compartment.map nodeToOperationCompartment()
	};
}

abstract mapping Notation::Shape::shapeToDeploymentTargetShape() : UMLDI::DeploymentTargetShape
	inherits Notation::Shape::shapeToElementShape;

abstract mapping Notation::Shape::shapeToClassifierWithNestedClassifiersShape() : UMLDI::ClassifierWithNestedClassifiersShape
	inherits Notation::Shape::shapeToClassifierWithReceptionsShape
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = nestedClassifierCompartmentType);
	nestedClassifierCompartment := compartment.map nodeToNestedClassifierCompartment();
}

abstract mapping Notation::Shape::shapeToClassifierWithReceptionsShape() : UMLDI::ClassifierWithReceptionsShape 
	inherits  Notation::Shape::shapeToClassifierWithOperationsShape
{
	var compartment : Notation::Node = self.visibleChildren()->selectOne(c|getViewType(c) = operationCompartmentType);
	if (compartment.visibleChildren()->notEmpty() and compartment.visibleChildren()->forAll(element.oclIsKindOf(UML::Reception))) {
		receptionCompartment := compartment.map nodeToReceptionCompartment()
	};
}

abstract mapping Notation::Shape::shapeToBehavioredClassifierShape() : UMLDI::BehavioredClassifierShape 
	inherits  Notation::Shape::shapeToClassifierShape
{
}

abstract mapping Notation::Shape::shapeToBaseStateShape() : UMLDI::BaseStateShape 
	inherits  Notation::Shape::shapeToElementShape
{
	var compartment = self.visibleChildren()->selectOne(c|regionCompartmentType->includes(getViewType(c)));
	regionCompartment := compartment.map nodeToRegionCompartment();

	var children = self.visibleChildren()->select(isConnectionPoint());
	connectionPointShape += children.oclAsType(Notation::Shape)->map shapeToPseudostateShape();	
}

query Notation::Node::isConnectionPoint() : Boolean {
	return self.element.oclIsKindOf(UML::Pseudostate) and self.element.oclAsType(UML::Pseudostate)->
		exists(kind = UML::PseudostateKind::entryPoint or kind = UML::PseudostateKind::exitPoint);
}

mapping Notation::Shape::shapeToClassShape() : UMLDI::ClassShape
	inherits Notation::Shape::shapeToClassifierWithNestedClassifiersShape, 
	         Notation::Shape::shapeToElementWithPortsShape,
	         Notation::Shape::shapeToBehavioredClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Class) };

mapping Notation::Shape::shapeToCollaborationShape() : UMLDI::CollaborationShape
	inherits Notation::Shape::shapeToClassifierWithOperationsShape, 
	 		 Notation::Shape::shapeToElementWithInternalStructureShape,
	 		 Notation::Shape::shapeToBehavioredClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Collaboration) };

mapping Notation::Shape::shapeToUseCaseShape() : UMLDI::UseCaseShape
	 inherits Notation::Shape::shapeToBehavioredClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::UseCase) }
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = extensionPointCompartmentType);
	extensionPointCompartment := compartment.map nodeToExtensionPointCompartment();
}

mapping Notation::Shape::shapeToActorShape() : UMLDI::ActorShape
	 inherits Notation::Shape::shapeToBehavioredClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Actor) };

mapping Notation::Shape::shapeToCollaborationUseShape() : UMLDI::CollaborationUseShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::CollaborationUse) };

mapping Notation::Shape::shapeToPropertyShape() : UMLDI::PropertyShape
	inherits Notation::Shape::shapeToElementWithPortsShape, Notation::Shape::shapeToDeploymentTargetShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Property) and getViewType(self) <> roleBindingShapeType};

mapping Notation::Shape::shapeToComponentShape() : UMLDI::ComponentShape
	inherits Notation::Shape::shapeToClassShape, Notation::Shape::shapeToElementWithPackagedElementsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Component) };

mapping Notation::Shape::shapeToAssociationClassShape() : UMLDI::AssociationClassShape
	inherits Notation::Shape::shapeToClassShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::AssociationClass) };

mapping Notation::Shape::shapeToInformationItemShape() : UMLDI::InformationItemShape
	inherits Notation::Shape::shapeToClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InformationItem) };

mapping Notation::Shape::shapeToInterfaceShape() : UMLDI::InterfaceShape
	inherits Notation::Shape::shapeToClassifierWithNestedClassifiersShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Interface) };
	
mapping Notation::Shape::shapeToDataTypeShape() : UMLDI::DataTypeShape
	inherits Notation::Shape::shapeToClassifierWithOperationsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::DataType) };

mapping Notation::Shape::shapeToArtifactShape() : UMLDI::ArtifactShape
	inherits Notation::Shape::shapeToClassifierWithOperationsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Artifact) }
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = nestedArtifactCompartmentType);
	nestedArtifactCompartment := compartment.map nodeToNestedArtifactCompartment();
}

mapping Notation::Shape::shapeToDeploymentSpecificationShape() : UMLDI::DeploymentSpecificationShape
	inherits Notation::Shape::shapeToArtifactShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::DeploymentSpecification) };

mapping Notation::Shape::shapeToTimeObservationShape() : UMLDI::TimeObservationShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::TimeObservation) };

mapping Notation::Shape::shapeToDurationObservationShape() : UMLDI::DurationObservationShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::DurationObservation) };

mapping Notation::Shape::shapeToPrimitiveTypeShape() : UMLDI::PrimitiveTypeShape
	inherits Notation::Shape::shapeToDataTypeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::PrimitiveType) };

mapping Notation::Shape::shapeToSignalShape() : UMLDI::SignalShape
	inherits Notation::Shape::shapeToClassifierWithAttributesShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Signal) };

mapping Notation::Shape::shapeToEnumerationShape() : UMLDI::EnumerationShape
	inherits Notation::Shape::shapeToClassifierShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Enumeration) }
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = literalCompartmentType);
	literalCompartment := compartment.map nodeToLiteralCompartment();
}

mapping Notation::Shape::shapeToPackageShape() : UMLDI::PackageShape
	inherits Notation::Shape::shapeToTemplatableElementShape, Notation::Shape::shapeToElementWithPackagedElementsShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Package) };

mapping Notation::Shape::shapeToModelShape() : UMLDI::ModelShape
	inherits Notation::Shape::shapeToPackageShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Model) };

mapping Notation::Shape::shapeToProfileShape() : UMLDI::ProfileShape
	inherits Notation::Shape::shapeToPackageShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Profile) };

mapping Notation::Shape::shapeToConstraintShape() : UMLDI::ConstraintShape
	inherits Notation::Shape::shapeToElementWithBodyShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Constraint) };

mapping Notation::Shape::shapeToCommentShape() : UMLDI::CommentShape
	inherits Notation::Shape::shapeToElementWithBodyShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Comment) };

mapping Notation::Shape::shapeToInstanceSpecificationShape() : UMLDI::InstanceSpecificationShape
	inherits Notation::Shape::shapeToDeploymentTargetShape 
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InstanceSpecification) }
{
	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = slotCompartmentType);
	slotCompartment := compartment.map nodeToSlotCompartment();
}

mapping Notation::Shape::shapeToAssociationShape() : UMLDI::AssociationShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Association) }
{
	useClassifierNotation := false;
}

mapping Notation::Shape::shapeToDependencyShape() : UMLDI::DependencyShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Dependency) }
{
	bounds.width := 4;		
	bounds.height := 4;		
}

mapping Notation::Shape::shapeToPortShape() : UMLDI::PortShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Port) };

mapping Notation::Shape::shapeToStereotypeShape() : UMLDI::StereotypeShape
	inherits Notation::Shape::shapeToClassShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Stereotype) };

mapping Notation::Shape::shapeToNodeShape() : UMLDI::NodeShape
	inherits Notation::Shape::shapeToClassShape, Notation::Shape::shapeToDeploymentTargetShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Node) }
{
	var compartment = self.visibleChildren()->selectOne(c|nestedNodeCompartmentType->includes(getViewType(c)));
	if (compartment->notEmpty()) {
		if (compartment.visibleChildren()->isEmpty())
			nestedNodeCompartment := compartment.map nodeToNestedNodeCompartment()
		else if (compartment.visibleChildren()->forAll(c|c.element.oclIsKindOf(UML::Node)))
			nestedNodeCompartment := compartment.map nodeToNestedNodeCompartment()
		else if (compartment.visibleChildren()->forAll(c|c.element.oclIsKindOf(UML::Artifact)))
			nestedClassifierCompartment := compartment.map nodeToNestedClassifierCompartment()
	};
}

mapping Notation::Shape::shapeToDeviceShape() : UMLDI::DeviceShape
	inherits Notation::Shape::shapeToNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Device) };

mapping Notation::Shape::shapeToExecutionEnvironmentShape() : UMLDI::ExecutionEnvironmentShape
	inherits Notation::Shape::shapeToNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ExecutionEnvironment) };

mapping Notation::Shape::shapeToActivityShape() : UMLDI::ActivityShape
	inherits Notation::Shape::shapeToClassShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Activity) }
{
	result.mainLabel.bounds.x := result.bounds.x + 1;
	result.mainLabel.bounds.y := result.mainLabel.bounds.y + 1;

	var compartment := self.visibleChildren()->selectOne(c|getViewType(c) = parameterCompartmentType);
	parameterCompartment := compartment.map nodeToParameterCompartment();

	compartment := self.visibleChildren()->selectOne(c|getViewType(c) = preConditionCompartmentType);
	preConditionCompartment := compartment.map nodeToPreConditionCompartment();

	compartment := self.visibleChildren()->selectOne(c|getViewType(c) = postConditionCompartmentType);
	postConditionCompartment := compartment.map nodeToPostConditionCompartment();

	compartment := self.visibleChildren()->selectOne(c|contentCompartmentType->includes(getViewType(c)));
	if compartment.children.element->exists(oclIsKindOf(Activity)) and not compartment.children.element->exists(oclIsKindOf(ActivityNode)) then
		ownedBehaviorCompartment := compartment.map nodeToOwnedBehaviorCompartment()
	else
		contentCompartment := compartment.map nodeToContentCompartment()
	endif;

	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::ActivityParameterNode));
	activityParameterNodeShape += children.oclAsType(Notation::Shape)->map shapeToActivityParameterNodeShape();	
}

mapping Notation::Shape::shapeToInteractionShape() : UMLDI::InteractionShape
	inherits Notation::Shape::shapeToClassShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Interaction) };

mapping Notation::Shape::shapeToStateMachineShape() : UMLDI::StateMachineShape
	inherits Notation::Shape::shapeToClassShape, Notation::Shape::shapeToBaseStateShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::StateMachine) }
{
	result.mainLabel.bounds.x := result.bounds.x + 1;
	result.mainLabel.bounds.y := result.mainLabel.bounds.y + 1;
}

mapping Notation::Shape::shapeToProtocolStateMachineShape() : UMLDI::ProtocolStateMachineShape
	inherits Notation::Shape::shapeToStateMachineShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ProtocolStateMachine) };

mapping Notation::Shape::shapeToOpaqueBehaviorShape() : UMLDI::OpaqueBehaviorShape
	inherits Notation::Shape::shapeToClassShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::OpaqueBehavior) };

mapping Notation::Shape::shapeToFunctionBehaviorShape() : UMLDI::FunctionBehaviorShape
	inherits Notation::Shape::shapeToOpaqueBehaviorShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::FunctionBehavior) };

mapping Notation::Shape::shapeToPseudostateShape() : UMLDI::PseudostateShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Pseudostate) };

mapping Notation::Shape::shapeToRegionShape() : UMLDI::RegionShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Region) }
{
	var key : String = self.eAnnotations->select(source='RegionAnnotationKey').details->at(1).value;
	key.characters()->forEach(c) {
		placement += switch {
			case (c = 'T') UMLDI::Placement::top; 
			case (c = 'R') UMLDI::Placement::right; 
			case (c = 'B') UMLDI::Placement::bottom; 
			case (c = 'L') UMLDI::Placement::left; 
		}
	};

	var compartment = self.visibleChildren()->selectOne(c|getViewType(c) = subvertexCompartmentType);
	subvertexCompartment := compartment.map nodeToSubvertexCompartment();
}

mapping Notation::Shape::shapeToStateShape() : UMLDI::StateShape
	inherits Notation::Shape::shapeToBaseStateShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::State) }
{
	if self.children->exists(element.oclIsKindOf(Behavior)) then
		internalBehaviorCompartment := self.map nodeToInternalBehaviorCompartment() 
	endif;

	if self.children->exists(element.oclIsKindOf(Transition)) then
		internalTransitionCompartment := self.map nodeToInternalTransitionCompartment() 
	endif;

	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::ConnectionPointReference));
	connectionPointReferenceShape += children.oclAsType(Notation::Shape)->map shapeToConnectionPointReferenceShape();	
}

mapping Notation::Shape::shapeToConnectionPointReferenceShape() : UMLDI::ConnectionPointReferenceShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ConnectionPointReference) };

mapping Notation::Shape::shapeToActivityGroupShape() : UMLDI::ActivityGroupShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ActivityGroup) };

mapping Notation::Shape::shapeToActivityPartitionShape() : UMLDI::ActivityPartitionShape
	inherits Notation::Shape::shapeToActivityGroupShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ActivityPartition) }
{
	var label := self.visibleChildren()->selectOne(c|subPartitionCompartmentType->includes(getViewType(c)));
	subPartitionCompartment := label.map nodeToSubPartitionCompartment();
}

mapping Notation::Shape::shapeToActivityNodeShape() : UMLDI::ActivityNodeShape
	inherits Notation::Shape::shapeToElementShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ActivityNode) };

mapping Notation::Shape::shapeToObjectNodeShape() : UMLDI::ObjectNodeShape
	inherits Notation::Shape::shapeToActivityNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ObjectNode) }
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = constraintLabelType);
	constraintLabel := label.map nodeToConstraintLabel();

	label := self.visibleChildren()->selectOne(c|getViewType(c) = selectionLabelType);
	selectionLabel := label.map nodeToSelectionLabel();
}

mapping Notation::Shape::shapeToActivityParameterNodeShape() : UMLDI::ActivityParameterNodeShape
	inherits Notation::Shape::shapeToObjectNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ActivityParameterNode) };

mapping Notation::Shape::shapeToPinShape() : UMLDI::PinShape
	inherits Notation::Shape::shapeToObjectNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Pin) };

mapping Notation::Shape::shapeToExpansionNodeShape() : UMLDI::ExpansionNodeShape
	inherits Notation::Shape::shapeToObjectNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ExpansionNode) };

mapping Notation::Shape::shapeToActionShape() : UMLDI::ActionShape
	inherits Notation::Shape::shapeToActivityNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Action) }
{
	if self.element.oclIsKindOf(AcceptEventAction) then {
		var e := self.element.oclAsType(AcceptEventAction);
		if e.trigger->size() = 1 and e.trigger->any(true).event.oclIsKindOf(UML::TimeEvent) then {
			result.bounds.x := result.bounds.x + result.bounds.width/2 - 5; 
			result.bounds.width := 20; 
			result.bounds.height := if result.mainLabel->isEmpty() then 
				20 
			else 
				result.mainLabel.bounds.y - result.bounds.y - 5
			endif; 
		} endif;
	} endif;
	
	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::Pin));
	pinShape += children.oclAsType(Notation::Shape)->map shapeToPinShape();
}

mapping Notation::Shape::shapeToStructuredActivityNodeShape() : UMLDI::StructuredActivityNodeShape
	inherits Notation::Shape::shapeToActionShape, Notation::Shape::shapeToActivityGroupShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::StructuredActivityNode) }
{
	var label := self.visibleChildren()->selectOne(c|contentCompartmentType->includes(getViewType(c)));
	contentCompartment := label.map nodeToContentCompartment();
}

mapping Notation::Shape::shapeToExpansionRegionShape() : UMLDI::ExpansionRegionShape
	inherits Notation::Shape::shapeToStructuredActivityNodeShape
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ExpansionRegion) }
{
	var children = self.visibleChildren()->select(element.oclIsKindOf(UML::ExpansionNode));
	expansionNodeShape += children.oclAsType(Notation::Shape)->map shapeToExpansionNodeShape();
}

//-------------------------------------------------------------------------------------

mapping Notation::Edge::toTopUmlDiagramElement() : UMLDI::TopUmlDiagramElement
	disjuncts Notation::Edge::edgeToTransitionEdge,
			  Notation::Edge::edgeToConnectorEdge,
			  Notation::Edge::edgeToGeneralizationEdge,
			  Notation::Edge::edgeToInterfaceRealizationEdge,
			  Notation::Edge::edgeToComponentRealizationEdge,
			  Notation::Edge::edgeToSubstitutionEdge,
			  Notation::Edge::edgeToRealizationEdge,
			  Notation::Edge::edgeToManifestationEdge,
			  Notation::Edge::edgeToAbstractionEdge,
			  Notation::Edge::edgeToUsageEdge,
			  Notation::Edge::edgeToDeploymentEdge,
			  Notation::Edge::edgeToDependencyEdge,
			  Notation::Edge::edgeToElementImportEdge,
			  Notation::Edge::edgeToPackageImportEdge,
			  Notation::Edge::edgeToPackageMergeEdge,
			  Notation::Edge::edgeToProfileApplicationEdge,
			  Notation::Edge::edgeToInformationFlowEdge,
			  Notation::Edge::edgeToGeneralizationSetEdge,
			  Notation::Edge::edgeToPropertyEdge,
			  Notation::Edge::edgeToExtensionEdgeEdge,
			  Notation::Edge::edgeToAssociationClassEdge,
			  Notation::Edge::edgeToAssociationEdge,
			  Notation::Edge::edgeToInstanceSpecificationEdge,
			  Notation::Edge::edgeToTemplateBindingEdge,
			  Notation::Edge::edgeToExtendEdge,
			  Notation::Edge::edgeToIncludeEdge,
			  Notation::Edge::edgeToContainmentEdge,
			  Notation::Edge::edgeToAttachmentEdge,
			  Notation::Edge::edgeToRepresentationEdge,
			  Notation::Edge::edgeToControlFlowEdge,
			  Notation::Edge::edgeToObjectFlowEdge,
			  Notation::Edge::edgeToExceptionHandlerEdge;

abstract mapping Notation::Edge::edgeToUmlEdge() : UMLDI::UmlEdge
	inherits Notation::View::viewToUmlDiagramElement
{
	getPoints(self)->forEach(p) {
		waypoint += object DC::Point { x := p.x; y := p.y; };
	};
	var fontStyle := self.styles[Notation::FontStyle]->at(1);
	localUmlStyle := object UMLDI::UmlStyle {
		fontName := fontStyle.fontName;
		fontSize := fontStyle.fontHeight;
	};
	sourceUmlDiagramElement := self.source.late resolveone(UMLDI::UmlDiagramElement);
	targetUmlDiagramElement := self.target.late resolveone(UMLDI::UmlDiagramElement);
}

abstract mapping Notation::Edge::edgeToElementEdge() : UMLDI::ElementEdge
	inherits Notation::Edge::edgeToUmlEdge
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = nameLabelType);
	mainLabel := label.oclAsType(Notation::DecorationNode).map nodeToMainLabel();

	if mainLabel.oclIsUndefined() then {
		label := self.visibleChildren()->selectOne(c|getViewType(c) = stereotypeLabelType);
		mainLabel := label.oclAsType(Notation::DecorationNode).map nodeToMainLabel();
	} endif;
}

abstract mapping Notation::Edge::edgeToRelationshipWithGuardEdge() : UMLDI::RelationshipWithGuardEdge
	inherits Notation::Edge::edgeToElementEdge
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = guardLabelType);
	guardLabel := label.oclAsType(Notation::DecorationNode).map nodeToGuardLabel();
}

abstract mapping Notation::Edge::edgeToActivityEdgeEdge() : UMLDI::ActivityEdgeEdge
	inherits Notation::Edge::edgeToRelationshipWithGuardEdge
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = weightLabelType);
	weightLabel := label.oclAsType(Notation::DecorationNode).map nodeToWeightLabel();
}

mapping Notation::Edge::edgeToContainmentEdge() : UMLDI::ContainmentEdge
	inherits Notation::Edge::edgeToUmlEdge
	when { getViewType(self) = containmentEdgeType }
{
	sourceUmlDiagramElement := self.source.container().late resolveone(UMLDI::UmlDiagramElement);
}

mapping Notation::Edge::edgeToAttachmentEdge() : UMLDI::AttachmentEdge
	inherits Notation::Edge::edgeToUmlEdge
	when { getViewType(self) = attachmentEdgeType };

mapping Notation::Edge::edgeToRepresentationEdge() : UMLDI::RepresentationEdge
	inherits Notation::Edge::edgeToUmlEdge
	when { getViewType(self) = representationEdgeType }
{
	var label = self.visibleChildren()->selectOne(c|getViewType(c) = representationLabelType);
	mainLabel := label.oclAsType(Notation::DecorationNode).map nodeToMainLabel();
}

mapping Notation::Edge::edgeToGeneralizationEdge() : UMLDI::GeneralizationEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Generalization) };
	
mapping Notation::Edge::edgeToElementImportEdge() : UMLDI::ElementImportEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ElementImport) }
{
	if (mainLabel.oclIsUndefined()) {
		var label = self.visibleChildren()->selectOne(c|getViewType(c) = aliasLabelType);
		mainLabel := label.oclAsType(Notation::DecorationNode).map nodeToMainLabel();
	}
}

mapping Notation::Edge::edgeToPackageImportEdge() : UMLDI::PackageImportEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::PackageImport) };

mapping Notation::Edge::edgeToPackageMergeEdge() : UMLDI::PackageMergeEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::PackageMerge) };

mapping Notation::Edge::edgeToProfileApplicationEdge() : UMLDI::ProfileApplicationEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ProfileApplication) }
{
	if (mainLabel.oclIsUndefined()) {
		mainLabel := object UMLDI::MainLabel {
			umlModelElement := self.element.oclAsType(UML::Element);
			bounds := self.centerPoint();
		};
	}
}

mapping Notation::Edge::edgeToGeneralizationSetEdge() : UMLDI::GeneralizationSetEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::GeneralizationSet) }
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = constraintLabelType);
	constraintLabel := label.oclAsType(Notation::DecorationNode).map nodeToConstraintLabel();
}

mapping Notation::Edge::edgeToInformationFlowEdge() : UMLDI::InformationFlowEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InformationFlow) }
{
	var label := self.visibleChildren()->selectOne(c|conveyedLabelType->includes(getViewType(c)));
	conveyedLabel := label.oclAsType(Notation::DecorationNode).map nodeToConveyedLabel();
}

mapping Notation::Edge::edgeToDependencyEdge() : UMLDI::DependencyEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Dependency) }
{
	var boundProperty = self.element.oclAsType(UML::Dependency).client![UML::Property];

	var label := self.visibleChildren()->selectOne(c|getViewType(c) = targetRoleLabelType);
	roleLabel := label.oclAsType(Notation::DecorationNode).map nodeToRoleLabel();
	if (not roleLabel.oclIsUndefined()) {
		roleLabel.umlModelElement := boundProperty;
	}
}

mapping Notation::Edge::edgeToAbstractionEdge() : UMLDI::AbstractionEdge
	inherits Notation::Edge::edgeToDependencyEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Abstraction) };

mapping Notation::Edge::edgeToUsageEdge() : UMLDI::UsageEdge
	inherits Notation::Edge::edgeToDependencyEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Usage) };

mapping Notation::Edge::edgeToDeploymentEdge() : UMLDI::DeploymentEdge
	inherits Notation::Edge::edgeToDependencyEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Deployment) }
{
	// reverse source and target
	sourceUmlDiagramElement := self.target.late resolveone(UMLDI::UmlDiagramElement);
	targetUmlDiagramElement := self.source.late resolveone(UMLDI::UmlDiagramElement);
	result.waypoint := result.waypoint->iterate(p; cv : OrderedSet(Point) = OrderedSet{} | cv->prepend(p));
}

mapping Notation::Edge::edgeToRealizationEdge() : UMLDI::RealizationEdge
	inherits Notation::Edge::edgeToAbstractionEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Realization) };

mapping Notation::Edge::edgeToManifestationEdge() : UMLDI::ManifestationEdge
	inherits Notation::Edge::edgeToAbstractionEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Manifestation) };

mapping Notation::Edge::edgeToInterfaceRealizationEdge() : UMLDI::InterfaceRealizationEdge
	inherits Notation::Edge::edgeToRealizationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InterfaceRealization) };

mapping Notation::Edge::edgeToComponentRealizationEdge() : UMLDI::ComponentRealizationEdge
	inherits Notation::Edge::edgeToRealizationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ComponentRealization) };

mapping Notation::Edge::edgeToSubstitutionEdge() : UMLDI::SubstitutionEdge
	inherits Notation::Edge::edgeToRealizationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Substitution) };

mapping Notation::Edge::edgeToExtendEdge() : UMLDI::ExtendEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Extend) };

mapping Notation::Edge::edgeToIncludeEdge() : UMLDI::IncludeEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Include) };

mapping Notation::Edge::edgeToPropertyEdge() : UMLDI::PropertyEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Association) and self.styles[Notation::EObjectValueStyle]->notEmpty() }
{
	var property_ := self.styles![Notation::EObjectValueStyle].eObjectValue.oclAsType(UML::Property);

	umlModelElement := property_;

	if (mainLabel.oclIsUndefined()) {
		var label := self.visibleChildren()->selectOne(c|getViewType(c) = targetRoleLabelType);
		mainLabel := label.oclAsType(Notation::DecorationNode).map nodeToMainLabel();
		if (not mainLabel.oclIsUndefined()) {
			mainLabel.umlModelElement := property_;
		}
	};
	
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = targetMultiplicityLabelType);
	multiplicityLabel := label.oclAsType(Notation::DecorationNode).map nodeToMultiplicityLabel();
	if (not multiplicityLabel.oclIsUndefined()) {
		multiplicityLabel.umlModelElement := property_;
	}
}

mapping Notation::Edge::edgeToAssociationEdge() : UMLDI::AssociationEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Association) and self.styles[Notation::EObjectValueStyle]->isEmpty() }
{
	var association = self.element.oclAsType(UML::Association);
	
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = sourceRoleLabelType);
	var newRoleLabel := label.oclAsType(Notation::DecorationNode).map nodeToRoleLabel();
	if (not newRoleLabel.oclIsUndefined()) {
		newRoleLabel.umlModelElement := association.memberEnd->at(2);
		endRoleLabel += newRoleLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = targetRoleLabelType);
	newRoleLabel := label.oclAsType(Notation::DecorationNode).map nodeToRoleLabel();
	if (not newRoleLabel.oclIsUndefined()) {
		newRoleLabel.umlModelElement := association.memberEnd->at(1);
		endRoleLabel += newRoleLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = sourceMultiplicityLabelType);
	var newMultiplicityLabel := label.oclAsType(Notation::DecorationNode).map nodeToMultiplicityLabel();
	if (not newMultiplicityLabel.oclIsUndefined()) {
		newMultiplicityLabel.umlModelElement := association.memberEnd->at(1);
		endMultiplicityLabel += newMultiplicityLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = targetMultiplicityLabelType);
	newMultiplicityLabel := label.oclAsType(Notation::DecorationNode).map nodeToMultiplicityLabel();
	if (not newMultiplicityLabel.oclIsUndefined()) {
		newMultiplicityLabel.umlModelElement := association.memberEnd->at(2);
		endMultiplicityLabel += newMultiplicityLabel;
	};
}

mapping Notation::Edge::edgeToAssociationClassEdge() : UMLDI::AssociationClassEdge
	inherits Notation::Edge::edgeToAssociationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::AssociationClass) };

mapping Notation::Edge::edgeToExtensionEdgeEdge() : UMLDI::ExtensionEdge
	inherits Notation::Edge::edgeToAssociationEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Extension) };

mapping Notation::Edge::edgeToInstanceSpecificationEdge() : UMLDI::InstanceSpecificationEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::InstanceSpecification) }
{
	var association = self.element.oclAsType(UML::InstanceSpecification).classifier![UML::Association];

	var label := self.visibleChildren()->selectOne(c|getViewType(c) = sourceRoleLabelType);
	var newRoleLabel := label.oclAsType(Notation::DecorationNode).map nodeToRoleLabel();
	if (not newRoleLabel.oclIsUndefined()) {
		newRoleLabel.umlModelElement := association.memberEnd->at(2);
		endRoleLabel += newRoleLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = targetRoleLabelType);
	newRoleLabel := label.oclAsType(Notation::DecorationNode).map nodeToRoleLabel();
	if (not newRoleLabel.oclIsUndefined()) {
		newRoleLabel.umlModelElement := association.memberEnd->at(1);
		endRoleLabel += newRoleLabel;
	};
}

mapping Notation::Edge::edgeToConnectorEdge() : UMLDI::ConnectorEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Connector) }
{
	var connector = self.element.oclAsType(UML::Connector);
	
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = sourceMultiplicityLabelType);
	var newMultiplicityLabel := label.oclAsType(Notation::DecorationNode).map nodeToMultiplicityLabel();
	if (not newMultiplicityLabel.oclIsUndefined()) {
		newMultiplicityLabel.umlModelElement := connector._end->at(1);
		endMultiplicityLabel += newMultiplicityLabel;
	};
	
	label := self.visibleChildren()->selectOne(c|getViewType(c) = targetMultiplicityLabelType);
	newMultiplicityLabel := label.oclAsType(Notation::DecorationNode).map nodeToMultiplicityLabel();
	if (not newMultiplicityLabel.oclIsUndefined()) {
		newMultiplicityLabel.umlModelElement := connector._end->at(2);
		endMultiplicityLabel += newMultiplicityLabel;
	};
}

mapping Notation::Edge::edgeToTemplateBindingEdge() : UMLDI::TemplateBindingEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::TemplateBinding) }
{
	if (mainLabel.oclIsUndefined()) {
		var label := self.visibleChildren()->selectOne(c|getViewType(c) = templateParameterSubstitutionLabelType);
		mainLabel := label.oclAsType(Notation::DecorationNode).map nodeToMainLabel();
	}
}

mapping Notation::Edge::edgeToTransitionEdge() : UMLDI::TransitionEdge
	inherits Notation::Edge::edgeToRelationshipWithGuardEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::Transition) };

mapping Notation::Edge::edgeToControlFlowEdge() : UMLDI::ControlFlowEdge
	inherits Notation::Edge::edgeToActivityEdgeEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ControlFlow) };

mapping Notation::Edge::edgeToObjectFlowEdge() : UMLDI::ObjectFlowEdge
	inherits Notation::Edge::edgeToActivityEdgeEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ObjectFlow) }
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = selectionLabelType);
	selectionLabel := label.oclAsType(Notation::DecorationNode).map nodeToSelectionLabel();

	label := self.visibleChildren()->selectOne(c|getViewType(c) = transformationLabelType);
	transformationLabel := label.oclAsType(Notation::DecorationNode).map nodeToTransformationLabel();
}

mapping Notation::Edge::edgeToExceptionHandlerEdge() : UMLDI::ExceptionHandlerEdge
	inherits Notation::Edge::edgeToElementEdge
	when { self.element->notEmpty() and self.element.oclIsKindOf(UML::ExceptionHandler) }
{
	var label := self.visibleChildren()->selectOne(c|getViewType(c) = typeLabelType);
	typeLabel := label.oclAsType(Notation::DecorationNode).map nodeToTypeLabel();

	label := self.visibleChildren()->selectOne(c|getViewType(c) = iconLabelType);
	iconLabel := label.oclAsType(Notation::DecorationNode).map nodeToIconLabel();
}

//-------------------------------------------------------------------------------------

abstract mapping Notation::Node::nodeToUmlLabel() : UMLDI::UmlLabel
	inherits Notation::View::viewToUmlDiagramElement
{
	bounds := self.bounds();
}

mapping Notation::Shape::shapeToListItemLabel() : UMLDI::ListItemLabel
	inherits Notation::Node::nodeToUmlLabel
{
	localUmlStyle := object UMLDI::UmlStyle {
		fontName := self.fontName;
		fontSize := self.fontHeight;
	}
}

mapping Notation::Node::nodeToMainLabel() : UMLDI::MainLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToRoleLabel() : UMLDI::RoleLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToMultiplicityLabel() : UMLDI::MultiplicityLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToConstraintLabel() : UMLDI::ConstraintLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToConveyedLabel() : UMLDI::ConveyedLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToBodyLabel() : UMLDI::BodyLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToGuardLabel() : UMLDI::GuardLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToWeightLabel() : UMLDI::WeightLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToSelectionLabel() : UMLDI::SelectionLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToTransformationLabel() : UMLDI::TransformationLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToTypeLabel() : UMLDI::TypeLabel
	inherits Notation::Node::nodeToUmlLabel;

mapping Notation::Node::nodeToIconLabel() : UMLDI::IconLabel
	inherits Notation::Node::nodeToUmlLabel;

//-------------------------------------------------------------------------------------

abstract mapping Notation::Node::nodeToUmlCompartment() : UMLDI::UmlCompartment
	inherits Notation::View::viewToUmlDiagramElement
{
	bounds := self.bounds();
}

abstract mapping Notation::Node::nodeToListCompartment() : UMLDI::ListCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	listItemLabel += self.visibleChildren()[Notation::Shape]->map shapeToListItemLabel();	
}

abstract mapping Notation::Node::nodeToDiagramCompartment() : UMLDI::DiagramCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	topUmlDiagramElement += self.visibleChildren()->map toTopUmlDiagramElement();
}

abstract mapping Notation::Node::nodeToClassifierCompartment() : UMLDI::ClassifierCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	if (self.visibleChildren().layoutConstraint->exists(oclIsKindOf(Notation::Bounds))) { // heuristic
		layout := UMLDI::CompartmentLayout::diagram;
		topUmlDiagramElement += self.visibleChildren()->map toTopUmlDiagramElement();
	} else {
		layout := UMLDI::CompartmentLayout::list;
		listItemLabel += self.visibleChildren().oclAsType(Notation::Shape)->map shapeToListItemLabel();
	};
}

mapping Notation::Node::nodeToAttributeCompartment() : UMLDI::AttributeCompartment
	inherits Notation::Node::nodeToListCompartment;
	
mapping Notation::Node::nodeToOperationCompartment() : UMLDI::OperationCompartment
	inherits Notation::Node::nodeToListCompartment;

mapping Notation::Node::nodeToReceptionCompartment() : UMLDI::ReceptionCompartment
	inherits Notation::Node::nodeToListCompartment;

mapping Notation::Node::nodeToLiteralCompartment() : UMLDI::LiteralCompartment
	inherits Notation::Node::nodeToListCompartment;

mapping Notation::Node::nodeToSlotCompartment() : UMLDI::SlotCompartment
	inherits Notation::Node::nodeToListCompartment;
	
mapping Notation::Node::nodeToTemplateParameterCompartment() : UMLDI::TemplateParameterCompartment
	inherits Notation::Node::nodeToListCompartment;
	
mapping Notation::Node::nodeToExtensionPointCompartment() : UMLDI::ExtensionPointCompartment
	inherits Notation::Node::nodeToListCompartment;
	
mapping Notation::Node::nodeToPackagedElementCompartment() : UMLDI::PackagedElementCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToInternalStructureCompartment() : UMLDI::InternalStructureCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToUseCaseCompartment() : UMLDI::UseCaseCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToNestedClassifierCompartment() : UMLDI::NestedClassifierCompartment
	inherits Notation::Node::nodeToClassifierCompartment;
	
mapping Notation::Node::nodeToNestedArtifactCompartment() : UMLDI::NestedArtifactCompartment
	inherits Notation::Node::nodeToClassifierCompartment;

mapping Notation::Node::nodeToNestedNodeCompartment() : UMLDI::NestedNodeCompartment
	inherits Notation::Node::nodeToClassifierCompartment;

mapping Notation::Node::nodeToOwnedUseCaseCompartment() : UMLDI::OwnedUseCaseCompartment
	inherits Notation::Node::nodeToClassifierCompartment;

mapping Notation::Node::nodeToOwnedBehaviorCompartment() : UMLDI::OwnedBehaviorCompartment
	inherits Notation::Node::nodeToClassifierCompartment;

mapping Notation::Node::nodeToRegionCompartment() : UMLDI::RegionCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToSubvertexCompartment() : UMLDI::SubvertexCompartment
	inherits Notation::Node::nodeToDiagramCompartment;

mapping Notation::Node::nodeToInternalBehaviorCompartment() : UMLDI::InternalBehaviorCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	listItemLabel += self.visibleChildren()[Notation::Shape]->select(element.oclIsKindOf(Behavior))->map shapeToListItemLabel();	
	listItemLabel->forEach(label) { label.bounds.x := bounds.x + 3; };
	var first := listItemLabel->at(1);
	var last := listItemLabel->at(listItemLabel->size());
	bounds.y := first.bounds.y;
	bounds.height := last.bounds.y + last.bounds.height - bounds.y;
}

mapping Notation::Node::nodeToInternalTransitionCompartment() : UMLDI::InternalTransitionCompartment
	inherits Notation::Node::nodeToUmlCompartment 
{
	listItemLabel += self.visibleChildren()[Notation::Shape]->select(element.oclIsKindOf(Transition))->map shapeToListItemLabel();	
	listItemLabel->forEach(label) { label.bounds.x := bounds.x + 3; };
	var f := listItemLabel->at(1);
	var l := listItemLabel->at(listItemLabel->size());
	bounds.y := f.bounds.y;
	bounds.height := l.bounds.y+l.bounds.height - bounds.y;
}

mapping Notation::Node::nodeToParameterCompartment() : UMLDI::ParameterCompartment
	inherits Notation::Node::nodeToListCompartment
{
	listItemLabel->forEach(label) { label.bounds.x := bounds.x; };
}

mapping Notation::Node::nodeToPreConditionCompartment() : UMLDI::PreConditionCompartment
	inherits Notation::Node::nodeToListCompartment
{
	listItemLabel->forEach(label) { label.bounds.x := bounds.x; };
}
	
mapping Notation::Node::nodeToPostConditionCompartment() : UMLDI::PostConditionCompartment
	inherits Notation::Node::nodeToListCompartment
{
	listItemLabel->forEach(label) { label.bounds.x := bounds.x; };
}
	
mapping Notation::Node::nodeToContentCompartment() : UMLDI::ContentCompartment
	inherits Notation::Node::nodeToDiagramCompartment
{
	// recursively collect nested subpartition compartments
	var nestedCompartments := self->closure
		(visibleChildren()->select(element.oclIsKindOf(UML::ActivityPartition)))
		.visibleChildren()->select(c|subPartitionCompartmentType->includes(getViewType(c)));
	// collect nested interruptible activity region compartments
	nestedCompartments += self.visibleChildren()->select(element.oclIsKindOf(UML::InterruptibleActivityRegion))
		.visibleChildren()->select(c|interruptibleActivityRegionCompartmentType->includes(getViewType(c)));
	// add the nodes contained in those nested compartments to this content compartment
	topUmlDiagramElement += nestedCompartments.visibleChildren()
		->select(not element.oclIsKindOf(UML::ActivityPartition))->map toTopUmlDiagramElement();
}

mapping Notation::Node::nodeToSubPartitionCompartment() : UMLDI::SubPartitionCompartment
	inherits Notation::Node::nodeToUmlCompartment
{
	topUmlDiagramElement += self.visibleChildren()->select(element.oclIsKindOf(UML::ActivityPartition))->map toTopUmlDiagramElement();
}

//-------------------------------------------------------------------------------------

query Notation::View::visibleChildren() : OrderedSet(Notation::Node) {
	return self.children->select(visible);
}

query Notation::Diagram::visibleEdges() : OrderedSet(Notation::Edge) {
	return self.edges->select(visible);
}

query Notation::Node::bounds() : DC::Bounds {
	var b := getBounds(self);
	return object DC::Bounds {
		x := b.x; y := b.y; width := b.width; height := b.height;
	}
}

query Notation::Edge::centerPoint() : DC::Bounds {
	var points := getPoints(self);
	var s := points->at(points->size()-1);
	var e := points->at(points->size());
	return object DC::Bounds { x:= s.x+(e.x-s.x)/2; y:=s.y+(e.y-s.y)/2 };
}