/**
 * Copyright (c) 2014 CEA LIST.
 *  
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 * Contributors:
 *  CEA LIST - Initial API and implementation
 */
import UmlDiagramToDG;

modeltype DC uses "http://www.omg.org/spec/DD/20110901/DC";
modeltype DG uses "http://www.omg.org/spec/DD/20110901/DG";
modeltype DI uses "http://www.omg.org/spec/DD/20110901/DI";
modeltype UMLDI uses "http://www.omg.org/spec/UML/20131001/UMLDI";
modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";
	
library ClassDiagram2DG;

/**************** Shapes *****************/

mapping UML::Classifier::shapeToGraphicalElement(shape : UMLDI::UmlShape) : DG::GraphicalElement {
	init {
		result := object DG::Rectangle {
			bounds := object DC::Bounds { 
				x := 0; y := 0; 
				width := shape.bounds.width;
				height := shape.bounds.height 
			};
		};
	}
}

/**************** Labels *****************/

mapping UML::NamedElement::labelToText(label : UMLDI::UmlLabel) : DG::Text {
	if (label.kind = UMLDI::UmlLabelKind::name) then {
		data := self.name;
		if (not label.owningUmlDiagramElement.oclIsTypeOf(UMLDI::UmlCompartment)) then {
			anchor := DG::TextAnchor::middle;
		} endif;
	} endif;
}

mapping UML::Property::labelToText(label : UMLDI::UmlLabel) : DG::Text  
	inherits UML::NamedElement::labelToText
{
	if (label.kind = UMLDI::UmlLabelKind::name) then {
		var name := self.visibility() + self.name;
		if (label.owningUmlDiagramElement.oclIsTypeOf(UMLDI::UmlCompartment)) then {
			name := name + self.type() + self.multiplicity();
		} endif;
		data := name;
	} endif;
}

mapping UML::Interface::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::NamedElement::labelToText
{
	if (label.kind = UMLDI::UmlLabelKind::name) then {
		data := '«Interface»\\n'+self.name;
	} endif;
}

/**************** Edges *****************/

mapping UML::Generalization::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	endMarker := endHollowClosedArrow;		
}

mapping UML::InterfaceRealization::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	_class := "interfaceRealization";
	endMarker := endHollowClosedArrow;		
}

mapping UML::Association::edgeToPath(edge : UMLDI::UmlEdge) : DG::Path {
	var end1 := self.memberEnd->at(1);
	var end2 := self.memberEnd->at(2);
	
	if (end1.owner != self) then {
		if (end2.aggregation = UML::AggregationKind::composite) then {
			startMarker := startSolidCircleSolidDiamondOpenArrow;
		} else if (end2.aggregation = UML::AggregationKind::shared) then {
			startMarker := startSolidCircleHollowDiamondOpenArrow;
		} else {
			startMarker := startSolidCircleOpenArrow;
		} endif endif;
	} else if (end1.isNavigable()) then {
		if (end2.aggregation = UML::AggregationKind::composite) then {
			startMarker := startSolidDiamondOpenArrow;
		} else if (end2.aggregation = UML::AggregationKind::shared) then {
			startMarker := startHollowDiamondOpenArrow;
		} else {
			startMarker := startOpenArrow;
		} endif endif;
	} else {
		if (end2.aggregation = UML::AggregationKind::composite) then {
			startMarker := startSolidDiamond;
		} else if (end2.aggregation = UML::AggregationKind::shared) then {
			startMarker := startHollowDiamond;
		} endif endif;
	} endif endif;
	
	if (end2.owner != self) then {
		if (end1.aggregation = UML::AggregationKind::composite) then {
			endMarker := endSolidCircleSolidDiamondOpenArrow;
		} else if (end1.aggregation = UML::AggregationKind::shared) then {
			endMarker := endSolidCircleHollowDiamondOpenArrow;
		} else {
			endMarker := endSolidCircleOpenArrow;
		} endif endif;
	} else if (end2.isNavigable()) then {
		if (end1.aggregation = UML::AggregationKind::composite) then {
			endMarker := endSolidDiamondOpenArrow;
		} else if (end1.aggregation = UML::AggregationKind::shared) then {
			endMarker := endHollowDiamondOpenArrow;
		} else {
			endMarker := endOpenArrow;
		} endif endif;
	} else {
		if (end1.aggregation = UML::AggregationKind::composite) then {
			endMarker := endSolidDiamond;
		} else if (end1.aggregation = UML::AggregationKind::shared) then {
			endMarker := endHollowDiamond;
		} endif endif;
	} endif endif;
}

/**************** Queries *****************/

query UML::NamedElement::visibility() : String {
	return switch {
		case (self.visibility = UML::VisibilityKind::package) '~ ';
		case (self.visibility = UML::VisibilityKind::protected) '# ';
		case (self.visibility = UML::VisibilityKind::private) '- ';
		else '+ ';
	};
}

query UML::TypedElement::type() : String {
	return if (self.type->notEmpty()) then ' : '+self.type.name else '' endif;
}

query UML::MultiplicityElement::multiplicity() : String {
	var lower = self.lower.toString();
	var upper = if (self.upper = -1) then '*' else self.upper.toString() endif;
	return switch {
		case (lower = '1' and upper = '1') '';
		case (lower = '0' and upper = '*') ' [*]';
		else ' ['+lower+'..'+upper+']';
	};
}