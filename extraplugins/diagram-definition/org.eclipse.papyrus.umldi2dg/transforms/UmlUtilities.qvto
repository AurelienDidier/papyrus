/**
 * Copyright (c) 2014 CEA LIST.
 *  
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 * Contributors:
 *  CEA LIST - Initial API and implementation
 */
import org.eclipse.papyrus.dd.qvt.DDUtilities;

modeltype DC uses "http://www.omg.org/spec/DD/20110901/DC";
modeltype DG uses "http://www.omg.org/spec/DD/20110901/DG";
modeltype DI uses "http://www.omg.org/spec/DD/20110901/DI";
modeltype UMLDI uses "http://www.omg.org/spec/UML/20131001/UMLDI";
modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";

library UmlUtilities;

property black = createColor('#000000');
 
property white = createColor('#FFFFFF');

query Collection(String)::separate(separator : String) : String {
	var str := self->iterate(s; acc : String = '' | if s = null or s = '' then acc else acc.concat(s.concat(separator)) endif);
	return if str = '' then '' else str.substring(1,str.size()-separator.size()) endif;
}

query Collection(String)::separate() : String {
	return self->separate(', ');
}

query min(n1 : Real, n2 : Real) : Real {
	return if (n1 > n2) then n2 else n1 endif;
}

query max(n1 : Real, n2 : Real) : Real {
	return if (n1 > n2) then n1 else n2 endif;
}

query abs(n : Real) : Real {
	return if (n<0) then -n else n endif;
}

query anchorPoint(bounds : Bounds, refX : Real, refY : Real) : Tuple(x: Real, y : Real) {
	var centerX := bounds.x + bounds.width/2;
	var centerY := bounds.y + bounds.height/2;
	var dx = refX - centerX;
	var dy = refY - centerY;
	var scale = 0.5 / max(abs(dx) / bounds.width, abs(dy) / bounds.height);
	dx := dx * scale;
	dy := dy * scale;
	return Tuple {x=centerX+dx, y=centerY+dy};
}

query replace(o : String, n : String, p : String) : String {
	return if n = null or n = '' then o else p.replace('<o>', o).replace('<n>', n) endif;
}

query UMLDI::UmlDiagramElement::rootDiagram() : UMLDI::UmlDiagram {
	return if (self.owningUmlDiagramElement->isEmpty()) then
		self.oclAsType(UMLDI::UmlDiagram)
	else
		self.owningUmlDiagramElement.rootDiagram()
	endif;
}

query UMLDI::UmlDiagramElement::resolveDefinitions() : DG::Definitions {
	return self.rootDiagram().resolveone(DG::Definitions);
}

query DG::Definitions::getDefinition(s : String) : DG::Definition {
	return self.definition->selectOne(id = s);
}

query DG::Definitions::getMarker(s : String) : DG::Marker {
	return self.getDefinition(s).oclAsType(DG::Marker);
}

helper DG::GraphicalElement::createStyleIfNeeded() : DG::Style {
	var e := self;
	if e.style.oclIsUndefined() then
		e.style := object DG::Style {}
	endif;
	return e.style;
}