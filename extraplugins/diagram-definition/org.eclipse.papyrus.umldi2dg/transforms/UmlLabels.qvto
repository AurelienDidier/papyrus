/**
 * Copyright (c) 2014 CEA LIST.
 *  
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 * Contributors:
 *  CEA LIST - Initial API and implementation
 */
import UmlUtilities;

modeltype DC uses "http://www.omg.org/spec/DD/20110901/DC";
modeltype DG uses "http://www.omg.org/spec/DD/20110901/DG";
modeltype DI uses "http://www.omg.org/spec/DD/20110901/DI";
modeltype UMLDI uses "http://www.omg.org/spec/UML/20131001/UMLDI";
modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";

library UmlLabels;

query UML::Abstraction::keyword(label : UMLDI::UmlLabel) : String {
	return 'abstraction';
}

mapping UML::Activity::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if  label.oclIsKindOf(UMLDI::MainLabel) and 
		not label.owningUmlDiagramElement.oclAsType(UMLDI::ClassifierShape).useClassifierNotation then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::Activity::keyword(label : UMLDI::UmlLabel) : String {
	return if self.isSingleExecution then
		'singleExecution'
	else
		''
	endif;
}

query UML::ActivityEdge::guardLabelToString(label : UMLDI::GuardLabel) : String {
	return replace('', self.guard.name(label), "[<n>]");
}

query UML::ActivityEdge::weightLabelToString(label : UMLDI::WeightLabel) : String {
	return replace('', self.weight.name(label), "weight=<n>");
}

mapping UML::ActivityPartition::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	data := self.labelToString(label);
	anchor := DG::TextAnchor::middle;
	if not label.owningDiagramElement.oclAsType(UMLDI::ActivityPartitionShape).isVertical then {
		var b = label.bounds;
		transform += object DG::Rotate {
			angle := -90;
			center := object DC::Point { x:=b.x+b.width/2; y:=b.y+b.height/2};
		}
	} endif;
}

query UML::AnyReceiveEvent::name(label : UMLDI::UmlLabel) : String {
	return 'all';
}

query UML::Artifact::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'artifact';
}

query UML::Behavior::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	return replace('', self.behaviorLabelToString(label), '<n>');
}

query UML::Behavior::behaviorLabelToString(label : UMLDI::ListItemLabel) : String {
	var s := replace('', self.kind(label), '<n>');
	s := replace(s, self.name(label), '<o> / <n>');
	s := replace(s, self.stereotype(label), '«<n>» <o>');
	return s;
}

query UML::Behavior::kind(label : UMLDI::ListItemLabel) : String {
	var state = label.umlModelElement.owner.oclAsType(UML::State);
	return if state.entry = self then
		'entry'
	else if state.exit = self then
		'exit'
	else
		'do'
	endif endif;
}

query UML::BehavioralFeature::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	var s := replace('', self.defaultForCompartment(label), "<n>");
	s := replace(s, self.visibility(label), '<n> <o>');
	s := replace(s, self.parameters(label), '<o> <n>');
	s := replace(s, self.type(label), '<o> : <n>');
	s := replace(s, self.multiplicity(label), '<o> [<n>]');
	return s;
}

query UML::BehavioralFeature::multiplicity(label : UMLDI::UmlLabel) : String {
	var p = self.ownedParameter->any(direction = UML::ParameterDirectionKind::_return);
	return if p.oclIsUndefined() then '' else p.multiplicity(label) endif;
}

query UML::BehavioralFeature::parameters(label : UMLDI::UmlLabel) : String {
	var p = self.ownedParameter->reject(direction = UML::ParameterDirectionKind::_return);
	return ' (' + p.signature(label)->separate() + ')';
}

query UML::BehavioralFeature::type(label : UMLDI::UmlLabel) : String {
	var p = self.ownedParameter->any(direction = UML::ParameterDirectionKind::_return);
	return if p.oclIsUndefined() then '' else p.type(label) endif;
}

query UML::CallEvent::name(label : UMLDI::UmlLabel) : String {
	return replace('', self.operation.basicSignature(label), '<n>');
}

query UML::CentralBufferNode::keyword(label : UMLDI::UmlLabel) : String {
	return 'centralBuffer';
}

query UML::ChangeEvent::name(label : UMLDI::UmlLabel) : String {
	return replace('', self.changeExpression.name(label), 'when <n>');
}

mapping UML::Class::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if self.isAbstract then {
		result.createStyleIfNeeded().fontItalic := true;
	} endif;
}

query UML::Classifier::keyword(label : UMLDI::UmlLabel) : String {
	var container := label.owningUmlDiagramElement;
	return if container.oclIsKindOf(ClassifierShape) and container.oclAsType(ClassifierShape).useClassifierNotation then 
		self.classifierKeyword(label) 
	else 
		'' 
	endif;
}

query UML::Classifier::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return '';
}

query UML::Collaboration::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'collaboration';
}

query UML::CollaborationUse::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.name(label), "<n>");
	s := replace(s, self.type(label), "<o> : <n>");
	return s;
}

query UML::CollaborationUse::type(label : UMLDI::UmlLabel) : String {
	return if (self.type.oclIsUndefined()) then '' else self.type.name(label) endif;
}

query UML::Comment::bodyLabelToString(label : UMLDI::BodyLabel) : String {
	var s := replace('', self.body(label), "<n>");
	return s;
}

query UML::Comment::body(label : UMLDI::UmlLabel) : String {
	return if self.body.oclIsUndefined() then '' else self.body endif;
}

mapping UML::Comment::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	anchor := DG::TextAnchor::start
}

query UML::Component::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'component';
}

query UML::ConnectionPointReference::name(label : UMLDI::UmlLabel) : String {
	return if self.entry->notEmpty() then
		self.entry.name(label)->separate()
	else if self.exit->notEmpty() then
		self.exit.name(label)->separate()
	else
		''
	endif endif;	
}

query UML::Connector::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.name(label), "<n>");
	s := replace(s, self.type(label), "<o> : <n>");
	return s;
}

query UML::Connector::type(label : UMLDI::UmlLabel) : String {
	return if (self.type.oclIsUndefined()) then '' else self.type.name(label) endif;
}

query UML::Constraint::bodyLabelToString(label : UMLDI::BodyLabel) : String {
	var s := replace('', self.body(label), "{<n>}");
	return s;
}

query UML::Constraint::body(label : UMLDI::UmlLabel) : String {
	return if self.specification.oclIsUndefined() then '' else self.specification.name(label) endif;
}

query UML::Constraint::keyword(label : UMLDI::UmlLabel) : String {
	return if label.owningUmlDiagramElement.oclIsKindOf(UMLDI::PreConditionCompartment) then
		'precondition'
	else if label.owningUmlDiagramElement.oclIsKindOf(UMLDI::PostConditionCompartment) then
		'postcondition'
	else if self.owner.oclIsKindOf(Action) and self.owner.oclAsType(Action).localPrecondition->includes(self) then
		'localPrecondition'
	else if self.owner.oclIsKindOf(Action) and self.owner.oclAsType(Action).localPostcondition->includes(self) then
		'localPostcondition'
	endif endif endif endif;
}

mapping UML::Constraint::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if (label.oclIsKindOf(UMLDI::BodyLabel)) then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::DataType::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'datatype';
}

query UML::DataStoreNode::keyword(label : UMLDI::UmlLabel) : String {
	return 'datastore';
}

query UML::Deployment::keyword(label : UMLDI::UmlLabel) : String {
	return 'deploy';
}

query UML::DeploymentSpecification::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'deployment spec';
}

query UML::Device::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'device';
}

query UML::Duration::value(label : UMLDI::UmlLabel) : String {
	return if self.expr->notEmpty() then self.expr.name(label) else self.observation.name(label)->separate() endif;
}

query UML::Element::keyword(label : UMLDI::UmlLabel) : String {
	return '';
}

query UML::Element::labelToString(label : UMLDI::UmlLabel) : String {
	return switch {
		case (label.oclIsKindOf(UMLDI::ListItemLabel)) 
			self.listItemLabelToString(label.oclAsType(UMLDI::ListItemLabel));
		case (label.oclIsKindOf(UMLDI::MainLabel)) 
			self.mainLabelToString(label.oclAsType(UMLDI::MainLabel));
		case (label.oclIsKindOf(UMLDI::BodyLabel)) 
			self.bodyLabelToString(label.oclAsType(UMLDI::BodyLabel));
		case (label.oclIsKindOf(UMLDI::RoleLabel)) 
			self.roleLabelToString(label.oclAsType(UMLDI::RoleLabel));
		case (label.oclIsKindOf(UMLDI::MultiplicityLabel)) 
			self.multiplicityLabelToString(label.oclAsType(UMLDI::MultiplicityLabel));
		case (label.oclIsKindOf(UMLDI::ConstraintLabel)) 
			self.constraintLabelToString(label.oclAsType(UMLDI::ConstraintLabel));
		case (label.oclIsKindOf(UMLDI::PowerLabel)) 
			self.powerLabelToString(label.oclAsType(UMLDI::PowerLabel));
		case (label.oclIsKindOf(UMLDI::ConveyedLabel)) 
			self.conveyedLabelToString(label.oclAsType(UMLDI::ConveyedLabel));
		case (label.oclIsKindOf(UMLDI::GuardLabel)) 
			self.guardLabelToString(label.oclAsType(UMLDI::GuardLabel));
		case (label.oclIsKindOf(UMLDI::WeightLabel)) 
			self.weightLabelToString(label.oclAsType(UMLDI::WeightLabel));
		case (label.oclIsKindOf(UMLDI::SelectionLabel)) 
			self.selectionLabelToString(label.oclAsType(UMLDI::SelectionLabel));
		case (label.oclIsKindOf(UMLDI::TransformationLabel)) 
			self.transformationLabelToString(label.oclAsType(UMLDI::TransformationLabel));
		case (label.oclIsKindOf(UMLDI::TypeLabel)) 
			self.typeLabelToString(label.oclAsType(UMLDI::TypeLabel));
		else
			'<LABEL>';
	};
}

mapping UML::Element::labelToText(label : UMLDI::UmlLabel) : DG::Text {
	data := self.labelToString(label);
	if (label.oclIsKindOf(UMLDI::ListItemLabel)) then
		anchor := DG::TextAnchor::start
	else
		anchor := DG::TextAnchor::middle
	endif;
}

query UML::Element::bodyLabelToString(label : UMLDI::BodyLabel) : String {
	return '<BODY>';
}

query UML::Element::conveyedLabelToString(label : UMLDI::ConveyedLabel) : String {
	return '<CONVEYED>';
}

query UML::Element::constraintLabelToString(label : UMLDI::ConstraintLabel) : String {
	return '<MODIFIER>';
}

query UML::Element::multiplicityLabelToString(label : UMLDI::MultiplicityLabel) : String {
	return '<MULTIPLICITY>';
}

query UML::Element::roleLabelToString(label : UMLDI::RoleLabel) : String {
	return '<ROLE>';
}

query UML::Element::powerLabelToString(label : UMLDI::PowerLabel) : String {
	return '<POWER>';
}

query UML::Element::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForElement(label), '<n>');
	return s;
}

query UML::Element::defaultForElement(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.name(label), '<n>');
	s := replace(s, self.stereotype(label), '«<n>»\n<o>');
	s := replace(s, self.keyword(label), '«<n>»\n<o>');
	return s;
}

query UML::Element::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	var s := replace('', self.defaultForCompartment(label), '<n>');
	return s;
}

query UML::Element::guardLabelToString(label : UMLDI::GuardLabel) : String {
	return '<GUARD>';
}

query UML::Element::weightLabelToString(label : UMLDI::WeightLabel) : String {
	return '<WEIGHT>';
}

query UML::Element::selectionLabelToString(label : UMLDI::SelectionLabel) : String {
	return '<SELECTION>';
}

query UML::Element::transformationLabelToString(label : UMLDI::TransformationLabel) : String {
	return '<TRANSFORMATION>';
}

query UML::Element::typeLabelToString(label : UMLDI::TypeLabel) : String {
	return '<TYPE>';
}

query UML::Element::defaultForCompartment(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.name(label), '<n>');
	s := replace(s, self.stereotype(label), '«<n>» <o>');
	s := replace(s, self.keyword(label), '«<n>» <o>');
	return s;
}

query UML::Element::name(label : UMLDI::UmlLabel) : String {
	return '';
}

query UML::Element::stereotype(label : UMLDI::UmlLabel) : String {
	return self.getAppliedStereotypes().name->separate();
}

query UML::ElementImport::alias(label : UMLDI::MainLabel) : String {
	return if self.alias.oclIsUndefined() then '' else self.alias endif;
}

query UML::ElementImport::keyword(label : UMLDI::UmlLabel) : String {
	var e = if self.importedElement.oclIsKindOf(UML::Package) then 'element ' else '' endif;
	var k = if self.visibility = UML::VisibilityKind::public then 'import' else 'access' endif;
	return e + k;
}

query UML::ElementImport::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForElement(label), '<n>');
	s := replace(s, self.alias(label), '<o>\n<n>');
	return s;
}

query UML::Enumeration::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'enumeration';
}

mapping UML::EnumerationLiteral::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	/* main label is not underlined */
}

query UML::EnumerationLiteral::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	var s := replace('', self.defaultForCompartment(label), '<n>');
	return s;
}

query UML::ExceptionHandler::typeLabelToString(label : UMLDI::TypeLabel) : String {
	return self.exceptionType.name(label)->separate('\n');
}

query UML::ExecutionEnvironment::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'executionEnvironment';
}

query UML::Expression::value(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.symbol, '<n>');
	s := replace(s, self.operand.name(label)->separate(), '<o> (<n>)');
	return s; 
}

query UML::Extend::keyword(label : UMLDI::UmlLabel) : String {
	return 'extend';
}

query UML::FunctionBehavior::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'functionalBehavior';
}

query UML::GeneralizationSet::covering(label : UMLDI::UmlLabel) : String {
	return if self.isCovering then 'complete' else 'incomplete' endif;
}

query UML::GeneralizationSet::disjoint(label : UMLDI::UmlLabel) : String {
	return if self.isDisjoint then 'disjoint' else 'overlapping' endif;
}

query UML::GeneralizationSet::constraintLabelToString(label : UMLDI::ConstraintLabel) : String {
	var s := replace(self.covering(label), self.disjoint(label), '{<o>, <n>}');
	return s;
}

query UML::GeneralizationSet::powerLabelToString(label : UMLDI::PowerLabel) : String {
	var s := replace('', self.powerType(label), ': <n>');
	return s;
}

query UML::GeneralizationSet::powerType(label : UMLDI::UmlLabel) : String {
	return if self.powertype.oclIsUndefined() then '' else self.powertype.name(label) endif;
}

query UML::Include::keyword(label : UMLDI::UmlLabel) : String {
	return 'include';
}

query UML::InformationFlow::conveyedLabelToString(label : UMLDI::ConveyedLabel) : String {
	var s := replace('', self.conveyed(label), '<n>');
	return s;
}

query UML::InformationFlow::conveyed(label : UMLDI::ConveyedLabel) : String {
	return self.conveyed->asOrderedSet().name(label)->separate();
}

query UML::InformationFlow::keyword(label : UMLDI::UmlLabel) : String {
	return 'flow';
}

query UML::InformationItem::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'information';
}

mapping UML::InstanceSpecification::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	_class := 'underlined';
}

query UML::InstanceSpecification::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForElement(label), '<n>');
	s := replace(s, self.type(label), '<o> : <n>');
	return s;
}

query UML::InstanceSpecification::type(label : UMLDI::UmlLabel) : String {
	return if (self.classifier->notEmpty()) then self.classifier->asOrderedSet().name(label)->separate() else '' endif;
}

mapping UML::Interaction::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if  label.oclIsKindOf(UMLDI::MainLabel) and 
		not label.owningUmlDiagramElement.oclAsType(UMLDI::ClassifierShape).useClassifierNotation then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::Interaction::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'interaction';
}

query UML::Interface::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'interface';
}

query UML::Interval::value(label : UMLDI::UmlLabel) : String {
	var min = if self.min->notEmpty() then self.min.name(label) else '' endif;
	var max = if self.max->notEmpty() then self.max.name(label) else '' endif;
	return min+'..'+max;
}

query UML::LiteralBoolean::value(label : UMLDI::UmlLabel) : String {
	return self.value.repr();
}

query UML::LiteralInteger::value(label : UMLDI::UmlLabel) : String {
	return self.value.repr();
}

query UML::LiteralNull::value(label : UMLDI::UmlLabel) : String {
	return 'null';
}

query UML::LiteralReal::value(label : UMLDI::UmlLabel) : String {
	return self.value.repr();
}

query UML::LiteralString::value(label : UMLDI::UmlLabel) : String {
	return if self.value.oclIsUndefined() then '' else '"'+self.value+'"' endif;
}

query UML::LiteralUnlimitedNatural::value(label : UMLDI::UmlLabel) : String {
	return if self.value = -1 then '*' else self.value.repr() endif;
}

query UML::Manifestation::keyword(label : UMLDI::UmlLabel) : String {
	return 'manifest';
}

query UML::MultiplicityElement::lower(label : UMLDI::UmlLabel) : String {
	return if self.lowerValue.oclIsUndefined() then '' else self.lowerValue.name(label) endif;
}

query UML::MultiplicityElement::multiplicityLabelToString(label : UMLDI::MultiplicityLabel) : String {
	var s := replace('', self.multiplicity(label), '<n>');
	return s;
}

query UML::MultiplicityElement::multiplicity(label : UMLDI::UmlLabel) : String {
	var lower = self.lower(label);
	var upper = self.upper(label);
	return switch {
		case (lower = '' and upper = '') '';
		case (lower = '0' and upper = '*') '*';
		case (lower = upper) lower;
		else lower+'..'+upper;
	};
}

query UML::MultiplicityElement::upper(label : UMLDI::UmlLabel) : String {
	return if self.upperValue.oclIsUndefined() then '' else self.upperValue.name(label) endif;
}

query UML::NamedElement::name(label : UMLDI::UmlLabel) : String {
	return if self.name.oclIsUndefined() then '' else self.name endif;
}

query UML::NamedElement::visibility(label : UMLDI::UmlLabel) : String {
	return switch {
		case (self.visibility = UML::VisibilityKind::package) '~';
		case (self.visibility = UML::VisibilityKind::protected) '#';
		case (self.visibility = UML::VisibilityKind::private) '-';
		else '+';
	};
}

query UML::ObjectFlow::selectionLabelToString(label : UMLDI::SelectionLabel) : String {
	var s := replace('', self.selection.name(label), "<n>");
	s := replace(s, 'selection', '«<n>»\n<o>');
	return s;
}

query UML::ObjectFlow::transformationLabelToString(label : UMLDI::TransformationLabel) : String {
	var s := replace('', self._transformation.name(label), "<n>");
	s := replace(s, 'transformation', '«<n>»\n<o>');
	return s;
}

query UML::ObjectNode::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.name(label), "<n>");
	s := replace(s, self.type(label), "<o> : <n>");
	s := replace(s, self.keyword(label), '«<n>»\n<o>');
	s := replace(s, self.inState(label), '<o>\n[<n>]');
	return s;
}

query UML::ObjectNode::inState(label : UMLDI::UmlLabel) : String {
	return self.inState.name(label)->separate();
}

query UML::ObjectNode::selectionLabelToString(label : UMLDI::SelectionLabel) : String {
	var s := replace('', self.selection.name(label), "<n>");
	s := replace(s, 'selection', '«<n>»\n<o>');
	return s;
}

query UML::OpaqueBehavior::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'opaqueBehavior';
}

query UML::OpaqueBehavior::name(label : UMLDI::UmlLabel) : String {
	return if not self.name.oclIsUndefined() then self.name else self.value(label) endif;
}

query UML::OpaqueBehavior::value(label : UMLDI::UmlLabel) : String {
	return if self.body->isEmpty() then '' else self.body(label) endif;
}

query UML::OpaqueBehavior::body(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.body->at(1), '<n>');
	s := replace(s, self.language->at(1), '{<n>} <o>');
	return s;
}

query UML::OpaqueExpression::value(label : UMLDI::UmlLabel) : String {
	return if self.body->isEmpty() then '' else self.body(label) endif;
}

query UML::OpaqueExpression::body(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.body->at(1), '<n>');
	s := replace(s, self.language->at(1), '{<n>} <o>');
	return s;
}

query UML::Operation::basicSignature(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.name(label), "<n>");
	s := replace(s, self.parameters(label), '<o> <n>');
	s := replace(s, self.type(label), '<o> : <n>');
	s := replace(s, self.multiplicity(label), '<o> [<n>]');
	return s;
}

query UML::OperationTemplateParameter::name(label : UMLDI::UmlLabel) : String {
	var e = self.parameteredElement.oclAsType(UML::Operation);
	return if e.oclIsUndefined() then '' else replace(e.name(label), e.parameters(label), '<o> <n>') endif;
}

query UML::PackageImport::keyword(label : UMLDI::UmlLabel) : String {
	return 'import';
}

query UML::PackageMerge::keyword(label : UMLDI::UmlLabel) : String {
	return 'merge';
}

query UML::Parameter::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	return self.signature(label);
}

query UML::Parameter::direction(label : UMLDI::UmlLabel) : String {
	return switch {
		case (self.direction = UML::ParameterDirectionKind::_in) 'in';
		case (self.direction = UML::ParameterDirectionKind::_inout) 'inout';
		case (self.direction = UML::ParameterDirectionKind::_out) 'out';
		else 'return';
	};
}

query UML::Parameter::signature(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.defaultForCompartment(label), '<n>');
	s := replace(s, self.direction(label), '<n> <o>');
	s := replace(s, self.type(label), '<o> : <n>');
	s := replace(s, self.multiplicity(label), '<o> [<n>]');
	return replace(s, self.defaultValue(label), '<o> = <n>');
}

query UML::Parameter::defaultValue(label : UMLDI::UmlLabel) : String {
	return if self.defaultValue.oclIsUndefined() then '' else self.defaultValue.name(label) endif;
}

query UML::Port::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForCompartment(label), '<n>');
	s := replace(s, self.type(label), '<o> : <n>');
	s := replace(s, self.multiplicity(label), '<o> [<n>]');
	s := replace(s, self.defaultValue(label), '<o> = <n>');
	s := replace(s, self.derivation(label), '<n><o>');
	s := replace(s, self.visibility(label), '<n> <o>');
	return s;
}

query UML::PrimitiveType::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'primitive';
}

query UML::Profile::keyword(label : UMLDI::UmlLabel) : String {
	return 'profile';
}

query UML::ProfileApplication::keyword(label : UMLDI::UmlLabel) : String {
	return if self.isStrict then 'strict' else 'apply' endif;
}

query UML::Property::defaultValue(label : UMLDI::UmlLabel) : String {
	return if self.defaultValue.oclIsUndefined() then '' else self.defaultValue.name(label) endif;
}

query UML::Property::derivation(label : UMLDI::UmlLabel) : String {
	return if self.isDerived then '/' else '' endif;
}

query UML::Property::multiplicityLabelToString(label : UMLDI::MultiplicityLabel) : String {
	var s := replace('', self.multiplicity(label), '<n>');
	return s;
}

query UML::Property::mainLabelToString(label : UMLDI::MainLabel) : String {
	return if label.owningUmlDiagramElement.oclIsKindOf(UMLDI::UmlEdge) then
		self.shortSignature(label)
	else
		self.longSignature(label)
	endif;
}

query UML::Property::roleLabelToString(label : UMLDI::RoleLabel) : String {
	return self.shortSignature(label);
}

query UML::Property::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	return self.longSignature(label);
}

query UML::Property::shortSignature(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.defaultForCompartment(label), '<n>');
	s := replace(s, self.derivation(label), '<n><o>');
	s := replace(s, self.visibility(label), '<n> <o>');
	return s;
}

query UML::Property::longSignature(label : UMLDI::UmlLabel) : String {
	var s := replace('', self.defaultForCompartment(label), '<n>');
	s := replace(s, self.type(label), '<o> : <n>');
	s := replace(s, self.multiplicity(label), '<o> [<n>]');
	s := replace(s, self.defaultValue(label), '<o> = <n>');
	s := replace(s, self.derivation(label), '<n><o>');
	s := replace(s, self.visibility(label), '<n> <o>');
	return s;
}

query UML::ProtocolStateMachine::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'protocolStateMachine';
}

query UML::ProtocolStateMachine::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForElement(label), '<n>');
	s := replace(s, '{protocol}', '<o>\n<n>');
	if self.extendedStateMachine->notEmpty() then
		s := replace(s, '{extended}', '<o>\n<n>')
	endif;
	return s;
}

query UML::ProtocolTransition::transition(label : UMLDI::UmlLabel) : String {
	var s := '';
	if self.trigger->notEmpty() then 
		s := replace(s, self.trigger.name(label)->separate(), '<n>')
	endif;
	if self.preCondition->notEmpty() then 
		s := replace(s, self.guard.body(label), '[<n>] <o>')
	endif;
	if self.postCondition->notEmpty() then 
		s := replace(s, self.postCondition.body(label), '<o> [<n>]')
	endif;
	return s.trim();
}

query UML::Realization::keyword(label : UMLDI::UmlLabel) : String {
	return '';
}

query UML::Reception::keyword(label : UMLDI::UmlLabel) : String {
	return 'signal';
}

query UML::Region::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForElement(label), '<n>');
	if self.extendedRegion->notEmpty() then
		s := replace(s, '{extended}', '<o>\n<n>')
	endif;
	return s;
}

query UML::Signal::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'signal';
}

query UML::SignalEvent::name(label : UMLDI::UmlLabel) : String {
	return replace('', self.signal.name(label), '<n>');
}

query UML::Slot::defaultValue(label : UMLDI::UmlLabel) : String {
	return if self.value->isEmpty() then '' else self.value.name(label)->separate() endif;
}

query UML::Slot::name(label : UMLDI::UmlLabel) : String {
	return if self.definingFeature.oclIsUndefined() then '' else self.definingFeature.name(label) endif;
}

query UML::Slot::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	var s := replace('', self.defaultForCompartment(label), '<n>');
	s := replace(s, self.type(label), '<o> : <n>');
	return replace(s, self.defaultValue(label), '<o> = <n>');
}

query UML::Slot::type(label : UMLDI::UmlLabel) : String {
	return if self.definingFeature.oclIsUndefined() then '' else self.definingFeature.type(label) endif;
}

query UML::State::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForElement(label), '<n>');
	if self.submachine->notEmpty() then
		s := replace(s, self.submachine.name(label), '<o> : <n>')
	endif;
	if self.isComposite and self.redefinedState->notEmpty() then
		s := replace(s, '{extended}', '<o>\n<n>')
	endif;
	if self.isLeaf then
		s := replace(s, '{final}', '<o>\n<n>')
	endif;
	if self.stateInvariant->notEmpty() then
		s := replace(s, self.stateInvariant.body(label), '<o>\n[<n>]')
	endif;
	return s;
}

mapping UML::StateMachine::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	if  label.oclIsKindOf(UMLDI::MainLabel) and 
		not label.owningUmlDiagramElement.oclAsType(UMLDI::ClassifierShape).useClassifierNotation then
		anchor := DG::TextAnchor::start
	endif;
}

query UML::StateMachine::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForElement(label), '<n>');
	if self.extendedStateMachine->notEmpty() then
		s := replace(s, '{extended}', '<o>\n<n>')
	endif;
	return s;
}

query UML::StateMachine::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'stateMachine';
}

query UML::Stereotype::classifierKeyword(label : UMLDI::UmlLabel) : String {
	return 'stereotype';
}

mapping UML::StructuredActivityNode::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UML::Element::labelToText
{
	anchor := DG::TextAnchor::start
}

query UML::StructuredActivityNode::keyword(label : UMLDI::UmlLabel) : String {
	return 'structured';
}

query UML::Substitution::keyword(label : UMLDI::UmlLabel) : String {
	return 'substitute';
}

query UML::TemplateBinding::substitutions(label : UMLDI::MainLabel) : String {
	return self.parameterSubstitution.substitution(label)->separate();
}

query UML::TemplateBinding::keyword(label : UMLDI::UmlLabel) : String {
	return 'bind';
}

query UML::TemplateBinding::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForElement(label), '<n>');
	s := replace(s, self.substitutions(label), '<o>\n<n>');
	return s;
}

query UML::TemplateParameter::name(label : UMLDI::UmlLabel) : String {
	var e = self.parameteredElement.oclAsType(UML::NamedElement);
	return if e.oclIsUndefined() then '' else e.name(label) endif;
}

query UML::TemplateParameter::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	var s := replace('', self.defaultForCompartment(label), '<n>');
	s := replace(s, self.type(label), '<o> : <n>');
	return s;
}

query UML::TemplateParameter::type(label : UMLDI::UmlLabel) : String {
	return if self.parameteredElement.oclIsUndefined() then '' else self.parameteredElement.metaClassName() endif;
}

query UML::TemplateParameterSubstitution::substitution(label : UMLDI::UmlLabel) : String {
	var formal = if self.formal.oclIsUndefined() then '' else self.formal.name(label) endif;
	var actual = if self.actual.oclIsUndefined() then '' else self.actual.name(label) endif;
	var s := replace('', formal, '<n>');
	return replace(s, actual, '<o> -> <n>');
}

query UML::TimeEvent::name(label : UMLDI::UmlLabel) : String {
	return if self.isRelative then
		replace('', self._when.name(label), 'after <n>')
	else
		replace('', self._when.name(label), 'at <n>')
	endif;
}

query UML::TimeExpression::value(label : UMLDI::UmlLabel) : String {
	return if self.expr->notEmpty() then self.expr.name(label) else self.observation.name(label)->separate() endif;
}

query UML::Transition::mainLabelToString(label : UMLDI::MainLabel) : String {
	var s := replace('', self.defaultForElement(label), '<n>');
	if self.isLeaf then
		s := replace(s, '{final}', '<o>\n<n>')
	endif;
	return s;
}

query UML::Transition::guardLabelToString(label : UMLDI::GuardLabel) : String {
	var s := replace('', self.transition(label), '<n>');
	return s;
}

query UML::Transition::listItemLabelToString(label : UMLDI::ListItemLabel) : String {
	var s := replace('', self.transition(label), '<n>');
	return s;
}

query UML::Transition::transition(label : UMLDI::UmlLabel) : String {
	var s := '';
	if self.trigger->notEmpty() then 
		s := replace(s, self.trigger.name(label)->separate(), '<n>')
	endif;
	if self.guard->notEmpty() then 
		s := replace(s, self.guard.body(label), '<o> [<n>]')
	endif;
	if self.effect->notEmpty() then 
		s := replace(s, self.effect.name(label), '<o> / <n>')
	endif;
	return s.trim();
}

query UML::Trigger::name(label : UMLDI::UmlLabel) : String {
	var s := self.event.name(label);
	if label.owningUmlDiagramElement.oclIsKindOf(UMLDI::DeferrableTriggerCompartment) then
		s := s + ' / defer' 
	endif;
	return s;
}

query UML::TypedElement::type(label : UMLDI::UmlLabel) : String {
	return if (self.type.oclIsUndefined()) then '' else self.type.name(label) endif;
}

query UML::Usage::keyword(label : UMLDI::UmlLabel) : String {
	return 'use';
}

query UML::ValueSpecification::value(label : UMLDI::UmlLabel) : String {
	return 'VALUE';
}

query UML::ValueSpecification::name(label : UMLDI::UmlLabel) : String {
	return if not self.name.oclIsUndefined() then self.name else self.value(label) endif;
}

mapping UMLDI::UmlDiagramElement::labelToText(label : UMLDI::UmlLabel) : DG::Text {
	anchor := DG::TextAnchor::middle
}

mapping UMLDI::RealizationEdge::labelToText(label : UMLDI::UmlLabel) : DG::Text 
	inherits UMLDI::UmlDiagramElement::labelToText
{
	if (label.oclIsKindOf(UMLDI::MainLabel))
		data := '«representation»';
}
