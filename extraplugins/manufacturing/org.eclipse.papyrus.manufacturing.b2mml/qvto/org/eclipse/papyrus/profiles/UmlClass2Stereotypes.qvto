modeltype UML uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype Ecore uses ecore('http://www.eclipse.org/emf/2002/Ecore');

transformation UmlClass2Stereotypes(in uml : UML, in umlMetamodel : UML, out UML);

main() {
	uml.rootObjects()[UML::Model]->map classModel2ProfileModel();
}

mapping Model::classModel2ProfileModel() : Profile{
	name := self.name;
	var classes := self.packagedElement[UML::Class];
	var stereotypes : Set(Stereotype) := classes->map class2Stereotype()->asSet();
	var primitiveTypes : Set(PrimitiveType) := self.packagedElement[UML::PrimitiveType]->map primitiveType2primitiveType()->asSet();
	var dataTypes : Set(DataType) := self.packagedElement[UML::DataType]->map dataType2dataType()->asSet();
	var associations : Set(Association) := self.packagedElement[UML::Association]->map association2association()->asSet();
	packagedElement := stereotypes.oclAsType(PackageableElement)
							->union(associations)
							->union(dataTypes)
							->union(primitiveTypes);
	packagedElement->forEach(packagedElement){
								
								packagedElement[Classifier].oclAsType(Classifier).generalization->forEach(generalization){
									var resolvedDataType : Classifier := generalization.general.resolveone(Stereotype);
									if (resolvedDataType = null){
										resolvedDataType := generalization.general.resolveone(DataType);
									};
									if (resolvedDataType = null){
										resolvedDataType := generalization.general.resolveone(PrimitiveType);
									};
									if (resolvedDataType = null){
										resolvedDataType := generalization.general;
									};
									if (resolvedDataType = null){
										log("no data type found for generalization.general.qualifiedName");
									};
									generalization.general := resolvedDataType;
								};
								
								packagedElement[StructuredClassifier].oclAsType(StructuredClassifier).ownedAttribute->forEach(ownedAttribute){
									var resolvedDataType : Type := ownedAttribute.type.resolveone(Stereotype);
									if (resolvedDataType = null){
										resolvedDataType := ownedAttribute.type.resolveone(DataType);
									};
									if (resolvedDataType = null){
										resolvedDataType := ownedAttribute.type.resolveone(PrimitiveType);
									};
									if (resolvedDataType = null){
										resolvedDataType := ownedAttribute.type;
									};
									if (resolvedDataType = null){
										log("no data type found for " + ownedAttribute.qualifiedName);
									};
									ownedAttribute.type := resolvedDataType;
								};
								packagedElement[DataType].oclAsType(DataType).ownedAttribute->forEach(ownedAttribute){
									var resolvedDataType : Type := ownedAttribute.type.resolveone(Stereotype);
									if (resolvedDataType = null){
										resolvedDataType := ownedAttribute.type.resolveone(DataType);
									};
									if (resolvedDataType = null){
										resolvedDataType := ownedAttribute.type.resolveone(PrimitiveType);
									};
									if (resolvedDataType = null){
										resolvedDataType := ownedAttribute.type;
									};
									if (resolvedDataType = null){
										log("no data type found for " + ownedAttribute.qualifiedName);
									};
									ownedAttribute.type := resolvedDataType;
								};
								packagedElement[Association].oclAsType(Association).ownedEnd->forEach(ownedEnd){
									var resolvedDataType : Type := ownedEnd.type.resolveone(Stereotype);
									if (resolvedDataType = null){
										resolvedDataType := ownedEnd.type.resolveone(DataType);
									};
									if (resolvedDataType = null){
										resolvedDataType := ownedEnd.type.resolveone(PrimitiveType);
									};
									if (resolvedDataType = null){
										resolvedDataType := ownedEnd.type;
									};
									if (resolvedDataType = null){
										log("no data type found for " + ownedEnd.qualifiedName);
									};
									ownedEnd.type := resolvedDataType;
								};
							};
<<<<<<< Upstream, based on origin/master
							
	log("Profile structure created");						
	//Make all stereotypes extend NamedElement
	var namedElementMetaclass := umlMetamodel.objects()[Class]->selectOne(name = "NamedElement").oclAsType(Class);
	var packageImport := result.createPackageImport(umlMetamodel.rootObjects()![Package], VisibilityKind::public);
	result.metamodelReference := packageImport;
	var extensions := result.ownedStereotype.createExtension(namedElementMetaclass, true);
	result.packagedElement := result.packagedElement->union(extensions);
	result.define();
							
}

mapping PrimitiveType::primitiveType2primitiveType() : PrimitiveType{
	init{
		result := self;//.deepclone()![PrimitiveType];
	}
	result.ownedAttribute := self.ownedAttribute.map property2property();
	
}

mapping DataType::dataType2dataType() : DataType{
	init{
		result := self;//.deepclone()![DataType];
	}
	
}

mapping Class::class2Stereotype() : Stereotype{
	eAnnotations := self.eAnnotations.clone()[EAnnotation]->asSet();
	ownedComment := self.ownedComment.clone()[Comment]->asSet();
	name := self.name.replaceAll("Type(?!.*Type)", "");
	nameExpression := self.nameExpression.clone()![StringExpression];
	visibility := self.visibility;
	ownedRule := self.ownedRule.clone()[Constraint]->asSet();
	elementImport := self.elementImport.clone()[ElementImport]->asSet();
	packageImport := self.packageImport.clone()[PackageImport]->asSet();
	isLeaf := self.isLeaf;
	owningTemplateParameter := self.owningTemplateParameter.clone()![TemplateParameter];
	templateParameter := self.templateParameter.clone()![TemplateParameter];
	//package := self.package.clone()![Package];
	templateBinding := self.templateBinding.clone()[TemplateBinding]->asSet();
	ownedTemplateSignature := self.ownedTemplateSignature.clone()![TemplateSignature];
	collaborationUse := self.collaborationUse.clone()[CollaborationUse]->asSet();
	general := self.general.clone()[Classifier]->asSet();
	generalization := self.generalization.deepclone()[Generalization]->asSet();
	powertypeExtent := self.powertypeExtent.clone()[GeneralizationSet]->asSet();
	isAbstract := self.isAbstract;
	isFinalSpecialization := self.isFinalSpecialization;
	ownedUseCase := self.ownedUseCase.clone()[UseCase]->asSet();
	useCase := self.useCase.clone()[UseCase]->asSet();
	redefinedClassifier := self.redefinedClassifier.clone()[Classifier]->asSet();
	representation := self.representation.clone()![CollaborationUse];
	substitution := self.substitution.clone()[Substitution]->asSet();
	ownedAttribute := self.ownedAttribute.map property2property();
	ownedConnector := self.ownedConnector.clone()[Connector]->asSet();
	classifierBehavior := self.classifierBehavior.clone()![Behavior];
	interfaceRealization := self.interfaceRealization.clone()[InterfaceRealization]->asSet();
	ownedBehavior := self.ownedBehavior.clone()[Behavior]->asSet();
	ownedOperation := self.ownedOperation.clone()[Operation]->asSet();
	isActive := self.isActive;
	nestedClassifier := self.nestedClassifier.clone()[Classifier]->asSet();
	ownedReception := self.ownedReception.clone()[Reception]->asSet();
	superClass := self.superClass.clone()[Class]->asSet();
}

mapping Property::property2property() : Property{
	init{
		result := self;//.deepclone()![Property];
	}
	
}

mapping Association::association2association() : Association{
	init{
		result := self;//.deepclone()![Association];
		result.ownedEnd := self.ownedEnd->map property2property();
=======
	//Make all stereotypes extend NamedElement
	var namedElementMetaclass := umlMetamodel.objects()[Class]->selectOne(name = "NamedElement").oclAsType(Class);
	Profile.allInstances()->forEach(profile){
		var packageImport := profile.createPackageImport(umlMetamodel.rootObjects()![Package], VisibilityKind::public);
		profile.metamodelReference := packageImport;
		var extensions := profile.ownedStereotype.createExtension(namedElementMetaclass, true);
		profile.packagedElement := profile.packagedElement->union(extensions);
	}						
							
}

mapping PrimitiveType::primitiveType2primitiveType() : PrimitiveType{
	init{
		result := self;//.deepclone()![PrimitiveType];
	}
	result.ownedAttribute := self.ownedAttribute.map property2property();
	
}

mapping DataType::dataType2dataType() : DataType{
	init{
		result := self;//.deepclone()![DataType];
	}
	//result.ownedAttribute := self.ownedAttribute.map property2property();
	
}

mapping Class::class2Stereotype() : Stereotype{
	eAnnotations := self.eAnnotations.clone()[EAnnotation]->asSet();
	ownedComment := self.ownedComment.clone()[Comment]->asSet();
	name := self.name;
	nameExpression := self.nameExpression.clone()![StringExpression];
	visibility := self.visibility;
	ownedRule := self.ownedRule.clone()[Constraint]->asSet();
	elementImport := self.elementImport.clone()[ElementImport]->asSet();
	packageImport := self.packageImport.clone()[PackageImport]->asSet();
	isLeaf := self.isLeaf;
	owningTemplateParameter := self.owningTemplateParameter.clone()![TemplateParameter];
	templateParameter := self.templateParameter.clone()![TemplateParameter];
	//package := self.package.clone()![Package];
	templateBinding := self.templateBinding.clone()[TemplateBinding]->asSet();
	ownedTemplateSignature := self.ownedTemplateSignature.clone()![TemplateSignature];
	collaborationUse := self.collaborationUse.clone()[CollaborationUse]->asSet();
	general := self.general.clone()[Classifier]->asSet();
	generalization := self.generalization.deepclone()[Generalization]->asSet();
	powertypeExtent := self.powertypeExtent.clone()[GeneralizationSet]->asSet();
	isAbstract := self.isAbstract;
	isFinalSpecialization := self.isFinalSpecialization;
	ownedUseCase := self.ownedUseCase.clone()[UseCase]->asSet();
	useCase := self.useCase.clone()[UseCase]->asSet();
	redefinedClassifier := self.redefinedClassifier.clone()[Classifier]->asSet();
	representation := self.representation.clone()![CollaborationUse];
	substitution := self.substitution.clone()[Substitution]->asSet();
	ownedAttribute := self.ownedAttribute.map property2property();
	ownedConnector := self.ownedConnector.clone()[Connector]->asSet();
	classifierBehavior := self.classifierBehavior.clone()![Behavior];
	interfaceRealization := self.interfaceRealization.clone()[InterfaceRealization]->asSet();
	ownedBehavior := self.ownedBehavior.clone()[Behavior]->asSet();
	ownedOperation := self.ownedOperation.clone()[Operation]->asSet();
	isActive := self.isActive;
	nestedClassifier := self.nestedClassifier.clone()[Classifier]->asSet();
	ownedReception := self.ownedReception.clone()[Reception]->asSet();
	superClass := self.superClass.clone()[Class]->asSet();
}

mapping Property::property2property() : Property{
	init{
		result := self;//.deepclone()![Property];
		//result.type := self.type.resolveone(Stereotype);
		//result.association := self.association.resolveone(Association);		
	}
	
}

mapping Association::association2association() : Association{
	init{
		result := self;//.deepclone()![Association];
		//result.memberEnd := self.memberEnd.clone()[Property];
		result.ownedEnd := self.ownedEnd->map property2property();
			
			/*
			->forEach(ownedEnd){
				ownedEnd.type := ownedEnd.type.resolveone(Stereotype);
				if (ownedEnd.type = null){
					ownedEnd.type := ownedEnd.type.resolveone(DataType)	
				}
			};
		
		*/
		
		//result.memberEnd := self.memberEnd.resolveone(Property);
		
		//forEach(result.ownedEnd.type := self.type.resolveone(Stereotype)
>>>>>>> 3dfdb08 Papyrus BPMN project
	}
}