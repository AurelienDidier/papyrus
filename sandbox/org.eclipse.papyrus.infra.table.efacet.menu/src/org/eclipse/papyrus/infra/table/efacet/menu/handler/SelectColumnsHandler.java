package org.eclipse.papyrus.infra.table.efacet.menu.handler;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.emf.common.command.Command;
import org.eclipse.emf.common.command.CompoundCommand;
import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.edit.provider.ComposedAdapterFactory;
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider;
import org.eclipse.emf.facet.efacet.core.IFacetManager;
import org.eclipse.emf.facet.efacet.core.IFacetManagerFactory;
import org.eclipse.emf.facet.efacet.metamodel.v0_2_0.efacet.EFacetFactory;
import org.eclipse.emf.facet.efacet.metamodel.v0_2_0.efacet.FacetElement;
import org.eclipse.emf.facet.efacet.metamodel.v0_2_0.efacet.FacetSet;
import org.eclipse.emf.facet.efacet.metamodel.v0_2_0.efacet.impl.FacetSetImpl;
import org.eclipse.emf.facet.widgets.celleditors.ICommandFactoriesRegistry;
import org.eclipse.emf.facet.widgets.celleditors.ICommandFactory;
import org.eclipse.emf.facet.widgets.table.metamodel.v0_2_0.table.Column;
import org.eclipse.emf.facet.widgets.table.metamodel.v0_2_0.table.FeatureColumn;
import org.eclipse.emf.facet.widgets.table.metamodel.v0_2_0.table.Table;
import org.eclipse.emf.facet.widgets.table.ui.internal.exported.ITableWidget;
import org.eclipse.emf.facet.widgets.table.ui.internal.exported.ITableWidgetInternal;
import org.eclipse.emf.facet.widgets.table.ui.internal.exported.ITableWidgetProvider;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.window.Window;
import org.eclipse.papyrus.commands.wrappers.GMFtoEMFCommandWrapper;
import org.eclipse.papyrus.infra.core.services.ServiceException;
import org.eclipse.papyrus.infra.emf.utils.ServiceUtilsForResource;
import org.eclipse.papyrus.infra.table.efacet.common.editor.AbstractTableEditor;
import org.eclipse.papyrus.infra.table.efacet.menu.Activator;
import org.eclipse.papyrus.infra.table.efacet.menu.factory.ITableCommandFactory;
import org.eclipse.papyrus.infra.table.efacet.menu.factory.TableCommandFactory;
import org.eclipse.papyrus.infra.table.efacet.menu.factory.TableInstanceCommandFactory;
import org.eclipse.papyrus.infra.table.efacet.metamodel.papyrustable.PapyrusTable;
import org.eclipse.papyrus.infra.table.efacet.metamodel.papyrustable.TableContentsUtils;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.PlatformUI;


//FIXME : uml dependency
public class SelectColumnsHandler extends AbstractHandler {

	private final String ADDITIONAL_CONTENTS_FACET_SET_NAME = "AdditionalContentsForTable";

	private final String ADDITIONAL_CONTENTS_FACET_SET_NS_URI = "http://www.eclipse.org/papyrustableefacet/additionalcontentsfacetset";

	private final String ADDITIONAL_CONTENTS_FACET_SET_PREFIX = "additionalcontentsfacetset";

	private final String ADDITIONAL_CONTENTS_FACET_SET_DOCUMENTATION = "This FacetSet provides facets to edit easily additional contents (as Stereotype Properties). It had been generated by the Papyrus Show/Hide columns";

	/** all direct features available in the table */
	final protected SortedSet<ETypedElement> allDirectFeatures = new TreeSet<ETypedElement>(new EcoreENamedElementComparator());

	/** all additional possible contents */
	final protected Collection<FacetSet> allAdditionalContents = new HashSet<FacetSet>();

	/** the initial direct features visibles in the table */
	final protected Collection<ETypedElement> initialDirectFeatureSelected = new HashSet<ETypedElement>();

	/** the initial additional features visibles in the table */
	final protected Collection<ETypedElement> initialAdditionalFeatureSelected = new HashSet<ETypedElement>();

	/** the list of the facetSet used in the current table */
	final protected Collection<FacetSet> facetSetsUsedInTheTable = new HashSet<FacetSet>();

	/** the map between existing columns (visible or not) and the feature */
	final protected Map<ETypedElement, Column> columnsFeatureMap = new HashMap<ETypedElement, Column>();


	//TODO remove it
	final StereotypeManagement management = new StereotypeManagement();

	/**
	 * clear the fields
	 */
	protected void clearFields() {
		this.allDirectFeatures.clear();
		this.initialDirectFeatureSelected.clear();
		this.initialAdditionalFeatureSelected.clear();
		this.facetSetsUsedInTheTable.clear();
		this.columnsFeatureMap.clear();
		this.allAdditionalContents.clear();
	}

	//TODO look for an existing method in EMF for EPackage
	private FacetSet getRootFacetSet(final FacetElement facetElement) {
		EObject container = facetElement;
		while(container.eContainer() != null) {
			container = container.eContainer();
		}
		if(container instanceof FacetSet) {
			return (FacetSet)container;
		}
		return null;
	}

	/**
	 * Inits the fields of this class
	 * 
	 * @param widget
	 *        the table widget
	 * @param papyrusTable
	 *        the papyrus table
	 */
	protected void initField(final ITableWidget widget, final PapyrusTable papyrusTable) {
		clearFields();
		//the contents of the table
		final List<EObject> contents = TableContentsUtils.getTableContents(papyrusTable, papyrusTable.getTable().getContext(), false);

		//1. Get all direct features
		for(final EObject current : contents) {
			this.allDirectFeatures.addAll(current.eClass().getEAllStructuralFeatures());
		}

		//2. we build the list of the initialSelection
		final List<Column> visibleColumns = widget.getVisibleColumns(false);
		final Set<ETypedElement> visibleFeatures = new HashSet<ETypedElement>();
		for(final Column current : visibleColumns) {
			if(current instanceof FeatureColumn) {
				final ETypedElement feature = ((FeatureColumn)current).getFeature();
				if(feature instanceof FacetElement) {
					this.initialAdditionalFeatureSelected.add(feature);
				} else {
					this.initialDirectFeatureSelected.add(feature);
				}
			}
		}

		for(final Column current : papyrusTable.getTable().getColumns()) {
			if(current instanceof FeatureColumn) {
				final FeatureColumn col = (FeatureColumn)current;
				final ETypedElement feature = col.getFeature();
				//3. we associate each features to each columns
				this.columnsFeatureMap.put(feature, col);

				//3 bis. we build the list of the initialSelection
				if(feature instanceof FacetElement) {
					final FacetSet set = getRootFacetSet((FacetElement)feature);
					this.facetSetsUsedInTheTable.add(set);
				}
			}
		}

		//4. get the additional features
		final FacetSet additionFeatureRootFacetSet = getAdditionalContentsFacetSet(papyrusTable);
		if(additionFeatureRootFacetSet != null) {
			//TODO ask for that to Grégoire Dupé!
			//TODO before update the source code of EMF-Facet
			final List<EPackage> sets = additionFeatureRootFacetSet.getESubpackages();
			for(final EPackage ePackage : sets) {
				if(ePackage instanceof FacetSet) {
					this.allAdditionalContents.add((FacetSet)ePackage);
				}
			}
		}
		this.allAdditionalContents.addAll(this.facetSetsUsedInTheTable);
		this.allAdditionalContents.addAll(this.management.getAdditionalFeatures(papyrusTable, contents, this.facetSetsUsedInTheTable));

	}

	/**
	 * 
	 * @see org.eclipse.core.commands.AbstractHandler#execute(org.eclipse.core.commands.ExecutionEvent)
	 * 
	 * @param event
	 * @return
	 * @throws ExecutionException
	 */
	public Object execute(final ExecutionEvent event) throws ExecutionException {

		final CompoundCommand compoundCmd = new CompoundCommand("Papyrus Show/Hide columns command");
		final PapyrusTable papyrusTable = getPapyrusTable();
		final ITableWidget widget = getTableWidget();
		final TransactionalEditingDomain domain = getEditingDomain();
		FacetSet additionFeatureRootFacetSet = getAdditionalContentsFacetSet(papyrusTable);
		if(papyrusTable != null && widget != null) {
			initField(widget, papyrusTable);
			final Collection<ETypedElement> initialSelection = new ArrayList<ETypedElement>();
			initialSelection.addAll(this.initialDirectFeatureSelected);
			initialSelection.addAll(this.initialAdditionalFeatureSelected);
			final Collection<ENamedElement> allFacetSets = new TreeSet<ENamedElement>(new EcoreENamedElementComparator());
			allFacetSets.addAll(this.facetSetsUsedInTheTable);
			allFacetSets.addAll(this.allAdditionalContents);
			FacetSet set = getAdditionalContentsFacetSet(papyrusTable);
			if(set!=null){
				allFacetSets.remove(set);
			}
			final ColumnsToShowDialog dialog = new ColumnsToShowDialog(Display.getCurrent().getActiveShell(), this.allDirectFeatures, allFacetSets, initialSelection, getLabelProvider(), new SortedColumnContentProvider());
			if(dialog.open() == Window.OK) {
				final Object[] result = dialog.getResult();
				final Set<ETypedElement> directFeatures = (Set<ETypedElement>)result[0];
				final Set<ETypedElement> additionalFeatures = (Set<ETypedElement>)result[1];
				if(!directFeatures.equals(this.initialDirectFeatureSelected)) {
					//1. get command to show/hide direct features
					final Command cmd = getShowHideDirectFeatureColumnsCommand(papyrusTable, (ITableWidgetInternal)widget, directFeatures);
					if(cmd != null) {
						compoundCmd.append(cmd);
					}
				}

				if(!additionalFeatures.equals(initialAdditionalFeatureSelected)) {
					// 2. get the command to show/hide additional contents
					final Command cmd2 = getCreateDestroyAdditonalFeatureColumnsCommand(papyrusTable, (ITableWidgetInternal)widget, additionalFeatures);
					if(cmd2 != null) {
						compoundCmd.append(cmd2);
					}
					//
					//					//3. get command to store/unstore facets
					//					final Set<FacetSet> requiredFacetSets = new HashSet<FacetSet>();
					//					final Set<FacetSet> toAddToResource = new HashSet<FacetSet>();
					//					final Set<FacetSet> uselessFacetSets = new HashSet<FacetSet>();
					//					for(final ETypedElement current : additionalFeatures) {
					//						assert (current instanceof FacetElement);
					//						final FacetSet root = getRootFacetSet((FacetElement)current);
					//						assert root != null;
					//						requiredFacetSets.add(root);
					//						if(root.eResource() == null) {
					//							toAddToResource.add(root);
					//						}
					//					}
					//
					//					if(additionFeatureRootFacetSet != null) {
					//						for(final EPackage set : additionFeatureRootFacetSet.getESubpackages()) {
					//							if(set instanceof FacetSet && !requiredFacetSets.contains(set)) {
					//								uselessFacetSets.add((FacetSet)set);//TODO and if this facetSet is required by another table
					//							}
					//						}
					//					}

					//					//4. add required facetSet to the resource
					//					if(additionFeatureRootFacetSet == null) {
					//						//we create the facetset
					//						additionFeatureRootFacetSet = EFacetFactory.eINSTANCE.createFacetSet();
					//						additionFeatureRootFacetSet.setName(this.ADDITIONAL_CONTENTS_FACET_SET_NAME);
					//						additionFeatureRootFacetSet.setNsPrefix(this.ADDITIONAL_CONTENTS_FACET_SET_PREFIX);
					//						additionFeatureRootFacetSet.setNsURI(this.ADDITIONAL_CONTENTS_FACET_SET_NS_URI);
					//						additionFeatureRootFacetSet.setDocumentation(this.ADDITIONAL_CONTENTS_FACET_SET_DOCUMENTATION);
					//						additionFeatureRootFacetSet.getESubpackages().addAll(toAddToResource);
					//						final FacetSet createdFacetSet = additionFeatureRootFacetSet;
					//						final ICommand addLocalFacetSetToResource = new AbstractTransactionalCommand(domain, "Add Additional Contents FacetSet to the resource", null) {
					//
					//							@Override
					//							protected CommandResult doExecuteWithResult(final IProgressMonitor monitor, final IAdaptable info) throws ExecutionException {
					//								papyrusTable.eResource().getContents().add(createdFacetSet);
					//								return CommandResult.newOKCommandResult();
					//							}
					//						};
					//						compoundCmd.append(new GMFtoEMFCommandWrapper(addLocalFacetSetToResource));
					//					} else if(toAddToResource != null) {
					//						final FacetSet localSet = additionFeatureRootFacetSet;
					//						final ICommand addNewFacetSetToResource = new AbstractTransactionalCommand(domain, "Add Additional Contents FacetSet to the resource", null) {
					//
					//							@Override
					//							protected CommandResult doExecuteWithResult(final IProgressMonitor monitor, final IAdaptable info) throws ExecutionException {
					//								localSet.getESubpackages().addAll(toAddToResource);
					//								return CommandResult.newOKCommandResult();
					//							}
					//						};
					//						compoundCmd.append(new GMFtoEMFCommandWrapper(addNewFacetSetToResource));
					//					}

					//5. remove useless facets set
					//TODO
				}
				if(!compoundCmd.isEmpty()) {
					domain.getCommandStack().execute(compoundCmd);
					System.out.println("fait");
				}

			}
		}
		//we clear the fields
		clearFields();
		return null;
	}

	//TODO should be moved in another classes to be used by the stereotypemanager?
	protected FacetSet getAdditionalContentsFacetSet(final PapyrusTable table) {
		FacetSet set = null;
		final Resource resource = table.eResource();
		final Iterator<EObject> iter = resource.getContents().iterator();
		while(iter.hasNext() && set == null) {
			final EObject current = iter.next();
			if(current instanceof FacetSet) {
				final FacetSet tmp = (FacetSet)current;
				if(this.ADDITIONAL_CONTENTS_FACET_SET_NS_URI.equals(tmp.getNsURI())) {
					set = tmp;
				}
			}
		}

		return set;
	}

	/**
	 * 
	 * @param papyrusTable
	 *        the papyrus table
	 * @param widget
	 *        the widget
	 * @param selectedFeatures
	 *        the direct features selected
	 * @return
	 *         the command to show/hide the required columns (we doesn't destroy columns, because EMF-Facet will cerate it, if they are required, for
	 *         the next added element in the table)
	 */
	protected Command getShowHideDirectFeatureColumnsCommand(final PapyrusTable papyrusTable, final ITableWidgetInternal widget, final Collection<ETypedElement> selectedFeatures) {
		final CompoundCommand compoundCmd = new CompoundCommand("Show/Hide direct features command");

		//1. calculus of the columns to show/add
		final List<ETypedElement> featuresToAdd = new ArrayList<ETypedElement>(selectedFeatures);
		featuresToAdd.removeAll(this.initialDirectFeatureSelected);
		//these columns should be set To Visible OR created

		//2. calculus of the columns to hide
		final List<Object> directFeaturesToHide = new ArrayList<Object>(this.initialDirectFeatureSelected);
		directFeaturesToHide.removeAll(selectedFeatures);

		//these columns should be hidden
		final List<Column> columnsToHide = new ArrayList<Column>();
		for(final Object current : directFeaturesToHide) {
			final Column toHide = this.columnsFeatureMap.get(current);
			if(toHide != null) {
				columnsToHide.add(toHide);
			}
		}

		final List<Column> columnsToShow = new ArrayList<Column>();

		//not useful for direct features
		final List<ETypedElement> columnsToCreate = new ArrayList<ETypedElement>();

		for(final Object currentColumn : featuresToAdd) {
			if(this.columnsFeatureMap.containsKey(currentColumn)) {
				columnsToShow.add(this.columnsFeatureMap.get(currentColumn));
			} else {
				columnsToCreate.add((ETypedElement)currentColumn);
			}
		}

		final TransactionalEditingDomain domain = getEditingDomain();
		final ITableWidgetInternal widgetController = widget;
		final ICommandFactory commandFactory = ICommandFactoriesRegistry.INSTANCE.getCommandFactoryFor(domain);
		final boolean putOnTheTop = false;

		final Command showHideCommand = TableInstanceCommandFactory.createShowHideColumnCommand(widgetController, domain, commandFactory, papyrusTable.getTable(), columnsToShow, columnsToHide, putOnTheTop);

		if(showHideCommand != null && showHideCommand.canExecute()) {
			compoundCmd.append(showHideCommand);
		}

		//columns to create should always be null with direct features!
		assert columnsToCreate.isEmpty();
		if(!compoundCmd.isEmpty() && compoundCmd.canExecute()) {
			return compoundCmd;
		}
		return null;

	}

	/**
	 * 
	 * @param papyrusTable
	 *        the papyrus table
	 * @param widget
	 *        the widget
	 * @param selectedAdditionalFeatures
	 *        the addtional features selected
	 * @return
	 *         the command to create and destroy the required columns (can be <code>null</code>)
	 *         /!\ EMF-Facet allows to hide EMF-Facet columns, so if such column already exists but are not visible, we show them
	 */
	private Command getCreateDestroyAdditonalFeatureColumnsCommand(final PapyrusTable papyrusTable, final ITableWidgetInternal widget, final Collection<ETypedElement> selectedAdditionalFeatures) {
		final CompoundCommand compoundCmd = new CompoundCommand("Show/Hide additional features command");

		//1. calculus of the columns to show/add
		//these columns should be set to visible or created
		final List<ETypedElement> featuresToAdd = new ArrayList<ETypedElement>(selectedAdditionalFeatures);
		featuresToAdd.removeAll(this.initialAdditionalFeatureSelected);

		//we should take into account that EMF-Facet allows to destroy AND hide columns, so some columns can already exists but are currently not visible
		final List<ETypedElement> columnsToCreate = new ArrayList<ETypedElement>();
		columnsToCreate.addAll(featuresToAdd);
		final List<Column> existingColumnsToShow = new ArrayList<Column>();

		final ListIterator<ETypedElement> iter = columnsToCreate.listIterator();
		while(iter.hasNext()) {
			final ETypedElement current = iter.next();
			if(this.columnsFeatureMap.containsKey(current)) {
				existingColumnsToShow.add(this.columnsFeatureMap.get(current));
				iter.remove();
			}
		}

		//2. calculus of the columns to hide/destroy
		final List<ETypedElement> additionalFeaturesToHide = new ArrayList<ETypedElement>(this.initialAdditionalFeatureSelected);
		additionalFeaturesToHide.removeAll(selectedAdditionalFeatures);

		final TransactionalEditingDomain domain = getEditingDomain();
		final ITableWidgetInternal widgetController = widget;

		final boolean putOnTheTop = false;

		final Set<FacetSet> facetSets = new HashSet<FacetSet>();
		for(final ETypedElement current : selectedAdditionalFeatures) {
			if(current instanceof FacetElement) {
				final FacetSet set = getRootFacetSet((FacetElement)current);
				if(set != null) {
					facetSets.add(set);
				}
			}
		}

		facetSets.addAll(papyrusTable.getTable().getFacetSets());//TODO!


		//TODO : 
		//register new facetSet into the root facetSet
		//unregister the facetset not used 
		//
		//-----------------------NEW - NEW NEW - NEW NEW //-----------------------NEW - NEW NEW - NEW NEW //-----------------------NEW - NEW NEW - NEW NEW //-----------------------NEW - NEW NEW - NEW NEW 

		//we list the required FacetSet
		//TODO : and if others facets are applied on the table? (facet not used for column but fut appearance?)
		FacetSet additionFeatureRootFacetSet = getAdditionalContentsFacetSet(papyrusTable);
		//the required facetset in the 
		final Set<FacetSet> requiredSubFacetSets = new HashSet<FacetSet>();
		final Set<FacetSet> toAddToResource = new HashSet<FacetSet>();
		for(final ETypedElement current : selectedAdditionalFeatures) {
			FacetSet root = getRootFacetSet((FacetElement)current);
			if(root.eResource()==null){
				toAddToResource.add((FacetSet)root);
				EObject container = current;
				while(container!=null){
					if(container instanceof FacetSet){
						requiredSubFacetSets.add((FacetSet)container);
					}
					container = container.eContainer();
				}
			}else if(root == additionFeatureRootFacetSet){
				EObject container = current;
				while(container!=null){
					if(container instanceof FacetSet && container!=additionFeatureRootFacetSet){
						requiredSubFacetSets.add((FacetSet)container);
					}
					container = container.eContainer();
				}
			}
		}




		//we list the useless facetset ownled by the addition contents facetset
		final Set<FacetSet> uselessFacetSets = new HashSet<FacetSet>();
		if(additionFeatureRootFacetSet != null) {
			for(final EPackage set : additionFeatureRootFacetSet.getESubpackages()) {
				if(set instanceof FacetSet && !requiredSubFacetSets.contains(set)) {
					uselessFacetSets.add((FacetSet)set);//TODO and if this facetSet is required by another table
				}
			}
		}

		//we calculate the new registered FacetSet for the addition contents facetset
		final Collection<FacetSet> newValue = new HashSet<FacetSet>();
		final Collection<FacetSet> oldValue = new HashSet<FacetSet>();
		if(additionFeatureRootFacetSet != null) {
			for(final EPackage current : additionFeatureRootFacetSet.getESubpackages()) {//TODO waiting fot he patch of 392413: FacetSet metamodel : FacetSet#getFacetSets always return a new list
				if(current instanceof FacetSet) {
					oldValue.add((FacetSet)current);
				}
			}
			newValue.addAll(oldValue);
		}
		newValue.addAll(toAddToResource);
		newValue.removeAll(uselessFacetSets);
		//TODO test if the new value and the old value are the same!

		if(!oldValue.equals(newValue)) {
			//5. register the new value for the sub facetset registred by the additional content facetset
			if(additionFeatureRootFacetSet == null) {
				//we create the facetset
				additionFeatureRootFacetSet = EFacetFactory.eINSTANCE.createFacetSet();
				additionFeatureRootFacetSet.setName(this.ADDITIONAL_CONTENTS_FACET_SET_NAME);
				additionFeatureRootFacetSet.setNsPrefix(this.ADDITIONAL_CONTENTS_FACET_SET_PREFIX);
				additionFeatureRootFacetSet.setNsURI(this.ADDITIONAL_CONTENTS_FACET_SET_NS_URI);
				additionFeatureRootFacetSet.setDocumentation(this.ADDITIONAL_CONTENTS_FACET_SET_DOCUMENTATION);
				additionFeatureRootFacetSet.getESubpackages().addAll(newValue);
				final FacetSet createdFacetSet = additionFeatureRootFacetSet;
				final ICommand addLocalFacetSetToResource = new AbstractTransactionalCommand(domain, "Add Additional Contents FacetSet to the resource", null) {

					@Override
					protected CommandResult doExecuteWithResult(final IProgressMonitor monitor, final IAdaptable info) throws ExecutionException {
						papyrusTable.eResource().getContents().add(createdFacetSet);
						return CommandResult.newOKCommandResult();
					}
				};
				compoundCmd.append(new GMFtoEMFCommandWrapper(addLocalFacetSetToResource));
			} else if(toAddToResource != null) {
				final FacetSet localSet = additionFeatureRootFacetSet;
				final ICommand addNewFacetSetToResource = new AbstractTransactionalCommand(domain, "Add Additional Contents FacetSet to the resource", null) {

					@Override
					protected CommandResult doExecuteWithResult(final IProgressMonitor monitor, final IAdaptable info) throws ExecutionException {
						localSet.getESubpackages().clear();
						localSet.getESubpackages().addAll(newValue);
						return CommandResult.newOKCommandResult();
					}
				};
				compoundCmd.append(new GMFtoEMFCommandWrapper(addNewFacetSetToResource));
			}

			//remove the additionFeatureRootFacetSet if not needed
			if(newValue.size() == 0 && additionFeatureRootFacetSet != null) {
				final FacetSet toRemove = additionFeatureRootFacetSet;
				final ICommand removeAdditionalFacetSet = new AbstractTransactionalCommand(domain, "Remove additional FacetSet from resource", null) {

					@Override
					protected CommandResult doExecuteWithResult(final IProgressMonitor monitor, final IAdaptable info) throws ExecutionException {
						papyrusTable.eResource().getContents().remove(toRemove);
						return CommandResult.newOKCommandResult();
					}
				};
				compoundCmd.append(new GMFtoEMFCommandWrapper(removeAdditionalFacetSet));
			} else if(newValue.size() != 0 && additionFeatureRootFacetSet != null) {
				facetSets.add(additionFeatureRootFacetSet);
				//facetSets.addAll(requiredSubFacetSets);//TODO so that ailleurs!
				facetSets.removeAll(requiredSubFacetSets);
			}
		}
		//END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW END OF NEW 
		final ITableCommandFactory tableCommandFactory = getTableCmdFactory(domain, papyrusTable.eResource().getResourceSet(), papyrusTable.getTable());
		final Command createColumns = tableCommandFactory.createAddColumnCommand(columnsToCreate, new ArrayList<FacetSet>(facetSets));
		if(createColumns != null && createColumns.canExecute()) {
			compoundCmd.append(createColumns);
		}


		if(additionalFeaturesToHide.size() != 0) {
			final Command removeColumns = tableCommandFactory.createRemoveColumnsCommand(additionalFeaturesToHide);
			if(removeColumns != null && removeColumns.canExecute()) {
				compoundCmd.append(removeColumns);
			}
		}
		final ICommandFactory commandFactory = ICommandFactoriesRegistry.INSTANCE.getCommandFactoryFor(domain);
		if(existingColumnsToShow.size() != 0) {
			final Command showHideCommand = TableInstanceCommandFactory.createShowHideColumnCommand(widgetController, domain, commandFactory, papyrusTable.getTable(), existingColumnsToShow, new ArrayList<Column>(), putOnTheTop);
			if(showHideCommand != null && showHideCommand.canExecute()) {
				compoundCmd.append(showHideCommand);
			}
		}

		if(!compoundCmd.isEmpty()) {
			return compoundCmd;
		}
		return null;
	}

	/**
	 * 
	 * @return
	 *         the editing domain used by this handler or <code>null</code> if not found
	 */
	private TransactionalEditingDomain getEditingDomain() {
		TransactionalEditingDomain domain = null;
		domain = TransactionUtil.getEditingDomain(getPapyrusTable());
		return domain;
	}

	/**
	 * 
	 * @return
	 *         the current table editor, or <code>null</code> if not found
	 */
	private AbstractTableEditor getCurrentTableEditor() {
		final IStructuredSelection selection = (IStructuredSelection)PlatformUI.getWorkbench().getActiveWorkbenchWindow().getSelectionService().getSelection();
		final Object current = selection.getFirstElement();
		if(current instanceof EObject) {

			IEditorPart part = null;
			try {
				part = ServiceUtilsForResource.getInstance().getNestedActiveIEditorPart(((EObject)current).eResource());
			} catch (final ServiceException e) {
				Activator.log.error(e);
			}
			if(part instanceof AbstractTableEditor) {
				return (AbstractTableEditor)part;
			}

		}
		return null;
	}

	/**
	 * 
	 * @return
	 *         the papyrus table
	 */
	private PapyrusTable getPapyrusTable() {
		final IEditorPart part = getCurrentTableEditor();
		if(part != null) {
			return (PapyrusTable)part.getAdapter(PapyrusTable.class);
		}
		return null;
	}

	/**
	 * 
	 * @return
	 *         the table widget
	 */
	private ITableWidget getTableWidget() {
		final IAdaptable editor = getCurrentTableEditor();
		final ITableWidgetProvider provider = (ITableWidgetProvider)editor.getAdapter(ITableWidgetProvider.class);
		if(provider != null) {
			return provider.getTableWidget();
		}
		return null;
	}

	/**
	 * 
	 * @return
	 *         the label provider by for the dialog
	 */
	private ILabelProvider getLabelProvider() {
		final AdapterFactory factory = new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE);
		final ILabelProvider labelProvider = new AdapterFactoryLabelProvider(factory);
		return labelProvider;
	}

	/**
	 * 
	 * @param editingDomain
	 *        the editing domain
	 * @param resourceSet
	 *        the resource set
	 * @param table
	 *        the table
	 * @return
	 *         the command factory for these parameters
	 */
	//TODO duplicated code from the AbstractTriggerListener
	private static ITableCommandFactory getTableCmdFactory(final TransactionalEditingDomain editingDomain, final ResourceSet resourceSet, final Table table) {
		final IFacetManager facetManager = IFacetManagerFactory.DEFAULT.getOrCreateFacetManager(resourceSet);
		final ICommandFactory commandFactory = ICommandFactoriesRegistry.INSTANCE.getCommandFactoryFor(editingDomain);
		return new TableCommandFactory(table, editingDomain, commandFactory, facetManager);
	}
}
